diff --git a/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp b/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
index e4d61f8c210e..d9e49c6d89e2 100644
--- a/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
+++ b/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
@@ -1,8921 +1,8941 @@
 //===-- MipsAsmParser.cpp - Parse Mips assembly to MCInst instructions ----===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
 #include "MCTargetDesc/MipsABIFlagsSection.h"
 #include "MCTargetDesc/MipsABIInfo.h"
 #include "MCTargetDesc/MipsBaseInfo.h"
 #include "MCTargetDesc/MipsMCExpr.h"
 #include "MCTargetDesc/MipsMCTargetDesc.h"
 #include "MipsTargetStreamer.h"
 #include "TargetInfo/MipsTargetInfo.h"
 #include "llvm/ADT/APFloat.h"
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/ADT/StringRef.h"
 #include "llvm/ADT/StringSwitch.h"
 #include "llvm/ADT/Triple.h"
 #include "llvm/ADT/Twine.h"
 #include "llvm/BinaryFormat/ELF.h"
 #include "llvm/MC/MCContext.h"
 #include "llvm/MC/MCExpr.h"
 #include "llvm/MC/MCInst.h"
 #include "llvm/MC/MCInstrDesc.h"
 #include "llvm/MC/MCObjectFileInfo.h"
 #include "llvm/MC/MCParser/MCAsmLexer.h"
 #include "llvm/MC/MCParser/MCAsmParser.h"
 #include "llvm/MC/MCParser/MCAsmParserExtension.h"
 #include "llvm/MC/MCParser/MCAsmParserUtils.h"
 #include "llvm/MC/MCParser/MCParsedAsmOperand.h"
 #include "llvm/MC/MCParser/MCTargetAsmParser.h"
 #include "llvm/MC/MCSectionELF.h"
 #include "llvm/MC/MCStreamer.h"
 #include "llvm/MC/MCSubtargetInfo.h"
 #include "llvm/MC/MCSymbol.h"
 #include "llvm/MC/MCSymbolELF.h"
 #include "llvm/MC/MCValue.h"
 #include "llvm/MC/SubtargetFeature.h"
 #include "llvm/Support/Alignment.h"
 #include "llvm/Support/Casting.h"
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Support/Compiler.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm/Support/MathExtras.h"
 #include "llvm/Support/SMLoc.h"
 #include "llvm/Support/SourceMgr.h"
 #include "llvm/Support/TargetRegistry.h"
 #include "llvm/Support/raw_ostream.h"
 #include <algorithm>
 #include <cassert>
 #include <cstdint>
 #include <memory>
 #include <string>
 #include <utility>
 
 using namespace llvm;
 
 #define DEBUG_TYPE "mips-asm-parser"
 
 namespace llvm {
 
 class MCInstrInfo;
 
 } // end namespace llvm
 
 extern cl::opt<bool> EmitJalrReloc;
 
 namespace {
 
 class MipsAssemblerOptions {
 public:
   MipsAssemblerOptions(const FeatureBitset &Features_) : Features(Features_) {}
 
   MipsAssemblerOptions(const MipsAssemblerOptions *Opts) {
     ATReg = Opts->getATRegIndex();
     Reorder = Opts->isReorder();
     Macro = Opts->isMacro();
     Features = Opts->getFeatures();
   }
 
   unsigned getATRegIndex() const { return ATReg; }
   bool setATRegIndex(unsigned Reg) {
     if (Reg > 31)
       return false;
 
     ATReg = Reg;
     return true;
   }
 
   bool isReorder() const { return Reorder; }
   void setReorder() { Reorder = true; }
   void setNoReorder() { Reorder = false; }
 
   bool isMacro() const { return Macro; }
   void setMacro() { Macro = true; }
   void setNoMacro() { Macro = false; }
 
   const FeatureBitset &getFeatures() const { return Features; }
   void setFeatures(const FeatureBitset &Features_) { Features = Features_; }
 
   // Set of features that are either architecture features or referenced
   // by them (e.g.: FeatureNaN2008 implied by FeatureMips32r6).
   // The full table can be found in MipsGenSubtargetInfo.inc (MipsFeatureKV[]).
   // The reason we need this mask is explained in the selectArch function.
   // FIXME: Ideally we would like TableGen to generate this information.
   static const FeatureBitset AllArchRelatedMask;
 
 private:
   unsigned ATReg = 1;
   bool Reorder = true;
   bool Macro = true;
   FeatureBitset Features;
 };
 
 } // end anonymous namespace
 
 const FeatureBitset MipsAssemblerOptions::AllArchRelatedMask = {
     Mips::FeatureMips1, Mips::FeatureMips2, Mips::FeatureMips3,
     Mips::FeatureMips3_32, Mips::FeatureMips3_32r2, Mips::FeatureMips4,
     Mips::FeatureMips4_32, Mips::FeatureMips4_32r2, Mips::FeatureMips5,
     Mips::FeatureMips5_32r2, Mips::FeatureMips32, Mips::FeatureMips32r2,
     Mips::FeatureMips32r3, Mips::FeatureMips32r5, Mips::FeatureMips32r6,
     Mips::FeatureMips64, Mips::FeatureMips64r2, Mips::FeatureMips64r3,
     Mips::FeatureMips64r5, Mips::FeatureMips64r6, Mips::FeatureCnMips,
     Mips::FeatureCnMipsP, Mips::FeatureFP64Bit, Mips::FeatureGP64Bit,
     Mips::FeatureNaN2008
 };
 
 namespace {
 
 class MipsAsmParser : public MCTargetAsmParser {
   MipsTargetStreamer &getTargetStreamer() {
     assert(getParser().getStreamer().getTargetStreamer() &&
            "do not have a target streamer");
     MCTargetStreamer &TS = *getParser().getStreamer().getTargetStreamer();
     return static_cast<MipsTargetStreamer &>(TS);
   }
 
   MipsABIInfo ABI;
   SmallVector<std::unique_ptr<MipsAssemblerOptions>, 2> AssemblerOptions;
   MCSymbol *CurrentFn; // Pointer to the function being parsed. It may be a
                        // nullptr, which indicates that no function is currently
                        // selected. This usually happens after an '.end func'
                        // directive.
   bool IsLittleEndian;
   bool IsPicEnabled;
   bool IsCpRestoreSet;
   int CpRestoreOffset;
   unsigned GPReg;
   unsigned CpSaveLocation;
   /// If true, then CpSaveLocation is a register, otherwise it's an offset.
   bool     CpSaveLocationIsRegister;
 
   // Map of register aliases created via the .set directive.
   StringMap<AsmToken> RegisterSets;
 
   // Print a warning along with its fix-it message at the given range.
   void printWarningWithFixIt(const Twine &Msg, const Twine &FixMsg,
                              SMRange Range, bool ShowColors = true);
 
   void ConvertXWPOperands(MCInst &Inst, const OperandVector &Operands);
 
 #define GET_ASSEMBLER_HEADER
 #include "MipsGenAsmMatcher.inc"
 
   unsigned
   checkEarlyTargetMatchPredicate(MCInst &Inst,
                                  const OperandVector &Operands) override;
   unsigned checkTargetMatchPredicate(MCInst &Inst) override;
 
   bool MatchAndEmitInstruction(SMLoc IDLoc, unsigned &Opcode,
                                OperandVector &Operands, MCStreamer &Out,
                                uint64_t &ErrorInfo,
                                bool MatchingInlineAsm) override;
 
   /// Parse a register as used in CFI directives
   bool ParseRegister(unsigned &RegNo, SMLoc &StartLoc, SMLoc &EndLoc) override;
   OperandMatchResultTy tryParseRegister(unsigned &RegNo, SMLoc &StartLoc,
                                         SMLoc &EndLoc) override;
 
   bool parseParenSuffix(StringRef Name, OperandVector &Operands);
 
   bool parseBracketSuffix(StringRef Name, OperandVector &Operands);
 
   bool mnemonicIsValid(StringRef Mnemonic, unsigned VariantID);
 
   bool ParseInstruction(ParseInstructionInfo &Info, StringRef Name,
                         SMLoc NameLoc, OperandVector &Operands) override;
 
   bool ParseDirective(AsmToken DirectiveID) override;
 
   OperandMatchResultTy parseMemOperand(OperandVector &Operands);
   OperandMatchResultTy
   matchAnyRegisterNameWithoutDollar(OperandVector &Operands,
                                     StringRef Identifier, SMLoc S);
   OperandMatchResultTy matchAnyRegisterWithoutDollar(OperandVector &Operands,
                                                      const AsmToken &Token,
                                                      SMLoc S);
   OperandMatchResultTy matchAnyRegisterWithoutDollar(OperandVector &Operands,
                                                      SMLoc S);
   OperandMatchResultTy parseAnyRegister(OperandVector &Operands);
   OperandMatchResultTy parseImm(OperandVector &Operands);
   OperandMatchResultTy parseJumpTarget(OperandVector &Operands);
   OperandMatchResultTy parseInvNum(OperandVector &Operands);
   OperandMatchResultTy parseRegisterList(OperandVector &Operands);
 
   bool searchSymbolAlias(OperandVector &Operands);
 
   bool parseOperand(OperandVector &, StringRef Mnemonic);
 
   enum MacroExpanderResultTy {
     MER_NotAMacro,
     MER_Success,
     MER_Fail,
   };
 
   // Expands assembly pseudo instructions.
   MacroExpanderResultTy tryExpandInstruction(MCInst &Inst, SMLoc IDLoc,
                                              MCStreamer &Out,
                                              const MCSubtargetInfo *STI);
 
   bool expandJalWithRegs(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                          const MCSubtargetInfo *STI);
 
   bool loadImmediate(int64_t ImmValue, unsigned DstReg, unsigned SrcReg,
                      bool Is32BitImm, bool IsAddress, SMLoc IDLoc,
                      MCStreamer &Out, const MCSubtargetInfo *STI);
 
   bool loadAndAddSymbolAddress(const MCExpr *SymExpr, unsigned DstReg,
                                unsigned SrcReg, bool Is32BitSym, SMLoc IDLoc,
                                MCStreamer &Out, const MCSubtargetInfo *STI);
 
   bool emitPartialAddress(MipsTargetStreamer &TOut, SMLoc IDLoc, MCSymbol *Sym);
 
   bool expandLoadImm(MCInst &Inst, bool Is32BitImm, SMLoc IDLoc,
                      MCStreamer &Out, const MCSubtargetInfo *STI);
 
   bool expandLoadSingleImmToGPR(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                 const MCSubtargetInfo *STI);
   bool expandLoadSingleImmToFPR(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                 const MCSubtargetInfo *STI);
   bool expandLoadDoubleImmToGPR(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                 const MCSubtargetInfo *STI);
   bool expandLoadDoubleImmToFPR(MCInst &Inst, bool Is64FPU, SMLoc IDLoc,
                                 MCStreamer &Out, const MCSubtargetInfo *STI);
 
   bool expandLoadAddress(unsigned DstReg, unsigned BaseReg,
                          const MCOperand &Offset, bool Is32BitAddress,
                          SMLoc IDLoc, MCStreamer &Out,
                          const MCSubtargetInfo *STI);
 
   bool expandUncondBranchMMPseudo(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                   const MCSubtargetInfo *STI);
 
   void expandMem16Inst(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                        const MCSubtargetInfo *STI, bool IsLoad);
   void expandMem9Inst(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                       const MCSubtargetInfo *STI, bool IsLoad);
 
   bool expandLoadStoreMultiple(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                const MCSubtargetInfo *STI);
 
   bool expandAliasImmediate(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                             const MCSubtargetInfo *STI);
 
   bool expandBranchImm(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                        const MCSubtargetInfo *STI);
 
   bool expandCondBranches(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                           const MCSubtargetInfo *STI);
 
   bool expandDivRem(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                     const MCSubtargetInfo *STI, const bool IsMips64,
                     const bool Signed);
 
   bool expandTrunc(MCInst &Inst, bool IsDouble, bool Is64FPU, SMLoc IDLoc,
                    MCStreamer &Out, const MCSubtargetInfo *STI);
 
   bool expandUlh(MCInst &Inst, bool Signed, SMLoc IDLoc, MCStreamer &Out,
                  const MCSubtargetInfo *STI);
 
   bool expandUsh(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                  const MCSubtargetInfo *STI);
 
   bool expandUxw(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                  const MCSubtargetInfo *STI);
 
   bool expandSge(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                  const MCSubtargetInfo *STI);
 
   bool expandSgeImm(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                     const MCSubtargetInfo *STI);
 
   bool expandSgtImm(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                     const MCSubtargetInfo *STI);
 
   bool expandSle(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                  const MCSubtargetInfo *STI);
 
   bool expandSleImm(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                     const MCSubtargetInfo *STI);
 
   bool expandRotation(MCInst &Inst, SMLoc IDLoc,
                       MCStreamer &Out, const MCSubtargetInfo *STI);
   bool expandRotationImm(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                          const MCSubtargetInfo *STI);
   bool expandDRotation(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                        const MCSubtargetInfo *STI);
   bool expandDRotationImm(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                           const MCSubtargetInfo *STI);
 
   bool expandAbs(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                  const MCSubtargetInfo *STI);
 
   bool expandMulImm(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                     const MCSubtargetInfo *STI);
 
   bool expandMulO(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                   const MCSubtargetInfo *STI);
 
   bool expandMulOU(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                    const MCSubtargetInfo *STI);
 
   bool expandDMULMacro(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                        const MCSubtargetInfo *STI);
 
   bool expandLoadStoreDMacro(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                              const MCSubtargetInfo *STI, bool IsLoad);
 
   bool expandStoreDM1Macro(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                            const MCSubtargetInfo *STI);
 
   bool expandSeq(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                  const MCSubtargetInfo *STI);
 
   bool expandSeqI(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                   const MCSubtargetInfo *STI);
 
   bool expandSne(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                  const MCSubtargetInfo *STI);
 
   bool expandSneI(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                   const MCSubtargetInfo *STI);
 
   bool expandMXTRAlias(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                        const MCSubtargetInfo *STI);
 
   bool expandSaaAddr(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                      const MCSubtargetInfo *STI);
 
   bool reportParseError(const Twine &ErrorMsg);
   bool reportParseError(SMLoc Loc, const Twine &ErrorMsg);
 
   bool parseMemOffset(const MCExpr *&Res, bool isParenExpr);
 
   bool parseSetMips0Directive();
   bool parseSetArchDirective();
   bool parseSetFeature(uint64_t Feature);
   bool isPicAndNotNxxAbi(); // Used by .cpload, .cprestore, and .cpsetup.
   bool parseDirectiveCpAdd(SMLoc Loc);
   bool parseDirectiveCpLoad(SMLoc Loc);
   bool parseDirectiveCpLocal(SMLoc Loc);
   bool parseDirectiveCpRestore(SMLoc Loc);
   bool parseDirectiveCPSetup();
   bool parseDirectiveCPReturn();
   bool parseDirectiveNaN();
   bool parseDirectiveSet();
   bool parseDirectiveOption();
   bool parseInsnDirective();
   bool parseRSectionDirective(StringRef Section);
   bool parseSSectionDirective(StringRef Section, unsigned Type);
 
   bool parseSetAtDirective();
   bool parseSetNoAtDirective();
   bool parseSetMacroDirective();
   bool parseSetNoMacroDirective();
   bool parseSetMsaDirective();
   bool parseSetNoMsaDirective();
   bool parseSetNoDspDirective();
   bool parseSetNoMips3DDirective();
   bool parseSetReorderDirective();
   bool parseSetNoReorderDirective();
   bool parseSetMips16Directive();
   bool parseSetNoMips16Directive();
   bool parseSetFpDirective();
   bool parseSetOddSPRegDirective();
   bool parseSetNoOddSPRegDirective();
   bool parseSetPopDirective();
   bool parseSetPushDirective();
   bool parseSetSoftFloatDirective();
   bool parseSetHardFloatDirective();
   bool parseSetMtDirective();
   bool parseSetNoMtDirective();
   bool parseSetNoCRCDirective();
   bool parseSetNoVirtDirective();
   bool parseSetNoGINVDirective();
 
   bool parseSetAssignment();
 
   bool parseDirectiveGpWord();
   bool parseDirectiveGpDWord();
   bool parseDirectiveDtpRelWord();
   bool parseDirectiveDtpRelDWord();
   bool parseDirectiveTpRelWord();
   bool parseDirectiveTpRelDWord();
   bool parseDirectiveModule();
   bool parseDirectiveModuleFP();
   bool parseFpABIValue(MipsABIFlagsSection::FpABIKind &FpABI,
                        StringRef Directive);
 
   bool parseInternalDirectiveReallowModule();
 
   bool eatComma(StringRef ErrorStr);
 
   int matchCPURegisterName(StringRef Symbol);
 
   int matchHWRegsRegisterName(StringRef Symbol);
 
   int matchFPURegisterName(StringRef Name);
 
   int matchFCCRegisterName(StringRef Name);
 
   int matchACRegisterName(StringRef Name);
 
   int matchMSA128RegisterName(StringRef Name);
 
   int matchMSA128CtrlRegisterName(StringRef Name);
 
   unsigned getReg(int RC, int RegNo);
 
   /// Returns the internal register number for the current AT. Also checks if
   /// the current AT is unavailable (set to $0) and gives an error if it is.
   /// This should be used in pseudo-instruction expansions which need AT.
   unsigned getATReg(SMLoc Loc);
 
   bool canUseATReg();
 
   bool processInstruction(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                           const MCSubtargetInfo *STI);
 
   // Helper function that checks if the value of a vector index is within the
   // boundaries of accepted values for each RegisterKind
   // Example: INSERT.B $w0[n], $1 => 16 > n >= 0
   bool validateMSAIndex(int Val, int RegKind);
 
   // Selects a new architecture by updating the FeatureBits with the necessary
   // info including implied dependencies.
   // Internally, it clears all the feature bits related to *any* architecture
   // and selects the new one using the ToggleFeature functionality of the
   // MCSubtargetInfo object that handles implied dependencies. The reason we
   // clear all the arch related bits manually is because ToggleFeature only
   // clears the features that imply the feature being cleared and not the
   // features implied by the feature being cleared. This is easier to see
   // with an example:
   //  --------------------------------------------------
   // | Feature         | Implies                        |
   // | -------------------------------------------------|
   // | FeatureMips1    | None                           |
   // | FeatureMips2    | FeatureMips1                   |
   // | FeatureMips3    | FeatureMips2 | FeatureMipsGP64 |
   // | FeatureMips4    | FeatureMips3                   |
   // | ...             |                                |
   //  --------------------------------------------------
   //
   // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |
   // FeatureMipsGP64 | FeatureMips1)
   // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).
   void selectArch(StringRef ArchFeature) {
     MCSubtargetInfo &STI = copySTI();
     FeatureBitset FeatureBits = STI.getFeatureBits();
     FeatureBits &= ~MipsAssemblerOptions::AllArchRelatedMask;
     STI.setFeatureBits(FeatureBits);
     setAvailableFeatures(
         ComputeAvailableFeatures(STI.ToggleFeature(ArchFeature)));
     AssemblerOptions.back()->setFeatures(STI.getFeatureBits());
   }
 
   void setFeatureBits(uint64_t Feature, StringRef FeatureString) {
     if (!(getSTI().getFeatureBits()[Feature])) {
       MCSubtargetInfo &STI = copySTI();
       setAvailableFeatures(
           ComputeAvailableFeatures(STI.ToggleFeature(FeatureString)));
       AssemblerOptions.back()->setFeatures(STI.getFeatureBits());
     }
   }
 
   void clearFeatureBits(uint64_t Feature, StringRef FeatureString) {
     if (getSTI().getFeatureBits()[Feature]) {
       MCSubtargetInfo &STI = copySTI();
       setAvailableFeatures(
           ComputeAvailableFeatures(STI.ToggleFeature(FeatureString)));
       AssemblerOptions.back()->setFeatures(STI.getFeatureBits());
     }
   }
 
   void setModuleFeatureBits(uint64_t Feature, StringRef FeatureString) {
     setFeatureBits(Feature, FeatureString);
     AssemblerOptions.front()->setFeatures(getSTI().getFeatureBits());
   }
 
   void clearModuleFeatureBits(uint64_t Feature, StringRef FeatureString) {
     clearFeatureBits(Feature, FeatureString);
     AssemblerOptions.front()->setFeatures(getSTI().getFeatureBits());
   }
 
 public:
   enum MipsMatchResultTy {
     Match_RequiresDifferentSrcAndDst = FIRST_TARGET_MATCH_RESULT_TY,
     Match_RequiresDifferentOperands,
     Match_RequiresNoZeroRegister,
     Match_RequiresSameSrcAndDst,
     Match_NoFCCRegisterForCurrentISA,
     Match_NonZeroOperandForSync,
     Match_NonZeroOperandForMTCX,
     Match_RequiresPosSizeRange0_32,
     Match_RequiresPosSizeRange33_64,
     Match_RequiresPosSizeUImm6,
 #define GET_OPERAND_DIAGNOSTIC_TYPES
 #include "MipsGenAsmMatcher.inc"
 #undef GET_OPERAND_DIAGNOSTIC_TYPES
   };
 
   MipsAsmParser(const MCSubtargetInfo &sti, MCAsmParser &parser,
                 const MCInstrInfo &MII, const MCTargetOptions &Options)
     : MCTargetAsmParser(Options, sti, MII),
         ABI(MipsABIInfo::computeTargetABI(Triple(sti.getTargetTriple()),
                                           sti.getCPU(), Options)) {
     MCAsmParserExtension::Initialize(parser);
 
     parser.addAliasForDirective(".asciiz", ".asciz");
     parser.addAliasForDirective(".hword", ".2byte");
     parser.addAliasForDirective(".word", ".4byte");
     parser.addAliasForDirective(".dword", ".8byte");
 
     // Initialize the set of available features.
     setAvailableFeatures(ComputeAvailableFeatures(getSTI().getFeatureBits()));
 
     // Remember the initial assembler options. The user can not modify these.
     AssemblerOptions.push_back(
         std::make_unique<MipsAssemblerOptions>(getSTI().getFeatureBits()));
 
     // Create an assembler options environment for the user to modify.
     AssemblerOptions.push_back(
         std::make_unique<MipsAssemblerOptions>(getSTI().getFeatureBits()));
 
     getTargetStreamer().updateABIInfo(*this);
 
     if (!isABI_O32() && !useOddSPReg() != 0)
       report_fatal_error("-mno-odd-spreg requires the O32 ABI");
 
     CurrentFn = nullptr;
 
     IsPicEnabled = getContext().getObjectFileInfo()->isPositionIndependent();
 
     IsCpRestoreSet = false;
     CpRestoreOffset = -1;
     GPReg = ABI.GetGlobalPtr();
 
     const Triple &TheTriple = sti.getTargetTriple();
     IsLittleEndian = TheTriple.isLittleEndian();
 
     if (getSTI().getCPU() == "mips64r6" && inMicroMipsMode())
       report_fatal_error("microMIPS64R6 is not supported", false);
 
     if (!isABI_O32() && inMicroMipsMode())
       report_fatal_error("microMIPS64 is not supported", false);
   }
 
   /// True if all of $fcc0 - $fcc7 exist for the current ISA.
   bool hasEightFccRegisters() const { return hasMips4() || hasMips32(); }
 
   bool isGP64bit() const {
     return getSTI().getFeatureBits()[Mips::FeatureGP64Bit];
   }
 
   bool isFP64bit() const {
     return getSTI().getFeatureBits()[Mips::FeatureFP64Bit];
   }
 
   bool isJalrRelocAvailable(const MCExpr *JalExpr) {
     if (!EmitJalrReloc)
       return false;
     MCValue Res;
     if (!JalExpr->evaluateAsRelocatable(Res, nullptr, nullptr))
       return false;
     if (Res.getSymB() != nullptr)
       return false;
     if (Res.getConstant() != 0)
       return ABI.IsN32() || ABI.IsN64();
     return true;
   }
 
   const MipsABIInfo &getABI() const { return ABI; }
   bool isABI_N32() const { return ABI.IsN32(); }
   bool isABI_N64() const { return ABI.IsN64(); }
   bool isABI_O32() const { return ABI.IsO32(); }
   bool isABI_FPXX() const {
     return getSTI().getFeatureBits()[Mips::FeatureFPXX];
   }
 
   bool useOddSPReg() const {
     return !(getSTI().getFeatureBits()[Mips::FeatureNoOddSPReg]);
   }
 
   bool inMicroMipsMode() const {
     return getSTI().getFeatureBits()[Mips::FeatureMicroMips];
   }
 
   bool hasMips1() const {
     return getSTI().getFeatureBits()[Mips::FeatureMips1];
   }
 
   bool hasMips2() const {
     return getSTI().getFeatureBits()[Mips::FeatureMips2];
   }
 
   bool hasMips3() const {
     return getSTI().getFeatureBits()[Mips::FeatureMips3];
   }
 
   bool hasMips4() const {
     return getSTI().getFeatureBits()[Mips::FeatureMips4];
   }
 
   bool hasMips5() const {
     return getSTI().getFeatureBits()[Mips::FeatureMips5];
   }
 
   bool hasMips32() const {
     return getSTI().getFeatureBits()[Mips::FeatureMips32];
   }
 
   bool hasMips64() const {
     return getSTI().getFeatureBits()[Mips::FeatureMips64];
   }
 
   bool hasMips32r2() const {
     return getSTI().getFeatureBits()[Mips::FeatureMips32r2];
   }
 
   bool hasMips64r2() const {
     return getSTI().getFeatureBits()[Mips::FeatureMips64r2];
   }
 
   bool hasMips32r3() const {
     return (getSTI().getFeatureBits()[Mips::FeatureMips32r3]);
   }
 
   bool hasMips64r3() const {
     return (getSTI().getFeatureBits()[Mips::FeatureMips64r3]);
   }
 
   bool hasMips32r5() const {
     return (getSTI().getFeatureBits()[Mips::FeatureMips32r5]);
   }
 
   bool hasMips64r5() const {
     return (getSTI().getFeatureBits()[Mips::FeatureMips64r5]);
   }
 
   bool hasMips32r6() const {
     return getSTI().getFeatureBits()[Mips::FeatureMips32r6];
   }
 
   bool hasMips64r6() const {
     return getSTI().getFeatureBits()[Mips::FeatureMips64r6];
   }
 
   bool hasDSP() const {
     return getSTI().getFeatureBits()[Mips::FeatureDSP];
   }
 
   bool hasDSPR2() const {
     return getSTI().getFeatureBits()[Mips::FeatureDSPR2];
   }
 
   bool hasDSPR3() const {
     return getSTI().getFeatureBits()[Mips::FeatureDSPR3];
   }
 
   bool hasMSA() const {
     return getSTI().getFeatureBits()[Mips::FeatureMSA];
   }
 
   bool hasCnMips() const {
     return (getSTI().getFeatureBits()[Mips::FeatureCnMips]);
   }
 
   bool hasCnMipsP() const {
     return (getSTI().getFeatureBits()[Mips::FeatureCnMipsP]);
   }
 
   bool inPicMode() {
     return IsPicEnabled;
   }
 
   bool inMips16Mode() const {
     return getSTI().getFeatureBits()[Mips::FeatureMips16];
   }
 
   bool useTraps() const {
     return getSTI().getFeatureBits()[Mips::FeatureUseTCCInDIV];
   }
 
   bool useSoftFloat() const {
     return getSTI().getFeatureBits()[Mips::FeatureSoftFloat];
   }
   bool hasMT() const {
     return getSTI().getFeatureBits()[Mips::FeatureMT];
   }
 
   bool hasCRC() const {
     return getSTI().getFeatureBits()[Mips::FeatureCRC];
   }
 
   bool hasVirt() const {
     return getSTI().getFeatureBits()[Mips::FeatureVirt];
   }
 
   bool hasGINV() const {
     return getSTI().getFeatureBits()[Mips::FeatureGINV];
   }
 
   /// Warn if RegIndex is the same as the current AT.
   void warnIfRegIndexIsAT(unsigned RegIndex, SMLoc Loc);
 
   void warnIfNoMacro(SMLoc Loc);
 
   bool isLittle() const { return IsLittleEndian; }
 
   const MCExpr *createTargetUnaryExpr(const MCExpr *E,
                                       AsmToken::TokenKind OperatorToken,
                                       MCContext &Ctx) override {
     switch(OperatorToken) {
     default:
       llvm_unreachable("Unknown token");
       return nullptr;
     case AsmToken::PercentCall16:
       return MipsMCExpr::create(MipsMCExpr::MEK_GOT_CALL, E, Ctx);
     case AsmToken::PercentCall_Hi:
       return MipsMCExpr::create(MipsMCExpr::MEK_CALL_HI16, E, Ctx);
     case AsmToken::PercentCall_Lo:
       return MipsMCExpr::create(MipsMCExpr::MEK_CALL_LO16, E, Ctx);
     case AsmToken::PercentDtprel_Hi:
       return MipsMCExpr::create(MipsMCExpr::MEK_DTPREL_HI, E, Ctx);
     case AsmToken::PercentDtprel_Lo:
       return MipsMCExpr::create(MipsMCExpr::MEK_DTPREL_LO, E, Ctx);
     case AsmToken::PercentGot:
       return MipsMCExpr::create(MipsMCExpr::MEK_GOT, E, Ctx);
     case AsmToken::PercentGot_Disp:
       return MipsMCExpr::create(MipsMCExpr::MEK_GOT_DISP, E, Ctx);
     case AsmToken::PercentGot_Hi:
       return MipsMCExpr::create(MipsMCExpr::MEK_GOT_HI16, E, Ctx);
     case AsmToken::PercentGot_Lo:
       return MipsMCExpr::create(MipsMCExpr::MEK_GOT_LO16, E, Ctx);
     case AsmToken::PercentGot_Ofst:
       return MipsMCExpr::create(MipsMCExpr::MEK_GOT_OFST, E, Ctx);
     case AsmToken::PercentGot_Page:
       return MipsMCExpr::create(MipsMCExpr::MEK_GOT_PAGE, E, Ctx);
     case AsmToken::PercentGottprel:
       return MipsMCExpr::create(MipsMCExpr::MEK_GOTTPREL, E, Ctx);
     case AsmToken::PercentGp_Rel:
       return MipsMCExpr::create(MipsMCExpr::MEK_GPREL, E, Ctx);
     case AsmToken::PercentHi:
       return MipsMCExpr::create(MipsMCExpr::MEK_HI, E, Ctx);
     case AsmToken::PercentHigher:
       return MipsMCExpr::create(MipsMCExpr::MEK_HIGHER, E, Ctx);
     case AsmToken::PercentHighest:
       return MipsMCExpr::create(MipsMCExpr::MEK_HIGHEST, E, Ctx);
     case AsmToken::PercentLo:
       return MipsMCExpr::create(MipsMCExpr::MEK_LO, E, Ctx);
     case AsmToken::PercentNeg:
       return MipsMCExpr::create(MipsMCExpr::MEK_NEG, E, Ctx);
     case AsmToken::PercentPcrel_Hi:
       return MipsMCExpr::create(MipsMCExpr::MEK_PCREL_HI16, E, Ctx);
     case AsmToken::PercentPcrel_Lo:
       return MipsMCExpr::create(MipsMCExpr::MEK_PCREL_LO16, E, Ctx);
     case AsmToken::PercentTlsgd:
       return MipsMCExpr::create(MipsMCExpr::MEK_TLSGD, E, Ctx);
     case AsmToken::PercentTlsldm:
       return MipsMCExpr::create(MipsMCExpr::MEK_TLSLDM, E, Ctx);
     case AsmToken::PercentTprel_Hi:
       return MipsMCExpr::create(MipsMCExpr::MEK_TPREL_HI, E, Ctx);
     case AsmToken::PercentTprel_Lo:
       return MipsMCExpr::create(MipsMCExpr::MEK_TPREL_LO, E, Ctx);
     }
   }
 };
 
 /// MipsOperand - Instances of this class represent a parsed Mips machine
 /// instruction.
 class MipsOperand : public MCParsedAsmOperand {
 public:
   /// Broad categories of register classes
   /// The exact class is finalized by the render method.
   enum RegKind {
     RegKind_GPR = 1,      /// GPR32 and GPR64 (depending on isGP64bit())
     RegKind_FGR = 2,      /// FGR32, FGR64, AFGR64 (depending on context and
                           /// isFP64bit())
     RegKind_FCC = 4,      /// FCC
     RegKind_MSA128 = 8,   /// MSA128[BHWD] (makes no difference which)
     RegKind_MSACtrl = 16, /// MSA control registers
     RegKind_COP2 = 32,    /// COP2
     RegKind_ACC = 64,     /// HI32DSP, LO32DSP, and ACC64DSP (depending on
                           /// context).
     RegKind_CCR = 128,    /// CCR
     RegKind_HWRegs = 256, /// HWRegs
     RegKind_COP3 = 512,   /// COP3
     RegKind_COP0 = 1024,  /// COP0
     /// Potentially any (e.g. $1)
     RegKind_Numeric = RegKind_GPR | RegKind_FGR | RegKind_FCC | RegKind_MSA128 |
                       RegKind_MSACtrl | RegKind_COP2 | RegKind_ACC |
                       RegKind_CCR | RegKind_HWRegs | RegKind_COP3 | RegKind_COP0
   };
 
 private:
   enum KindTy {
     k_Immediate,     /// An immediate (possibly involving symbol references)
     k_Memory,        /// Base + Offset Memory Address
     k_RegisterIndex, /// A register index in one or more RegKind.
     k_Token,         /// A simple token
     k_RegList,       /// A physical register list
   } Kind;
 
 public:
   MipsOperand(KindTy K, MipsAsmParser &Parser)
       : MCParsedAsmOperand(), Kind(K), AsmParser(Parser) {}
 
   ~MipsOperand() override {
     switch (Kind) {
     case k_Memory:
       delete Mem.Base;
       break;
     case k_RegList:
       delete RegList.List;
       break;
     case k_Immediate:
     case k_RegisterIndex:
     case k_Token:
       break;
     }
   }
 
 private:
   /// For diagnostics, and checking the assembler temporary
   MipsAsmParser &AsmParser;
 
   struct Token {
     const char *Data;
     unsigned Length;
   };
 
   struct RegIdxOp {
     unsigned Index; /// Index into the register class
     RegKind Kind;   /// Bitfield of the kinds it could possibly be
     struct Token Tok; /// The input token this operand originated from.
     const MCRegisterInfo *RegInfo;
   };
 
   struct ImmOp {
     const MCExpr *Val;
   };
 
   struct MemOp {
     MipsOperand *Base;
     const MCExpr *Off;
   };
 
   struct RegListOp {
     SmallVector<unsigned, 10> *List;
   };
 
   union {
     struct Token Tok;
     struct RegIdxOp RegIdx;
     struct ImmOp Imm;
     struct MemOp Mem;
     struct RegListOp RegList;
   };
 
   SMLoc StartLoc, EndLoc;
 
   /// Internal constructor for register kinds
   static std::unique_ptr<MipsOperand> CreateReg(unsigned Index, StringRef Str,
                                                 RegKind RegKind,
                                                 const MCRegisterInfo *RegInfo,
                                                 SMLoc S, SMLoc E,
                                                 MipsAsmParser &Parser) {
     auto Op = std::make_unique<MipsOperand>(k_RegisterIndex, Parser);
     Op->RegIdx.Index = Index;
     Op->RegIdx.RegInfo = RegInfo;
     Op->RegIdx.Kind = RegKind;
     Op->RegIdx.Tok.Data = Str.data();
     Op->RegIdx.Tok.Length = Str.size();
     Op->StartLoc = S;
     Op->EndLoc = E;
     return Op;
   }
 
 public:
   /// Coerce the register to GPR32 and return the real register for the current
   /// target.
   unsigned getGPR32Reg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_GPR) && "Invalid access!");
     AsmParser.warnIfRegIndexIsAT(RegIdx.Index, StartLoc);
     unsigned ClassID = Mips::GPR32RegClassID;
     return RegIdx.RegInfo->getRegClass(ClassID).getRegister(RegIdx.Index);
   }
 
   /// Coerce the register to GPR32 and return the real register for the current
   /// target.
   unsigned getGPRMM16Reg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_GPR) && "Invalid access!");
     unsigned ClassID = Mips::GPR32RegClassID;
     return RegIdx.RegInfo->getRegClass(ClassID).getRegister(RegIdx.Index);
   }
 
+  /// Coerce the register to GPR32 and return the real register for the current
+  /// target.
+  unsigned getCPU16Reg() const {
+    assert(isRegIdx() && (RegIdx.Kind & RegKind_GPR) && "Invalid access!");
+    unsigned ClassID = Mips::GPR32RegClassID;
+    return RegIdx.RegInfo->getRegClass(ClassID).getRegister(RegIdx.Index);
+  }
+
   /// Coerce the register to GPR64 and return the real register for the current
   /// target.
   unsigned getGPR64Reg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_GPR) && "Invalid access!");
     unsigned ClassID = Mips::GPR64RegClassID;
     return RegIdx.RegInfo->getRegClass(ClassID).getRegister(RegIdx.Index);
   }
 
 private:
   /// Coerce the register to AFGR64 and return the real register for the current
   /// target.
   unsigned getAFGR64Reg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_FGR) && "Invalid access!");
     if (RegIdx.Index % 2 != 0)
       AsmParser.Warning(StartLoc, "Float register should be even.");
     return RegIdx.RegInfo->getRegClass(Mips::AFGR64RegClassID)
         .getRegister(RegIdx.Index / 2);
   }
 
   /// Coerce the register to FGR64 and return the real register for the current
   /// target.
   unsigned getFGR64Reg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_FGR) && "Invalid access!");
     return RegIdx.RegInfo->getRegClass(Mips::FGR64RegClassID)
         .getRegister(RegIdx.Index);
   }
 
   /// Coerce the register to FGR32 and return the real register for the current
   /// target.
   unsigned getFGR32Reg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_FGR) && "Invalid access!");
     return RegIdx.RegInfo->getRegClass(Mips::FGR32RegClassID)
         .getRegister(RegIdx.Index);
   }
 
   /// Coerce the register to FCC and return the real register for the current
   /// target.
   unsigned getFCCReg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_FCC) && "Invalid access!");
     return RegIdx.RegInfo->getRegClass(Mips::FCCRegClassID)
         .getRegister(RegIdx.Index);
   }
 
   /// Coerce the register to MSA128 and return the real register for the current
   /// target.
   unsigned getMSA128Reg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_MSA128) && "Invalid access!");
     // It doesn't matter which of the MSA128[BHWD] classes we use. They are all
     // identical
     unsigned ClassID = Mips::MSA128BRegClassID;
     return RegIdx.RegInfo->getRegClass(ClassID).getRegister(RegIdx.Index);
   }
 
   /// Coerce the register to MSACtrl and return the real register for the
   /// current target.
   unsigned getMSACtrlReg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_MSACtrl) && "Invalid access!");
     unsigned ClassID = Mips::MSACtrlRegClassID;
     return RegIdx.RegInfo->getRegClass(ClassID).getRegister(RegIdx.Index);
   }
 
   /// Coerce the register to COP0 and return the real register for the
   /// current target.
   unsigned getCOP0Reg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_COP0) && "Invalid access!");
     unsigned ClassID = Mips::COP0RegClassID;
     return RegIdx.RegInfo->getRegClass(ClassID).getRegister(RegIdx.Index);
   }
 
   /// Coerce the register to COP2 and return the real register for the
   /// current target.
   unsigned getCOP2Reg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_COP2) && "Invalid access!");
     unsigned ClassID = Mips::COP2RegClassID;
     return RegIdx.RegInfo->getRegClass(ClassID).getRegister(RegIdx.Index);
   }
 
   /// Coerce the register to COP3 and return the real register for the
   /// current target.
   unsigned getCOP3Reg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_COP3) && "Invalid access!");
     unsigned ClassID = Mips::COP3RegClassID;
     return RegIdx.RegInfo->getRegClass(ClassID).getRegister(RegIdx.Index);
   }
 
   /// Coerce the register to ACC64DSP and return the real register for the
   /// current target.
   unsigned getACC64DSPReg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_ACC) && "Invalid access!");
     unsigned ClassID = Mips::ACC64DSPRegClassID;
     return RegIdx.RegInfo->getRegClass(ClassID).getRegister(RegIdx.Index);
   }
 
   /// Coerce the register to HI32DSP and return the real register for the
   /// current target.
   unsigned getHI32DSPReg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_ACC) && "Invalid access!");
     unsigned ClassID = Mips::HI32DSPRegClassID;
     return RegIdx.RegInfo->getRegClass(ClassID).getRegister(RegIdx.Index);
   }
 
   /// Coerce the register to LO32DSP and return the real register for the
   /// current target.
   unsigned getLO32DSPReg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_ACC) && "Invalid access!");
     unsigned ClassID = Mips::LO32DSPRegClassID;
     return RegIdx.RegInfo->getRegClass(ClassID).getRegister(RegIdx.Index);
   }
 
   /// Coerce the register to CCR and return the real register for the
   /// current target.
   unsigned getCCRReg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_CCR) && "Invalid access!");
     unsigned ClassID = Mips::CCRRegClassID;
     return RegIdx.RegInfo->getRegClass(ClassID).getRegister(RegIdx.Index);
   }
 
   /// Coerce the register to HWRegs and return the real register for the
   /// current target.
   unsigned getHWRegsReg() const {
     assert(isRegIdx() && (RegIdx.Kind & RegKind_HWRegs) && "Invalid access!");
     unsigned ClassID = Mips::HWRegsRegClassID;
     return RegIdx.RegInfo->getRegClass(ClassID).getRegister(RegIdx.Index);
   }
 
 public:
   void addExpr(MCInst &Inst, const MCExpr *Expr) const {
     // Add as immediate when possible.  Null MCExpr = 0.
     if (!Expr)
       Inst.addOperand(MCOperand::createImm(0));
     else if (const MCConstantExpr *CE = dyn_cast<MCConstantExpr>(Expr))
       Inst.addOperand(MCOperand::createImm(CE->getValue()));
     else
       Inst.addOperand(MCOperand::createExpr(Expr));
   }
 
   void addRegOperands(MCInst &Inst, unsigned N) const {
     llvm_unreachable("Use a custom parser instead");
   }
 
   /// Render the operand to an MCInst as a GPR32
   /// Asserts if the wrong number of operands are requested, or the operand
   /// is not a k_RegisterIndex compatible with RegKind_GPR
   void addGPR32ZeroAsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getGPR32Reg()));
   }
 
   void addGPR32NonZeroAsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getGPR32Reg()));
   }
 
   void addGPR32AsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getGPR32Reg()));
   }
 
   void addGPRMM16AsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getGPRMM16Reg()));
   }
 
   void addGPRMM16AsmRegZeroOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getGPRMM16Reg()));
   }
 
   void addGPRMM16AsmRegMovePOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getGPRMM16Reg()));
   }
 
   void addGPRMM16AsmRegMovePPairFirstOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getGPRMM16Reg()));
   }
 
   void addGPRMM16AsmRegMovePPairSecondOperands(MCInst &Inst,
                                                unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getGPRMM16Reg()));
   }
 
+  void addCPU16AsmRegOperands(MCInst &Inst, unsigned N) const {
+    assert(N == 1 && "Invalid number of operands!");
+    Inst.addOperand(MCOperand::createReg(getCPU16Reg()));
+  }
+
   /// Render the operand to an MCInst as a GPR64
   /// Asserts if the wrong number of operands are requested, or the operand
   /// is not a k_RegisterIndex compatible with RegKind_GPR
   void addGPR64AsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getGPR64Reg()));
   }
 
   void addAFGR64AsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getAFGR64Reg()));
   }
 
   void addStrictlyAFGR64AsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getAFGR64Reg()));
   }
 
   void addStrictlyFGR64AsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getFGR64Reg()));
   }
 
   void addFGR64AsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getFGR64Reg()));
   }
 
   void addFGR32AsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getFGR32Reg()));
     // FIXME: We ought to do this for -integrated-as without -via-file-asm too.
     // FIXME: This should propagate failure up to parseStatement.
     if (!AsmParser.useOddSPReg() && RegIdx.Index & 1)
       AsmParser.getParser().printError(
           StartLoc, "-mno-odd-spreg prohibits the use of odd FPU "
                     "registers");
   }
 
   void addStrictlyFGR32AsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getFGR32Reg()));
     // FIXME: We ought to do this for -integrated-as without -via-file-asm too.
     if (!AsmParser.useOddSPReg() && RegIdx.Index & 1)
       AsmParser.Error(StartLoc, "-mno-odd-spreg prohibits the use of odd FPU "
                                 "registers");
   }
 
   void addFCCAsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getFCCReg()));
   }
 
   void addMSA128AsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getMSA128Reg()));
   }
 
   void addMSACtrlAsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getMSACtrlReg()));
   }
 
   void addCOP0AsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getCOP0Reg()));
   }
 
   void addCOP2AsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getCOP2Reg()));
   }
 
   void addCOP3AsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getCOP3Reg()));
   }
 
   void addACC64DSPAsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getACC64DSPReg()));
   }
 
   void addHI32DSPAsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getHI32DSPReg()));
   }
 
   void addLO32DSPAsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getLO32DSPReg()));
   }
 
   void addCCRAsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getCCRReg()));
   }
 
   void addHWRegsAsmRegOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     Inst.addOperand(MCOperand::createReg(getHWRegsReg()));
   }
 
   template <unsigned Bits, int Offset = 0, int AdjustOffset = 0>
   void addConstantUImmOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     uint64_t Imm = getConstantImm() - Offset;
     Imm &= (1ULL << Bits) - 1;
     Imm += Offset;
     Imm += AdjustOffset;
     Inst.addOperand(MCOperand::createImm(Imm));
   }
 
   template <unsigned Bits>
   void addSImmOperands(MCInst &Inst, unsigned N) const {
     if (isImm() && !isConstantImm()) {
       addExpr(Inst, getImm());
       return;
     }
     addConstantSImmOperands<Bits, 0, 0>(Inst, N);
   }
 
   template <unsigned Bits>
   void addUImmOperands(MCInst &Inst, unsigned N) const {
     if (isImm() && !isConstantImm()) {
       addExpr(Inst, getImm());
       return;
     }
     addConstantUImmOperands<Bits, 0, 0>(Inst, N);
   }
 
   template <unsigned Bits, int Offset = 0, int AdjustOffset = 0>
   void addConstantSImmOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     int64_t Imm = getConstantImm() - Offset;
     Imm = SignExtend64<Bits>(Imm);
     Imm += Offset;
     Imm += AdjustOffset;
     Inst.addOperand(MCOperand::createImm(Imm));
   }
 
   void addImmOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
     const MCExpr *Expr = getImm();
     addExpr(Inst, Expr);
   }
 
   void addMemOperands(MCInst &Inst, unsigned N) const {
     assert(N == 2 && "Invalid number of operands!");
 
     Inst.addOperand(MCOperand::createReg(AsmParser.getABI().ArePtrs64bit()
                                              ? getMemBase()->getGPR64Reg()
                                              : getMemBase()->getGPR32Reg()));
 
     const MCExpr *Expr = getMemOff();
     addExpr(Inst, Expr);
   }
 
   void addMicroMipsMemOperands(MCInst &Inst, unsigned N) const {
     assert(N == 2 && "Invalid number of operands!");
 
     Inst.addOperand(MCOperand::createReg(getMemBase()->getGPRMM16Reg()));
 
     const MCExpr *Expr = getMemOff();
     addExpr(Inst, Expr);
   }
 
   void addRegListOperands(MCInst &Inst, unsigned N) const {
     assert(N == 1 && "Invalid number of operands!");
 
     for (auto RegNo : getRegList())
       Inst.addOperand(MCOperand::createReg(RegNo));
   }
 
   bool isReg() const override {
     // As a special case until we sort out the definition of div/divu, accept
     // $0/$zero here so that MCK_ZERO works correctly.
     return isGPRAsmReg() && RegIdx.Index == 0;
   }
 
   bool isRegIdx() const { return Kind == k_RegisterIndex; }
   bool isImm() const override { return Kind == k_Immediate; }
 
   bool isConstantImm() const {
     int64_t Res;
     return isImm() && getImm()->evaluateAsAbsolute(Res);
   }
 
   bool isConstantImmz() const {
     return isConstantImm() && getConstantImm() == 0;
   }
 
   template <unsigned Bits, int Offset = 0> bool isConstantUImm() const {
     return isConstantImm() && isUInt<Bits>(getConstantImm() - Offset);
   }
 
   template <unsigned Bits> bool isSImm() const {
     return isConstantImm() ? isInt<Bits>(getConstantImm()) : isImm();
   }
 
   template <unsigned Bits> bool isUImm() const {
     return isConstantImm() ? isUInt<Bits>(getConstantImm()) : isImm();
   }
 
   template <unsigned Bits> bool isAnyImm() const {
     return isConstantImm() ? (isInt<Bits>(getConstantImm()) ||
                               isUInt<Bits>(getConstantImm()))
                            : isImm();
   }
 
   template <unsigned Bits, int Offset = 0> bool isConstantSImm() const {
     return isConstantImm() && isInt<Bits>(getConstantImm() - Offset);
   }
 
   template <unsigned Bottom, unsigned Top> bool isConstantUImmRange() const {
     return isConstantImm() && getConstantImm() >= Bottom &&
            getConstantImm() <= Top;
   }
 
   bool isToken() const override {
     // Note: It's not possible to pretend that other operand kinds are tokens.
     // The matcher emitter checks tokens first.
     return Kind == k_Token;
   }
 
   bool isMem() const override { return Kind == k_Memory; }
 
   bool isConstantMemOff() const {
     return isMem() && isa<MCConstantExpr>(getMemOff());
   }
 
   // Allow relocation operators.
   template <unsigned Bits, unsigned ShiftAmount = 0>
   bool isMemWithSimmOffset() const {
     if (!isMem())
       return false;
     if (!getMemBase()->isGPRAsmReg())
       return false;
     if (isa<MCTargetExpr>(getMemOff()) ||
         (isConstantMemOff() &&
          isShiftedInt<Bits, ShiftAmount>(getConstantMemOff())))
       return true;
     MCValue Res;
     bool IsReloc = getMemOff()->evaluateAsRelocatable(Res, nullptr, nullptr);
     return IsReloc && isShiftedInt<Bits, ShiftAmount>(Res.getConstant());
   }
 
   bool isMemWithPtrSizeOffset() const {
     if (!isMem())
       return false;
     if (!getMemBase()->isGPRAsmReg())
       return false;
     const unsigned PtrBits = AsmParser.getABI().ArePtrs64bit() ? 64 : 32;
     if (isa<MCTargetExpr>(getMemOff()) ||
         (isConstantMemOff() && isIntN(PtrBits, getConstantMemOff())))
       return true;
     MCValue Res;
     bool IsReloc = getMemOff()->evaluateAsRelocatable(Res, nullptr, nullptr);
     return IsReloc && isIntN(PtrBits, Res.getConstant());
   }
 
   bool isMemWithGRPMM16Base() const {
     return isMem() && getMemBase()->isMM16AsmReg();
   }
 
   template <unsigned Bits> bool isMemWithUimmOffsetSP() const {
     return isMem() && isConstantMemOff() && isUInt<Bits>(getConstantMemOff())
       && getMemBase()->isRegIdx() && (getMemBase()->getGPR32Reg() == Mips::SP);
   }
 
   template <unsigned Bits> bool isMemWithUimmWordAlignedOffsetSP() const {
     return isMem() && isConstantMemOff() && isUInt<Bits>(getConstantMemOff())
       && (getConstantMemOff() % 4 == 0) && getMemBase()->isRegIdx()
       && (getMemBase()->getGPR32Reg() == Mips::SP);
   }
 
   template <unsigned Bits> bool isMemWithSimmWordAlignedOffsetGP() const {
     return isMem() && isConstantMemOff() && isInt<Bits>(getConstantMemOff())
       && (getConstantMemOff() % 4 == 0) && getMemBase()->isRegIdx()
       && (getMemBase()->getGPR32Reg() == Mips::GP);
   }
 
   template <unsigned Bits, unsigned ShiftLeftAmount>
   bool isScaledUImm() const {
     return isConstantImm() &&
            isShiftedUInt<Bits, ShiftLeftAmount>(getConstantImm());
   }
 
   template <unsigned Bits, unsigned ShiftLeftAmount>
   bool isScaledSImm() const {
     if (isConstantImm() &&
         isShiftedInt<Bits, ShiftLeftAmount>(getConstantImm()))
       return true;
     // Operand can also be a symbol or symbol plus
     // offset in case of relocations.
     if (Kind != k_Immediate)
       return false;
     MCValue Res;
     bool Success = getImm()->evaluateAsRelocatable(Res, nullptr, nullptr);
     return Success && isShiftedInt<Bits, ShiftLeftAmount>(Res.getConstant());
   }
 
   bool isRegList16() const {
     if (!isRegList())
       return false;
 
     int Size = RegList.List->size();
     if (Size < 2 || Size > 5)
       return false;
 
     unsigned R0 = RegList.List->front();
     unsigned R1 = RegList.List->back();
     if (!((R0 == Mips::S0 && R1 == Mips::RA) ||
           (R0 == Mips::S0_64 && R1 == Mips::RA_64)))
       return false;
 
     int PrevReg = *RegList.List->begin();
     for (int i = 1; i < Size - 1; i++) {
       int Reg = (*(RegList.List))[i];
       if ( Reg != PrevReg + 1)
         return false;
       PrevReg = Reg;
     }
 
     return true;
   }
 
   bool isInvNum() const { return Kind == k_Immediate; }
 
   bool isLSAImm() const {
     if (!isConstantImm())
       return false;
     int64_t Val = getConstantImm();
     return 1 <= Val && Val <= 4;
   }
 
   bool isRegList() const { return Kind == k_RegList; }
 
   StringRef getToken() const {
     assert(Kind == k_Token && "Invalid access!");
     return StringRef(Tok.Data, Tok.Length);
   }
 
   unsigned getReg() const override {
     // As a special case until we sort out the definition of div/divu, accept
     // $0/$zero here so that MCK_ZERO works correctly.
     if (Kind == k_RegisterIndex && RegIdx.Index == 0 &&
         RegIdx.Kind & RegKind_GPR)
       return getGPR32Reg(); // FIXME: GPR64 too
 
     llvm_unreachable("Invalid access!");
     return 0;
   }
 
   const MCExpr *getImm() const {
     assert((Kind == k_Immediate) && "Invalid access!");
     return Imm.Val;
   }
 
   int64_t getConstantImm() const {
     const MCExpr *Val = getImm();
     int64_t Value = 0;
     (void)Val->evaluateAsAbsolute(Value);
     return Value;
   }
 
   MipsOperand *getMemBase() const {
     assert((Kind == k_Memory) && "Invalid access!");
     return Mem.Base;
   }
 
   const MCExpr *getMemOff() const {
     assert((Kind == k_Memory) && "Invalid access!");
     return Mem.Off;
   }
 
   int64_t getConstantMemOff() const {
     return static_cast<const MCConstantExpr *>(getMemOff())->getValue();
   }
 
   const SmallVectorImpl<unsigned> &getRegList() const {
     assert((Kind == k_RegList) && "Invalid access!");
     return *(RegList.List);
   }
 
   static std::unique_ptr<MipsOperand> CreateToken(StringRef Str, SMLoc S,
                                                   MipsAsmParser &Parser) {
     auto Op = std::make_unique<MipsOperand>(k_Token, Parser);
     Op->Tok.Data = Str.data();
     Op->Tok.Length = Str.size();
     Op->StartLoc = S;
     Op->EndLoc = S;
     return Op;
   }
 
   /// Create a numeric register (e.g. $1). The exact register remains
   /// unresolved until an instruction successfully matches
   static std::unique_ptr<MipsOperand>
   createNumericReg(unsigned Index, StringRef Str, const MCRegisterInfo *RegInfo,
                    SMLoc S, SMLoc E, MipsAsmParser &Parser) {
     LLVM_DEBUG(dbgs() << "createNumericReg(" << Index << ", ...)\n");
     return CreateReg(Index, Str, RegKind_Numeric, RegInfo, S, E, Parser);
   }
 
   /// Create a register that is definitely a GPR.
   /// This is typically only used for named registers such as $gp.
   static std::unique_ptr<MipsOperand>
   createGPRReg(unsigned Index, StringRef Str, const MCRegisterInfo *RegInfo,
                SMLoc S, SMLoc E, MipsAsmParser &Parser) {
     return CreateReg(Index, Str, RegKind_GPR, RegInfo, S, E, Parser);
   }
 
   /// Create a register that is definitely a FGR.
   /// This is typically only used for named registers such as $f0.
   static std::unique_ptr<MipsOperand>
   createFGRReg(unsigned Index, StringRef Str, const MCRegisterInfo *RegInfo,
                SMLoc S, SMLoc E, MipsAsmParser &Parser) {
     return CreateReg(Index, Str, RegKind_FGR, RegInfo, S, E, Parser);
   }
 
   /// Create a register that is definitely a HWReg.
   /// This is typically only used for named registers such as $hwr_cpunum.
   static std::unique_ptr<MipsOperand>
   createHWRegsReg(unsigned Index, StringRef Str, const MCRegisterInfo *RegInfo,
                   SMLoc S, SMLoc E, MipsAsmParser &Parser) {
     return CreateReg(Index, Str, RegKind_HWRegs, RegInfo, S, E, Parser);
   }
 
   /// Create a register that is definitely an FCC.
   /// This is typically only used for named registers such as $fcc0.
   static std::unique_ptr<MipsOperand>
   createFCCReg(unsigned Index, StringRef Str, const MCRegisterInfo *RegInfo,
                SMLoc S, SMLoc E, MipsAsmParser &Parser) {
     return CreateReg(Index, Str, RegKind_FCC, RegInfo, S, E, Parser);
   }
 
   /// Create a register that is definitely an ACC.
   /// This is typically only used for named registers such as $ac0.
   static std::unique_ptr<MipsOperand>
   createACCReg(unsigned Index, StringRef Str, const MCRegisterInfo *RegInfo,
                SMLoc S, SMLoc E, MipsAsmParser &Parser) {
     return CreateReg(Index, Str, RegKind_ACC, RegInfo, S, E, Parser);
   }
 
   /// Create a register that is definitely an MSA128.
   /// This is typically only used for named registers such as $w0.
   static std::unique_ptr<MipsOperand>
   createMSA128Reg(unsigned Index, StringRef Str, const MCRegisterInfo *RegInfo,
                   SMLoc S, SMLoc E, MipsAsmParser &Parser) {
     return CreateReg(Index, Str, RegKind_MSA128, RegInfo, S, E, Parser);
   }
 
   /// Create a register that is definitely an MSACtrl.
   /// This is typically only used for named registers such as $msaaccess.
   static std::unique_ptr<MipsOperand>
   createMSACtrlReg(unsigned Index, StringRef Str, const MCRegisterInfo *RegInfo,
                    SMLoc S, SMLoc E, MipsAsmParser &Parser) {
     return CreateReg(Index, Str, RegKind_MSACtrl, RegInfo, S, E, Parser);
   }
 
   static std::unique_ptr<MipsOperand>
   CreateImm(const MCExpr *Val, SMLoc S, SMLoc E, MipsAsmParser &Parser) {
     auto Op = std::make_unique<MipsOperand>(k_Immediate, Parser);
     Op->Imm.Val = Val;
     Op->StartLoc = S;
     Op->EndLoc = E;
     return Op;
   }
 
   static std::unique_ptr<MipsOperand>
   CreateMem(std::unique_ptr<MipsOperand> Base, const MCExpr *Off, SMLoc S,
             SMLoc E, MipsAsmParser &Parser) {
     auto Op = std::make_unique<MipsOperand>(k_Memory, Parser);
     Op->Mem.Base = Base.release();
     Op->Mem.Off = Off;
     Op->StartLoc = S;
     Op->EndLoc = E;
     return Op;
   }
 
   static std::unique_ptr<MipsOperand>
   CreateRegList(SmallVectorImpl<unsigned> &Regs, SMLoc StartLoc, SMLoc EndLoc,
                 MipsAsmParser &Parser) {
     assert(Regs.size() > 0 && "Empty list not allowed");
 
     auto Op = std::make_unique<MipsOperand>(k_RegList, Parser);
     Op->RegList.List = new SmallVector<unsigned, 10>(Regs.begin(), Regs.end());
     Op->StartLoc = StartLoc;
     Op->EndLoc = EndLoc;
     return Op;
   }
 
  bool isGPRZeroAsmReg() const {
     return isRegIdx() && RegIdx.Kind & RegKind_GPR && RegIdx.Index == 0;
   }
 
  bool isGPRNonZeroAsmReg() const {
    return isRegIdx() && RegIdx.Kind & RegKind_GPR && RegIdx.Index > 0 &&
           RegIdx.Index <= 31;
   }
 
   bool isGPRAsmReg() const {
     return isRegIdx() && RegIdx.Kind & RegKind_GPR && RegIdx.Index <= 31;
   }
 
   bool isMM16AsmReg() const {
     if (!(isRegIdx() && RegIdx.Kind))
       return false;
     return ((RegIdx.Index >= 2 && RegIdx.Index <= 7)
             || RegIdx.Index == 16 || RegIdx.Index == 17);
 
   }
   bool isMM16AsmRegZero() const {
     if (!(isRegIdx() && RegIdx.Kind))
       return false;
     return (RegIdx.Index == 0 ||
             (RegIdx.Index >= 2 && RegIdx.Index <= 7) ||
             RegIdx.Index == 17);
   }
 
   bool isMM16AsmRegMoveP() const {
     if (!(isRegIdx() && RegIdx.Kind))
       return false;
     return (RegIdx.Index == 0 || (RegIdx.Index >= 2 && RegIdx.Index <= 3) ||
       (RegIdx.Index >= 16 && RegIdx.Index <= 20));
   }
 
   bool isMM16AsmRegMovePPairFirst() const {
     if (!(isRegIdx() && RegIdx.Kind))
       return false;
     return RegIdx.Index >= 4 && RegIdx.Index <= 6;
   }
 
   bool isMM16AsmRegMovePPairSecond() const {
     if (!(isRegIdx() && RegIdx.Kind))
       return false;
     return (RegIdx.Index == 21 || RegIdx.Index == 22 ||
       (RegIdx.Index >= 5 && RegIdx.Index <= 7));
   }
 
+  bool isCPU16AsmReg() const {
+    if (!(isRegIdx() && RegIdx.Kind))
+      return false;
+    return ((RegIdx.Index >= 2 && RegIdx.Index <= 7)
+            || RegIdx.Index == 16 || RegIdx.Index == 17);
+  }
+
   bool isFGRAsmReg() const {
     // AFGR64 is $0-$15 but we handle this in getAFGR64()
     return isRegIdx() && RegIdx.Kind & RegKind_FGR && RegIdx.Index <= 31;
   }
 
   bool isStrictlyFGRAsmReg() const {
     // AFGR64 is $0-$15 but we handle this in getAFGR64()
     return isRegIdx() && RegIdx.Kind == RegKind_FGR && RegIdx.Index <= 31;
   }
 
   bool isHWRegsAsmReg() const {
     return isRegIdx() && RegIdx.Kind & RegKind_HWRegs && RegIdx.Index <= 31;
   }
 
   bool isCCRAsmReg() const {
     return isRegIdx() && RegIdx.Kind & RegKind_CCR && RegIdx.Index <= 31;
   }
 
   bool isFCCAsmReg() const {
     if (!(isRegIdx() && RegIdx.Kind & RegKind_FCC))
       return false;
     return RegIdx.Index <= 7;
   }
 
   bool isACCAsmReg() const {
     return isRegIdx() && RegIdx.Kind & RegKind_ACC && RegIdx.Index <= 3;
   }
 
   bool isCOP0AsmReg() const {
     return isRegIdx() && RegIdx.Kind & RegKind_COP0 && RegIdx.Index <= 31;
   }
 
   bool isCOP2AsmReg() const {
     return isRegIdx() && RegIdx.Kind & RegKind_COP2 && RegIdx.Index <= 31;
   }
 
   bool isCOP3AsmReg() const {
     return isRegIdx() && RegIdx.Kind & RegKind_COP3 && RegIdx.Index <= 31;
   }
 
   bool isMSA128AsmReg() const {
     return isRegIdx() && RegIdx.Kind & RegKind_MSA128 && RegIdx.Index <= 31;
   }
 
   bool isMSACtrlAsmReg() const {
     return isRegIdx() && RegIdx.Kind & RegKind_MSACtrl && RegIdx.Index <= 7;
   }
 
   /// getStartLoc - Get the location of the first token of this operand.
   SMLoc getStartLoc() const override { return StartLoc; }
   /// getEndLoc - Get the location of the last token of this operand.
   SMLoc getEndLoc() const override { return EndLoc; }
 
   void print(raw_ostream &OS) const override {
     switch (Kind) {
     case k_Immediate:
       OS << "Imm<";
       OS << *Imm.Val;
       OS << ">";
       break;
     case k_Memory:
       OS << "Mem<";
       Mem.Base->print(OS);
       OS << ", ";
       OS << *Mem.Off;
       OS << ">";
       break;
     case k_RegisterIndex:
       OS << "RegIdx<" << RegIdx.Index << ":" << RegIdx.Kind << ", "
          << StringRef(RegIdx.Tok.Data, RegIdx.Tok.Length) << ">";
       break;
     case k_Token:
       OS << getToken();
       break;
     case k_RegList:
       OS << "RegList< ";
       for (auto Reg : (*RegList.List))
         OS << Reg << " ";
       OS <<  ">";
       break;
     }
   }
 
   bool isValidForTie(const MipsOperand &Other) const {
     if (Kind != Other.Kind)
       return false;
 
     switch (Kind) {
     default:
       llvm_unreachable("Unexpected kind");
       return false;
     case k_RegisterIndex: {
       StringRef Token(RegIdx.Tok.Data, RegIdx.Tok.Length);
       StringRef OtherToken(Other.RegIdx.Tok.Data, Other.RegIdx.Tok.Length);
       return Token == OtherToken;
     }
     }
   }
 }; // class MipsOperand
 
 } // end anonymous namespace
 
 namespace llvm {
 
 extern const MCInstrDesc MipsInsts[];
 
 } // end namespace llvm
 
 static const MCInstrDesc &getInstDesc(unsigned Opcode) {
   return MipsInsts[Opcode];
 }
 
 static bool hasShortDelaySlot(MCInst &Inst) {
   switch (Inst.getOpcode()) {
     case Mips::BEQ_MM:
     case Mips::BNE_MM:
     case Mips::BLTZ_MM:
     case Mips::BGEZ_MM:
     case Mips::BLEZ_MM:
     case Mips::BGTZ_MM:
     case Mips::JRC16_MM:
     case Mips::JALS_MM:
     case Mips::JALRS_MM:
     case Mips::JALRS16_MM:
     case Mips::BGEZALS_MM:
     case Mips::BLTZALS_MM:
       return true;
     case Mips::J_MM:
       return !Inst.getOperand(0).isReg();
     default:
       return false;
   }
 }
 
 static const MCSymbol *getSingleMCSymbol(const MCExpr *Expr) {
   if (const MCSymbolRefExpr *SRExpr = dyn_cast<MCSymbolRefExpr>(Expr)) {
     return &SRExpr->getSymbol();
   }
 
   if (const MCBinaryExpr *BExpr = dyn_cast<MCBinaryExpr>(Expr)) {
     const MCSymbol *LHSSym = getSingleMCSymbol(BExpr->getLHS());
     const MCSymbol *RHSSym = getSingleMCSymbol(BExpr->getRHS());
 
     if (LHSSym)
       return LHSSym;
 
     if (RHSSym)
       return RHSSym;
 
     return nullptr;
   }
 
   if (const MCUnaryExpr *UExpr = dyn_cast<MCUnaryExpr>(Expr))
     return getSingleMCSymbol(UExpr->getSubExpr());
 
   return nullptr;
 }
 
 static unsigned countMCSymbolRefExpr(const MCExpr *Expr) {
   if (isa<MCSymbolRefExpr>(Expr))
     return 1;
 
   if (const MCBinaryExpr *BExpr = dyn_cast<MCBinaryExpr>(Expr))
     return countMCSymbolRefExpr(BExpr->getLHS()) +
            countMCSymbolRefExpr(BExpr->getRHS());
 
   if (const MCUnaryExpr *UExpr = dyn_cast<MCUnaryExpr>(Expr))
     return countMCSymbolRefExpr(UExpr->getSubExpr());
 
   return 0;
 }
 
 static bool isEvaluated(const MCExpr *Expr) {
   switch (Expr->getKind()) {
   case MCExpr::Constant:
     return true;
   case MCExpr::SymbolRef:
     return (cast<MCSymbolRefExpr>(Expr)->getKind() != MCSymbolRefExpr::VK_None);
   case MCExpr::Binary: {
     const MCBinaryExpr *BE = cast<MCBinaryExpr>(Expr);
     if (!isEvaluated(BE->getLHS()))
       return false;
     return isEvaluated(BE->getRHS());
   }
   case MCExpr::Unary:
     return isEvaluated(cast<MCUnaryExpr>(Expr)->getSubExpr());
   case MCExpr::Target:
     return true;
   }
   return false;
 }
 
 static bool needsExpandMemInst(MCInst &Inst) {
   const MCInstrDesc &MCID = getInstDesc(Inst.getOpcode());
 
   unsigned NumOp = MCID.getNumOperands();
   if (NumOp != 3 && NumOp != 4)
     return false;
 
   const MCOperandInfo &OpInfo = MCID.OpInfo[NumOp - 1];
   if (OpInfo.OperandType != MCOI::OPERAND_MEMORY &&
       OpInfo.OperandType != MCOI::OPERAND_UNKNOWN &&
       OpInfo.OperandType != MipsII::OPERAND_MEM_SIMM9)
     return false;
 
   MCOperand &Op = Inst.getOperand(NumOp - 1);
   if (Op.isImm()) {
     if (OpInfo.OperandType == MipsII::OPERAND_MEM_SIMM9)
       return !isInt<9>(Op.getImm());
     // Offset can't exceed 16bit value.
     return !isInt<16>(Op.getImm());
   }
 
   if (Op.isExpr()) {
     const MCExpr *Expr = Op.getExpr();
     if (Expr->getKind() != MCExpr::SymbolRef)
       return !isEvaluated(Expr);
 
     // Expand symbol.
     const MCSymbolRefExpr *SR = static_cast<const MCSymbolRefExpr *>(Expr);
     return SR->getKind() == MCSymbolRefExpr::VK_None;
   }
 
   return false;
 }
 
 bool MipsAsmParser::processInstruction(MCInst &Inst, SMLoc IDLoc,
                                        MCStreamer &Out,
                                        const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   const unsigned Opcode = Inst.getOpcode();
   const MCInstrDesc &MCID = getInstDesc(Opcode);
   bool ExpandedJalSym = false;
 
   Inst.setLoc(IDLoc);
 
   if (MCID.isBranch() || MCID.isCall()) {
     MCOperand Offset;
 
     switch (Opcode) {
     default:
       break;
     case Mips::BBIT0:
     case Mips::BBIT032:
     case Mips::BBIT1:
     case Mips::BBIT132:
       assert(hasCnMips() && "instruction only valid for octeon cpus");
       LLVM_FALLTHROUGH;
 
     case Mips::BEQ:
     case Mips::BNE:
     case Mips::BEQ_MM:
     case Mips::BNE_MM:
       assert(MCID.getNumOperands() == 3 && "unexpected number of operands");
       Offset = Inst.getOperand(2);
       if (!Offset.isImm())
         break; // We'll deal with this situation later on when applying fixups.
       if (!isIntN(inMicroMipsMode() ? 17 : 18, Offset.getImm()))
         return Error(IDLoc, "branch target out of range");
       if (offsetToAlignment(Offset.getImm(),
                             (inMicroMipsMode() ? Align(2) : Align(4))))
         return Error(IDLoc, "branch to misaligned address");
       break;
     case Mips::BGEZ:
     case Mips::BGTZ:
     case Mips::BLEZ:
     case Mips::BLTZ:
     case Mips::BGEZAL:
     case Mips::BLTZAL:
     case Mips::BC1F:
     case Mips::BC1T:
     case Mips::BGEZ_MM:
     case Mips::BGTZ_MM:
     case Mips::BLEZ_MM:
     case Mips::BLTZ_MM:
     case Mips::BGEZAL_MM:
     case Mips::BLTZAL_MM:
     case Mips::BC1F_MM:
     case Mips::BC1T_MM:
     case Mips::BC1EQZC_MMR6:
     case Mips::BC1NEZC_MMR6:
     case Mips::BC2EQZC_MMR6:
     case Mips::BC2NEZC_MMR6:
       assert(MCID.getNumOperands() == 2 && "unexpected number of operands");
       Offset = Inst.getOperand(1);
       if (!Offset.isImm())
         break; // We'll deal with this situation later on when applying fixups.
       if (!isIntN(inMicroMipsMode() ? 17 : 18, Offset.getImm()))
         return Error(IDLoc, "branch target out of range");
       if (offsetToAlignment(Offset.getImm(),
                             (inMicroMipsMode() ? Align(2) : Align(4))))
         return Error(IDLoc, "branch to misaligned address");
       break;
     case Mips::BGEC:    case Mips::BGEC_MMR6:
     case Mips::BLTC:    case Mips::BLTC_MMR6:
     case Mips::BGEUC:   case Mips::BGEUC_MMR6:
     case Mips::BLTUC:   case Mips::BLTUC_MMR6:
     case Mips::BEQC:    case Mips::BEQC_MMR6:
     case Mips::BNEC:    case Mips::BNEC_MMR6:
       assert(MCID.getNumOperands() == 3 && "unexpected number of operands");
       Offset = Inst.getOperand(2);
       if (!Offset.isImm())
         break; // We'll deal with this situation later on when applying fixups.
       if (!isIntN(18, Offset.getImm()))
         return Error(IDLoc, "branch target out of range");
       if (offsetToAlignment(Offset.getImm(), Align(4)))
         return Error(IDLoc, "branch to misaligned address");
       break;
     case Mips::BLEZC:   case Mips::BLEZC_MMR6:
     case Mips::BGEZC:   case Mips::BGEZC_MMR6:
     case Mips::BGTZC:   case Mips::BGTZC_MMR6:
     case Mips::BLTZC:   case Mips::BLTZC_MMR6:
       assert(MCID.getNumOperands() == 2 && "unexpected number of operands");
       Offset = Inst.getOperand(1);
       if (!Offset.isImm())
         break; // We'll deal with this situation later on when applying fixups.
       if (!isIntN(18, Offset.getImm()))
         return Error(IDLoc, "branch target out of range");
       if (offsetToAlignment(Offset.getImm(), Align(4)))
         return Error(IDLoc, "branch to misaligned address");
       break;
     case Mips::BEQZC:   case Mips::BEQZC_MMR6:
     case Mips::BNEZC:   case Mips::BNEZC_MMR6:
       assert(MCID.getNumOperands() == 2 && "unexpected number of operands");
       Offset = Inst.getOperand(1);
       if (!Offset.isImm())
         break; // We'll deal with this situation later on when applying fixups.
       if (!isIntN(23, Offset.getImm()))
         return Error(IDLoc, "branch target out of range");
       if (offsetToAlignment(Offset.getImm(), Align(4)))
         return Error(IDLoc, "branch to misaligned address");
       break;
     case Mips::BEQZ16_MM:
     case Mips::BEQZC16_MMR6:
     case Mips::BNEZ16_MM:
     case Mips::BNEZC16_MMR6:
       assert(MCID.getNumOperands() == 2 && "unexpected number of operands");
       Offset = Inst.getOperand(1);
       if (!Offset.isImm())
         break; // We'll deal with this situation later on when applying fixups.
       if (!isInt<8>(Offset.getImm()))
         return Error(IDLoc, "branch target out of range");
       if (offsetToAlignment(Offset.getImm(), Align(2)))
         return Error(IDLoc, "branch to misaligned address");
       break;
     }
   }
 
   // SSNOP is deprecated on MIPS32r6/MIPS64r6
   // We still accept it but it is a normal nop.
   if (hasMips32r6() && Opcode == Mips::SSNOP) {
     std::string ISA = hasMips64r6() ? "MIPS64r6" : "MIPS32r6";
     Warning(IDLoc, "ssnop is deprecated for " + ISA + " and is equivalent to a "
                                                       "nop instruction");
   }
 
   if (hasCnMips()) {
     MCOperand Opnd;
     int Imm;
 
     switch (Opcode) {
       default:
         break;
 
       case Mips::BBIT0:
       case Mips::BBIT032:
       case Mips::BBIT1:
       case Mips::BBIT132:
         assert(MCID.getNumOperands() == 3 && "unexpected number of operands");
         // The offset is handled above
         Opnd = Inst.getOperand(1);
         if (!Opnd.isImm())
           return Error(IDLoc, "expected immediate operand kind");
         Imm = Opnd.getImm();
         if (Imm < 0 || Imm > (Opcode == Mips::BBIT0 ||
                               Opcode == Mips::BBIT1 ? 63 : 31))
           return Error(IDLoc, "immediate operand value out of range");
         if (Imm > 31) {
           Inst.setOpcode(Opcode == Mips::BBIT0 ? Mips::BBIT032
                                                : Mips::BBIT132);
           Inst.getOperand(1).setImm(Imm - 32);
         }
         break;
 
       case Mips::SEQi:
       case Mips::SNEi:
         assert(MCID.getNumOperands() == 3 && "unexpected number of operands");
         Opnd = Inst.getOperand(2);
         if (!Opnd.isImm())
           return Error(IDLoc, "expected immediate operand kind");
         Imm = Opnd.getImm();
         if (!isInt<10>(Imm))
           return Error(IDLoc, "immediate operand value out of range");
         break;
     }
   }
 
   // Warn on division by zero. We're checking here as all instructions get
   // processed here, not just the macros that need expansion.
   //
   // The MIPS backend models most of the divison instructions and macros as
   // three operand instructions. The pre-R6 divide instructions however have
   // two operands and explicitly define HI/LO as part of the instruction,
   // not in the operands.
   unsigned FirstOp = 1;
   unsigned SecondOp = 2;
   switch (Opcode) {
   default:
     break;
   case Mips::SDivIMacro:
   case Mips::UDivIMacro:
   case Mips::DSDivIMacro:
   case Mips::DUDivIMacro:
     if (Inst.getOperand(2).getImm() == 0) {
       if (Inst.getOperand(1).getReg() == Mips::ZERO ||
           Inst.getOperand(1).getReg() == Mips::ZERO_64)
         Warning(IDLoc, "dividing zero by zero");
       else
         Warning(IDLoc, "division by zero");
     }
     break;
   case Mips::DSDIV:
   case Mips::SDIV:
   case Mips::UDIV:
   case Mips::DUDIV:
   case Mips::UDIV_MM:
   case Mips::SDIV_MM:
     FirstOp = 0;
     SecondOp = 1;
     LLVM_FALLTHROUGH;
   case Mips::SDivMacro:
   case Mips::DSDivMacro:
   case Mips::UDivMacro:
   case Mips::DUDivMacro:
   case Mips::DIV:
   case Mips::DIVU:
   case Mips::DDIV:
   case Mips::DDIVU:
   case Mips::DIVU_MMR6:
   case Mips::DIV_MMR6:
     if (Inst.getOperand(SecondOp).getReg() == Mips::ZERO ||
         Inst.getOperand(SecondOp).getReg() == Mips::ZERO_64) {
       if (Inst.getOperand(FirstOp).getReg() == Mips::ZERO ||
           Inst.getOperand(FirstOp).getReg() == Mips::ZERO_64)
         Warning(IDLoc, "dividing zero by zero");
       else
         Warning(IDLoc, "division by zero");
     }
     break;
   }
 
   // For PIC code convert unconditional jump to unconditional branch.
   if ((Opcode == Mips::J || Opcode == Mips::J_MM) && inPicMode()) {
     MCInst BInst;
     BInst.setOpcode(inMicroMipsMode() ? Mips::BEQ_MM : Mips::BEQ);
     BInst.addOperand(MCOperand::createReg(Mips::ZERO));
     BInst.addOperand(MCOperand::createReg(Mips::ZERO));
     BInst.addOperand(Inst.getOperand(0));
     Inst = BInst;
   }
 
   // This expansion is not in a function called by tryExpandInstruction()
   // because the pseudo-instruction doesn't have a distinct opcode.
   if ((Opcode == Mips::JAL || Opcode == Mips::JAL_MM) && inPicMode()) {
     warnIfNoMacro(IDLoc);
 
     const MCExpr *JalExpr = Inst.getOperand(0).getExpr();
 
     // We can do this expansion if there's only 1 symbol in the argument
     // expression.
     if (countMCSymbolRefExpr(JalExpr) > 1)
       return Error(IDLoc, "jal doesn't support multiple symbols in PIC mode");
 
     // FIXME: This is checking the expression can be handled by the later stages
     //        of the assembler. We ought to leave it to those later stages.
     const MCSymbol *JalSym = getSingleMCSymbol(JalExpr);
 
     if (expandLoadAddress(Mips::T9, Mips::NoRegister, Inst.getOperand(0),
                           !isGP64bit(), IDLoc, Out, STI))
       return true;
 
     MCInst JalrInst;
     if (inMicroMipsMode())
       JalrInst.setOpcode(IsCpRestoreSet ? Mips::JALRS_MM : Mips::JALR_MM);
     else
       JalrInst.setOpcode(Mips::JALR);
     JalrInst.addOperand(MCOperand::createReg(Mips::RA));
     JalrInst.addOperand(MCOperand::createReg(Mips::T9));
 
     if (isJalrRelocAvailable(JalExpr)) {
       // As an optimization hint for the linker, before the JALR we add:
       // .reloc tmplabel, R_{MICRO}MIPS_JALR, symbol
       // tmplabel:
       MCSymbol *TmpLabel = getContext().createTempSymbol();
       const MCExpr *TmpExpr = MCSymbolRefExpr::create(TmpLabel, getContext());
       const MCExpr *RelocJalrExpr =
           MCSymbolRefExpr::create(JalSym, MCSymbolRefExpr::VK_None,
                                   getContext(), IDLoc);
 
       TOut.getStreamer().emitRelocDirective(
           *TmpExpr, inMicroMipsMode() ? "R_MICROMIPS_JALR" : "R_MIPS_JALR",
           RelocJalrExpr, IDLoc, *STI);
       TOut.getStreamer().emitLabel(TmpLabel);
     }
 
     Inst = JalrInst;
     ExpandedJalSym = true;
   }
 
   if (MCID.mayLoad() || MCID.mayStore()) {
     // Check the offset of memory operand, if it is a symbol
     // reference or immediate we may have to expand instructions.
     if (needsExpandMemInst(Inst)) {
       const MCInstrDesc &MCID = getInstDesc(Inst.getOpcode());
       switch (MCID.OpInfo[MCID.getNumOperands() - 1].OperandType) {
       case MipsII::OPERAND_MEM_SIMM9:
         expandMem9Inst(Inst, IDLoc, Out, STI, MCID.mayLoad());
         break;
       default:
         expandMem16Inst(Inst, IDLoc, Out, STI, MCID.mayLoad());
         break;
       }
       return getParser().hasPendingError();
     }
   }
 
   if (inMicroMipsMode()) {
     if (MCID.mayLoad() && Opcode != Mips::LWP_MM) {
       // Try to create 16-bit GP relative load instruction.
       for (unsigned i = 0; i < MCID.getNumOperands(); i++) {
         const MCOperandInfo &OpInfo = MCID.OpInfo[i];
         if ((OpInfo.OperandType == MCOI::OPERAND_MEMORY) ||
             (OpInfo.OperandType == MCOI::OPERAND_UNKNOWN)) {
           MCOperand &Op = Inst.getOperand(i);
           if (Op.isImm()) {
             int MemOffset = Op.getImm();
             MCOperand &DstReg = Inst.getOperand(0);
             MCOperand &BaseReg = Inst.getOperand(1);
             if (isInt<9>(MemOffset) && (MemOffset % 4 == 0) &&
                 getContext().getRegisterInfo()->getRegClass(
                   Mips::GPRMM16RegClassID).contains(DstReg.getReg()) &&
                 (BaseReg.getReg() == Mips::GP ||
                 BaseReg.getReg() == Mips::GP_64)) {
 
               TOut.emitRRI(Mips::LWGP_MM, DstReg.getReg(), Mips::GP, MemOffset,
                            IDLoc, STI);
               return false;
             }
           }
         }
       } // for
     }   // if load
 
     // TODO: Handle this with the AsmOperandClass.PredicateMethod.
 
     MCOperand Opnd;
     int Imm;
 
     switch (Opcode) {
       default:
         break;
       case Mips::ADDIUSP_MM:
         Opnd = Inst.getOperand(0);
         if (!Opnd.isImm())
           return Error(IDLoc, "expected immediate operand kind");
         Imm = Opnd.getImm();
         if (Imm < -1032 || Imm > 1028 || (Imm < 8 && Imm > -12) ||
             Imm % 4 != 0)
           return Error(IDLoc, "immediate operand value out of range");
         break;
       case Mips::SLL16_MM:
       case Mips::SRL16_MM:
         Opnd = Inst.getOperand(2);
         if (!Opnd.isImm())
           return Error(IDLoc, "expected immediate operand kind");
         Imm = Opnd.getImm();
         if (Imm < 1 || Imm > 8)
           return Error(IDLoc, "immediate operand value out of range");
         break;
       case Mips::LI16_MM:
         Opnd = Inst.getOperand(1);
         if (!Opnd.isImm())
           return Error(IDLoc, "expected immediate operand kind");
         Imm = Opnd.getImm();
         if (Imm < -1 || Imm > 126)
           return Error(IDLoc, "immediate operand value out of range");
         break;
       case Mips::ADDIUR2_MM:
         Opnd = Inst.getOperand(2);
         if (!Opnd.isImm())
           return Error(IDLoc, "expected immediate operand kind");
         Imm = Opnd.getImm();
         if (!(Imm == 1 || Imm == -1 ||
               ((Imm % 4 == 0) && Imm < 28 && Imm > 0)))
           return Error(IDLoc, "immediate operand value out of range");
         break;
       case Mips::ANDI16_MM:
         Opnd = Inst.getOperand(2);
         if (!Opnd.isImm())
           return Error(IDLoc, "expected immediate operand kind");
         Imm = Opnd.getImm();
         if (!(Imm == 128 || (Imm >= 1 && Imm <= 4) || Imm == 7 || Imm == 8 ||
               Imm == 15 || Imm == 16 || Imm == 31 || Imm == 32 || Imm == 63 ||
               Imm == 64 || Imm == 255 || Imm == 32768 || Imm == 65535))
           return Error(IDLoc, "immediate operand value out of range");
         break;
       case Mips::LBU16_MM:
         Opnd = Inst.getOperand(2);
         if (!Opnd.isImm())
           return Error(IDLoc, "expected immediate operand kind");
         Imm = Opnd.getImm();
         if (Imm < -1 || Imm > 14)
           return Error(IDLoc, "immediate operand value out of range");
         break;
       case Mips::SB16_MM:
       case Mips::SB16_MMR6:
         Opnd = Inst.getOperand(2);
         if (!Opnd.isImm())
           return Error(IDLoc, "expected immediate operand kind");
         Imm = Opnd.getImm();
         if (Imm < 0 || Imm > 15)
           return Error(IDLoc, "immediate operand value out of range");
         break;
       case Mips::LHU16_MM:
       case Mips::SH16_MM:
       case Mips::SH16_MMR6:
         Opnd = Inst.getOperand(2);
         if (!Opnd.isImm())
           return Error(IDLoc, "expected immediate operand kind");
         Imm = Opnd.getImm();
         if (Imm < 0 || Imm > 30 || (Imm % 2 != 0))
           return Error(IDLoc, "immediate operand value out of range");
         break;
       case Mips::LW16_MM:
       case Mips::SW16_MM:
       case Mips::SW16_MMR6:
         Opnd = Inst.getOperand(2);
         if (!Opnd.isImm())
           return Error(IDLoc, "expected immediate operand kind");
         Imm = Opnd.getImm();
         if (Imm < 0 || Imm > 60 || (Imm % 4 != 0))
           return Error(IDLoc, "immediate operand value out of range");
         break;
       case Mips::ADDIUPC_MM:
         Opnd = Inst.getOperand(1);
         if (!Opnd.isImm())
           return Error(IDLoc, "expected immediate operand kind");
         Imm = Opnd.getImm();
         if ((Imm % 4 != 0) || !isInt<25>(Imm))
           return Error(IDLoc, "immediate operand value out of range");
         break;
       case Mips::LWP_MM:
       case Mips::SWP_MM:
         if (Inst.getOperand(0).getReg() == Mips::RA)
           return Error(IDLoc, "invalid operand for instruction");
         break;
       case Mips::MOVEP_MM:
       case Mips::MOVEP_MMR6: {
         unsigned R0 = Inst.getOperand(0).getReg();
         unsigned R1 = Inst.getOperand(1).getReg();
         bool RegPair = ((R0 == Mips::A1 && R1 == Mips::A2) ||
                         (R0 == Mips::A1 && R1 == Mips::A3) ||
                         (R0 == Mips::A2 && R1 == Mips::A3) ||
                         (R0 == Mips::A0 && R1 == Mips::S5) ||
                         (R0 == Mips::A0 && R1 == Mips::S6) ||
                         (R0 == Mips::A0 && R1 == Mips::A1) ||
                         (R0 == Mips::A0 && R1 == Mips::A2) ||
                         (R0 == Mips::A0 && R1 == Mips::A3));
         if (!RegPair)
           return Error(IDLoc, "invalid operand for instruction");
         break;
       }
     }
   }
 
   bool FillDelaySlot =
       MCID.hasDelaySlot() && AssemblerOptions.back()->isReorder();
   if (FillDelaySlot)
     TOut.emitDirectiveSetNoReorder();
 
   MacroExpanderResultTy ExpandResult =
       tryExpandInstruction(Inst, IDLoc, Out, STI);
   switch (ExpandResult) {
   case MER_NotAMacro:
     Out.emitInstruction(Inst, *STI);
     break;
   case MER_Success:
     break;
   case MER_Fail:
     return true;
   }
 
   // We know we emitted an instruction on the MER_NotAMacro or MER_Success path.
   // If we're in microMIPS mode then we must also set EF_MIPS_MICROMIPS.
   if (inMicroMipsMode()) {
     TOut.setUsesMicroMips();
     TOut.updateABIInfo(*this);
   }
 
   // If this instruction has a delay slot and .set reorder is active,
   // emit a NOP after it.
   if (FillDelaySlot) {
     TOut.emitEmptyDelaySlot(hasShortDelaySlot(Inst), IDLoc, STI);
     TOut.emitDirectiveSetReorder();
   }
 
   if ((Opcode == Mips::JalOneReg || Opcode == Mips::JalTwoReg ||
        ExpandedJalSym) &&
       isPicAndNotNxxAbi()) {
     if (IsCpRestoreSet) {
       // We need a NOP between the JALR and the LW:
       // If .set reorder has been used, we've already emitted a NOP.
       // If .set noreorder has been used, we need to emit a NOP at this point.
       if (!AssemblerOptions.back()->isReorder())
         TOut.emitEmptyDelaySlot(hasShortDelaySlot(Inst), IDLoc,
                                 STI);
 
       // Load the $gp from the stack.
       TOut.emitGPRestore(CpRestoreOffset, IDLoc, STI);
     } else
       Warning(IDLoc, "no .cprestore used in PIC mode");
   }
 
   return false;
 }
 
 MipsAsmParser::MacroExpanderResultTy
 MipsAsmParser::tryExpandInstruction(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                     const MCSubtargetInfo *STI) {
   switch (Inst.getOpcode()) {
   default:
     return MER_NotAMacro;
   case Mips::LoadImm32:
     return expandLoadImm(Inst, true, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::LoadImm64:
     return expandLoadImm(Inst, false, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::LoadAddrImm32:
   case Mips::LoadAddrImm64:
     assert(Inst.getOperand(0).isReg() && "expected register operand kind");
     assert((Inst.getOperand(1).isImm() || Inst.getOperand(1).isExpr()) &&
            "expected immediate operand kind");
 
     return expandLoadAddress(Inst.getOperand(0).getReg(), Mips::NoRegister,
                              Inst.getOperand(1),
                              Inst.getOpcode() == Mips::LoadAddrImm32, IDLoc,
                              Out, STI)
                ? MER_Fail
                : MER_Success;
   case Mips::LoadAddrReg32:
   case Mips::LoadAddrReg64:
     assert(Inst.getOperand(0).isReg() && "expected register operand kind");
     assert(Inst.getOperand(1).isReg() && "expected register operand kind");
     assert((Inst.getOperand(2).isImm() || Inst.getOperand(2).isExpr()) &&
            "expected immediate operand kind");
 
     return expandLoadAddress(Inst.getOperand(0).getReg(),
                              Inst.getOperand(1).getReg(), Inst.getOperand(2),
                              Inst.getOpcode() == Mips::LoadAddrReg32, IDLoc,
                              Out, STI)
                ? MER_Fail
                : MER_Success;
   case Mips::B_MM_Pseudo:
   case Mips::B_MMR6_Pseudo:
     return expandUncondBranchMMPseudo(Inst, IDLoc, Out, STI) ? MER_Fail
                                                              : MER_Success;
   case Mips::SWM_MM:
   case Mips::LWM_MM:
     return expandLoadStoreMultiple(Inst, IDLoc, Out, STI) ? MER_Fail
                                                           : MER_Success;
   case Mips::JalOneReg:
   case Mips::JalTwoReg:
     return expandJalWithRegs(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::BneImm:
   case Mips::BeqImm:
   case Mips::BEQLImmMacro:
   case Mips::BNELImmMacro:
     return expandBranchImm(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::BLT:
   case Mips::BLE:
   case Mips::BGE:
   case Mips::BGT:
   case Mips::BLTU:
   case Mips::BLEU:
   case Mips::BGEU:
   case Mips::BGTU:
   case Mips::BLTL:
   case Mips::BLEL:
   case Mips::BGEL:
   case Mips::BGTL:
   case Mips::BLTUL:
   case Mips::BLEUL:
   case Mips::BGEUL:
   case Mips::BGTUL:
   case Mips::BLTImmMacro:
   case Mips::BLEImmMacro:
   case Mips::BGEImmMacro:
   case Mips::BGTImmMacro:
   case Mips::BLTUImmMacro:
   case Mips::BLEUImmMacro:
   case Mips::BGEUImmMacro:
   case Mips::BGTUImmMacro:
   case Mips::BLTLImmMacro:
   case Mips::BLELImmMacro:
   case Mips::BGELImmMacro:
   case Mips::BGTLImmMacro:
   case Mips::BLTULImmMacro:
   case Mips::BLEULImmMacro:
   case Mips::BGEULImmMacro:
   case Mips::BGTULImmMacro:
     return expandCondBranches(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::SDivMacro:
   case Mips::SDivIMacro:
   case Mips::SRemMacro:
   case Mips::SRemIMacro:
     return expandDivRem(Inst, IDLoc, Out, STI, false, true) ? MER_Fail
                                                             : MER_Success;
   case Mips::DSDivMacro:
   case Mips::DSDivIMacro:
   case Mips::DSRemMacro:
   case Mips::DSRemIMacro:
     return expandDivRem(Inst, IDLoc, Out, STI, true, true) ? MER_Fail
                                                            : MER_Success;
   case Mips::UDivMacro:
   case Mips::UDivIMacro:
   case Mips::URemMacro:
   case Mips::URemIMacro:
     return expandDivRem(Inst, IDLoc, Out, STI, false, false) ? MER_Fail
                                                              : MER_Success;
   case Mips::DUDivMacro:
   case Mips::DUDivIMacro:
   case Mips::DURemMacro:
   case Mips::DURemIMacro:
     return expandDivRem(Inst, IDLoc, Out, STI, true, false) ? MER_Fail
                                                             : MER_Success;
   case Mips::PseudoTRUNC_W_S:
     return expandTrunc(Inst, false, false, IDLoc, Out, STI) ? MER_Fail
                                                             : MER_Success;
   case Mips::PseudoTRUNC_W_D32:
     return expandTrunc(Inst, true, false, IDLoc, Out, STI) ? MER_Fail
                                                            : MER_Success;
   case Mips::PseudoTRUNC_W_D:
     return expandTrunc(Inst, true, true, IDLoc, Out, STI) ? MER_Fail
                                                           : MER_Success;
 
   case Mips::LoadImmSingleGPR:
     return expandLoadSingleImmToGPR(Inst, IDLoc, Out, STI) ? MER_Fail
                                                            : MER_Success;
   case Mips::LoadImmSingleFGR:
     return expandLoadSingleImmToFPR(Inst, IDLoc, Out, STI) ? MER_Fail
                                                            : MER_Success;
   case Mips::LoadImmDoubleGPR:
     return expandLoadDoubleImmToGPR(Inst, IDLoc, Out, STI) ? MER_Fail
                                                            : MER_Success;
   case Mips::LoadImmDoubleFGR:
     return expandLoadDoubleImmToFPR(Inst, true, IDLoc, Out, STI) ? MER_Fail
                                                                  : MER_Success;
   case Mips::LoadImmDoubleFGR_32:
     return expandLoadDoubleImmToFPR(Inst, false, IDLoc, Out, STI) ? MER_Fail
                                                                   : MER_Success;
 
   case Mips::Ulh:
     return expandUlh(Inst, true, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::Ulhu:
     return expandUlh(Inst, false, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::Ush:
     return expandUsh(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::Ulw:
   case Mips::Usw:
     return expandUxw(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::NORImm:
   case Mips::NORImm64:
     return expandAliasImmediate(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::SGE:
   case Mips::SGEU:
     return expandSge(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::SGEImm:
   case Mips::SGEUImm:
   case Mips::SGEImm64:
   case Mips::SGEUImm64:
     return expandSgeImm(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::SGTImm:
   case Mips::SGTUImm:
   case Mips::SGTImm64:
   case Mips::SGTUImm64:
     return expandSgtImm(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::SLE:
   case Mips::SLEU:
     return expandSle(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::SLEImm:
   case Mips::SLEUImm:
   case Mips::SLEImm64:
   case Mips::SLEUImm64:
     return expandSleImm(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::SLTImm64:
     if (isInt<16>(Inst.getOperand(2).getImm())) {
       Inst.setOpcode(Mips::SLTi64);
       return MER_NotAMacro;
     }
     return expandAliasImmediate(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::SLTUImm64:
     if (isInt<16>(Inst.getOperand(2).getImm())) {
       Inst.setOpcode(Mips::SLTiu64);
       return MER_NotAMacro;
     }
     return expandAliasImmediate(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::ADDi:   case Mips::ADDi_MM:
   case Mips::ADDiu:  case Mips::ADDiu_MM:
   case Mips::SLTi:   case Mips::SLTi_MM:
   case Mips::SLTiu:  case Mips::SLTiu_MM:
     if ((Inst.getNumOperands() == 3) && Inst.getOperand(0).isReg() &&
         Inst.getOperand(1).isReg() && Inst.getOperand(2).isImm()) {
       int64_t ImmValue = Inst.getOperand(2).getImm();
       if (isInt<16>(ImmValue))
         return MER_NotAMacro;
       return expandAliasImmediate(Inst, IDLoc, Out, STI) ? MER_Fail
                                                          : MER_Success;
     }
     return MER_NotAMacro;
   case Mips::ANDi:  case Mips::ANDi_MM:  case Mips::ANDi64:
   case Mips::ORi:   case Mips::ORi_MM:   case Mips::ORi64:
   case Mips::XORi:  case Mips::XORi_MM:  case Mips::XORi64:
     if ((Inst.getNumOperands() == 3) && Inst.getOperand(0).isReg() &&
         Inst.getOperand(1).isReg() && Inst.getOperand(2).isImm()) {
       int64_t ImmValue = Inst.getOperand(2).getImm();
       if (isUInt<16>(ImmValue))
         return MER_NotAMacro;
       return expandAliasImmediate(Inst, IDLoc, Out, STI) ? MER_Fail
                                                          : MER_Success;
     }
     return MER_NotAMacro;
   case Mips::ROL:
   case Mips::ROR:
     return expandRotation(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::ROLImm:
   case Mips::RORImm:
     return expandRotationImm(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::DROL:
   case Mips::DROR:
     return expandDRotation(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::DROLImm:
   case Mips::DRORImm:
     return expandDRotationImm(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::ABSMacro:
     return expandAbs(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::MULImmMacro:
   case Mips::DMULImmMacro:
     return expandMulImm(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::MULOMacro:
   case Mips::DMULOMacro:
     return expandMulO(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::MULOUMacro:
   case Mips::DMULOUMacro:
     return expandMulOU(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::DMULMacro:
     return expandDMULMacro(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::LDMacro:
   case Mips::SDMacro:
     return expandLoadStoreDMacro(Inst, IDLoc, Out, STI,
                                  Inst.getOpcode() == Mips::LDMacro)
                ? MER_Fail
                : MER_Success;
   case Mips::SDC1_M1:
     return expandStoreDM1Macro(Inst, IDLoc, Out, STI)
                ? MER_Fail
                : MER_Success;
   case Mips::SEQMacro:
     return expandSeq(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::SEQIMacro:
     return expandSeqI(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::SNEMacro:
     return expandSne(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::SNEIMacro:
     return expandSneI(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::MFTC0:   case Mips::MTTC0:
   case Mips::MFTGPR:  case Mips::MTTGPR:
   case Mips::MFTLO:   case Mips::MTTLO:
   case Mips::MFTHI:   case Mips::MTTHI:
   case Mips::MFTACX:  case Mips::MTTACX:
   case Mips::MFTDSP:  case Mips::MTTDSP:
   case Mips::MFTC1:   case Mips::MTTC1:
   case Mips::MFTHC1:  case Mips::MTTHC1:
   case Mips::CFTC1:   case Mips::CTTC1:
     return expandMXTRAlias(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   case Mips::SaaAddr:
   case Mips::SaadAddr:
     return expandSaaAddr(Inst, IDLoc, Out, STI) ? MER_Fail : MER_Success;
   }
 }
 
 bool MipsAsmParser::expandJalWithRegs(MCInst &Inst, SMLoc IDLoc,
                                       MCStreamer &Out,
                                       const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
 
   // Create a JALR instruction which is going to replace the pseudo-JAL.
   MCInst JalrInst;
   JalrInst.setLoc(IDLoc);
   const MCOperand FirstRegOp = Inst.getOperand(0);
   const unsigned Opcode = Inst.getOpcode();
 
   if (Opcode == Mips::JalOneReg) {
     // jal $rs => jalr $rs
     if (IsCpRestoreSet && inMicroMipsMode()) {
       JalrInst.setOpcode(Mips::JALRS16_MM);
       JalrInst.addOperand(FirstRegOp);
     } else if (inMicroMipsMode()) {
       JalrInst.setOpcode(hasMips32r6() ? Mips::JALRC16_MMR6 : Mips::JALR16_MM);
       JalrInst.addOperand(FirstRegOp);
     } else {
       JalrInst.setOpcode(Mips::JALR);
       JalrInst.addOperand(MCOperand::createReg(Mips::RA));
       JalrInst.addOperand(FirstRegOp);
     }
   } else if (Opcode == Mips::JalTwoReg) {
     // jal $rd, $rs => jalr $rd, $rs
     if (IsCpRestoreSet && inMicroMipsMode())
       JalrInst.setOpcode(Mips::JALRS_MM);
     else
       JalrInst.setOpcode(inMicroMipsMode() ? Mips::JALR_MM : Mips::JALR);
     JalrInst.addOperand(FirstRegOp);
     const MCOperand SecondRegOp = Inst.getOperand(1);
     JalrInst.addOperand(SecondRegOp);
   }
   Out.emitInstruction(JalrInst, *STI);
 
   // If .set reorder is active and branch instruction has a delay slot,
   // emit a NOP after it.
   const MCInstrDesc &MCID = getInstDesc(JalrInst.getOpcode());
   if (MCID.hasDelaySlot() && AssemblerOptions.back()->isReorder())
     TOut.emitEmptyDelaySlot(hasShortDelaySlot(JalrInst), IDLoc,
                             STI);
 
   return false;
 }
 
 /// Can the value be represented by a unsigned N-bit value and a shift left?
 template <unsigned N> static bool isShiftedUIntAtAnyPosition(uint64_t x) {
   unsigned BitNum = findFirstSet(x);
 
   return (x == x >> BitNum << BitNum) && isUInt<N>(x >> BitNum);
 }
 
 /// Load (or add) an immediate into a register.
 ///
 /// @param ImmValue     The immediate to load.
 /// @param DstReg       The register that will hold the immediate.
 /// @param SrcReg       A register to add to the immediate or Mips::NoRegister
 ///                     for a simple initialization.
 /// @param Is32BitImm   Is ImmValue 32-bit or 64-bit?
 /// @param IsAddress    True if the immediate represents an address. False if it
 ///                     is an integer.
 /// @param IDLoc        Location of the immediate in the source file.
 bool MipsAsmParser::loadImmediate(int64_t ImmValue, unsigned DstReg,
                                   unsigned SrcReg, bool Is32BitImm,
                                   bool IsAddress, SMLoc IDLoc, MCStreamer &Out,
                                   const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
 
   if (!Is32BitImm && !isGP64bit()) {
     Error(IDLoc, "instruction requires a 64-bit architecture");
     return true;
   }
 
   if (Is32BitImm) {
     if (isInt<32>(ImmValue) || isUInt<32>(ImmValue)) {
       // Sign extend up to 64-bit so that the predicates match the hardware
       // behaviour. In particular, isInt<16>(0xffff8000) and similar should be
       // true.
       ImmValue = SignExtend64<32>(ImmValue);
     } else {
       Error(IDLoc, "instruction requires a 32-bit immediate");
       return true;
     }
   }
 
   unsigned ZeroReg = IsAddress ? ABI.GetNullPtr() : ABI.GetZeroReg();
   unsigned AdduOp = !Is32BitImm ? Mips::DADDu : Mips::ADDu;
 
   bool UseSrcReg = false;
   if (SrcReg != Mips::NoRegister)
     UseSrcReg = true;
 
   unsigned TmpReg = DstReg;
   if (UseSrcReg &&
       getContext().getRegisterInfo()->isSuperOrSubRegisterEq(DstReg, SrcReg)) {
     // At this point we need AT to perform the expansions and we exit if it is
     // not available.
     unsigned ATReg = getATReg(IDLoc);
     if (!ATReg)
       return true;
     TmpReg = ATReg;
   }
 
   if (isInt<16>(ImmValue)) {
     if (!UseSrcReg)
       SrcReg = ZeroReg;
 
     // This doesn't quite follow the usual ABI expectations for N32 but matches
     // traditional assembler behaviour. N32 would normally use addiu for both
     // integers and addresses.
     if (IsAddress && !Is32BitImm) {
       TOut.emitRRI(Mips::DADDiu, DstReg, SrcReg, ImmValue, IDLoc, STI);
       return false;
     }
 
     TOut.emitRRI(Mips::ADDiu, DstReg, SrcReg, ImmValue, IDLoc, STI);
     return false;
   }
 
   if (isUInt<16>(ImmValue)) {
     unsigned TmpReg = DstReg;
     if (SrcReg == DstReg) {
       TmpReg = getATReg(IDLoc);
       if (!TmpReg)
         return true;
     }
 
     TOut.emitRRI(Mips::ORi, TmpReg, ZeroReg, ImmValue, IDLoc, STI);
     if (UseSrcReg)
       TOut.emitRRR(ABI.GetPtrAdduOp(), DstReg, TmpReg, SrcReg, IDLoc, STI);
     return false;
   }
 
   if (isInt<32>(ImmValue) || isUInt<32>(ImmValue)) {
     warnIfNoMacro(IDLoc);
 
     uint16_t Bits31To16 = (ImmValue >> 16) & 0xffff;
     uint16_t Bits15To0 = ImmValue & 0xffff;
     if (!Is32BitImm && !isInt<32>(ImmValue)) {
       // Traditional behaviour seems to special case this particular value. It's
       // not clear why other masks are handled differently.
       if (ImmValue == 0xffffffff) {
         TOut.emitRI(Mips::LUi, TmpReg, 0xffff, IDLoc, STI);
         TOut.emitRRI(Mips::DSRL32, TmpReg, TmpReg, 0, IDLoc, STI);
         if (UseSrcReg)
           TOut.emitRRR(AdduOp, DstReg, TmpReg, SrcReg, IDLoc, STI);
         return false;
       }
 
       // Expand to an ORi instead of a LUi to avoid sign-extending into the
       // upper 32 bits.
       TOut.emitRRI(Mips::ORi, TmpReg, ZeroReg, Bits31To16, IDLoc, STI);
       TOut.emitRRI(Mips::DSLL, TmpReg, TmpReg, 16, IDLoc, STI);
       if (Bits15To0)
         TOut.emitRRI(Mips::ORi, TmpReg, TmpReg, Bits15To0, IDLoc, STI);
       if (UseSrcReg)
         TOut.emitRRR(AdduOp, DstReg, TmpReg, SrcReg, IDLoc, STI);
       return false;
     }
 
     TOut.emitRI(Mips::LUi, TmpReg, Bits31To16, IDLoc, STI);
     if (Bits15To0)
       TOut.emitRRI(Mips::ORi, TmpReg, TmpReg, Bits15To0, IDLoc, STI);
     if (UseSrcReg)
       TOut.emitRRR(AdduOp, DstReg, TmpReg, SrcReg, IDLoc, STI);
     return false;
   }
 
   if (isShiftedUIntAtAnyPosition<16>(ImmValue)) {
     if (Is32BitImm) {
       Error(IDLoc, "instruction requires a 32-bit immediate");
       return true;
     }
 
     // Traditionally, these immediates are shifted as little as possible and as
     // such we align the most significant bit to bit 15 of our temporary.
     unsigned FirstSet = findFirstSet((uint64_t)ImmValue);
     unsigned LastSet = findLastSet((uint64_t)ImmValue);
     unsigned ShiftAmount = FirstSet - (15 - (LastSet - FirstSet));
     uint16_t Bits = (ImmValue >> ShiftAmount) & 0xffff;
     TOut.emitRRI(Mips::ORi, TmpReg, ZeroReg, Bits, IDLoc, STI);
     TOut.emitRRI(Mips::DSLL, TmpReg, TmpReg, ShiftAmount, IDLoc, STI);
 
     if (UseSrcReg)
       TOut.emitRRR(AdduOp, DstReg, TmpReg, SrcReg, IDLoc, STI);
 
     return false;
   }
 
   warnIfNoMacro(IDLoc);
 
   // The remaining case is packed with a sequence of dsll and ori with zeros
   // being omitted and any neighbouring dsll's being coalesced.
   // The highest 32-bit's are equivalent to a 32-bit immediate load.
 
   // Load bits 32-63 of ImmValue into bits 0-31 of the temporary register.
   if (loadImmediate(ImmValue >> 32, TmpReg, Mips::NoRegister, true, false,
                     IDLoc, Out, STI))
     return false;
 
   // Shift and accumulate into the register. If a 16-bit chunk is zero, then
   // skip it and defer the shift to the next chunk.
   unsigned ShiftCarriedForwards = 16;
   for (int BitNum = 16; BitNum >= 0; BitNum -= 16) {
     uint16_t ImmChunk = (ImmValue >> BitNum) & 0xffff;
 
     if (ImmChunk != 0) {
       TOut.emitDSLL(TmpReg, TmpReg, ShiftCarriedForwards, IDLoc, STI);
       TOut.emitRRI(Mips::ORi, TmpReg, TmpReg, ImmChunk, IDLoc, STI);
       ShiftCarriedForwards = 0;
     }
 
     ShiftCarriedForwards += 16;
   }
   ShiftCarriedForwards -= 16;
 
   // Finish any remaining shifts left by trailing zeros.
   if (ShiftCarriedForwards)
     TOut.emitDSLL(TmpReg, TmpReg, ShiftCarriedForwards, IDLoc, STI);
 
   if (UseSrcReg)
     TOut.emitRRR(AdduOp, DstReg, TmpReg, SrcReg, IDLoc, STI);
 
   return false;
 }
 
 bool MipsAsmParser::expandLoadImm(MCInst &Inst, bool Is32BitImm, SMLoc IDLoc,
                                   MCStreamer &Out, const MCSubtargetInfo *STI) {
   const MCOperand &ImmOp = Inst.getOperand(1);
   assert(ImmOp.isImm() && "expected immediate operand kind");
   const MCOperand &DstRegOp = Inst.getOperand(0);
   assert(DstRegOp.isReg() && "expected register operand kind");
 
   if (loadImmediate(ImmOp.getImm(), DstRegOp.getReg(), Mips::NoRegister,
                     Is32BitImm, false, IDLoc, Out, STI))
     return true;
 
   return false;
 }
 
 bool MipsAsmParser::expandLoadAddress(unsigned DstReg, unsigned BaseReg,
                                       const MCOperand &Offset,
                                       bool Is32BitAddress, SMLoc IDLoc,
                                       MCStreamer &Out,
                                       const MCSubtargetInfo *STI) {
   // la can't produce a usable address when addresses are 64-bit.
   if (Is32BitAddress && ABI.ArePtrs64bit()) {
     Warning(IDLoc, "la used to load 64-bit address");
     // Continue as if we had 'dla' instead.
     Is32BitAddress = false;
   }
 
   // dla requires 64-bit addresses.
   if (!Is32BitAddress && !hasMips3()) {
     Error(IDLoc, "instruction requires a 64-bit architecture");
     return true;
   }
 
   if (!Offset.isImm())
     return loadAndAddSymbolAddress(Offset.getExpr(), DstReg, BaseReg,
                                    Is32BitAddress, IDLoc, Out, STI);
 
   if (!ABI.ArePtrs64bit()) {
     // Continue as if we had 'la' whether we had 'la' or 'dla'.
     Is32BitAddress = true;
   }
 
   return loadImmediate(Offset.getImm(), DstReg, BaseReg, Is32BitAddress, true,
                        IDLoc, Out, STI);
 }
 
 bool MipsAsmParser::loadAndAddSymbolAddress(const MCExpr *SymExpr,
                                             unsigned DstReg, unsigned SrcReg,
                                             bool Is32BitSym, SMLoc IDLoc,
                                             MCStreamer &Out,
                                             const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   bool UseSrcReg = SrcReg != Mips::NoRegister && SrcReg != Mips::ZERO &&
                    SrcReg != Mips::ZERO_64;
   warnIfNoMacro(IDLoc);
 
   if (inPicMode()) {
     MCValue Res;
     if (!SymExpr->evaluateAsRelocatable(Res, nullptr, nullptr)) {
       Error(IDLoc, "expected relocatable expression");
       return true;
     }
     if (Res.getSymB() != nullptr) {
       Error(IDLoc, "expected relocatable expression with only one symbol");
       return true;
     }
 
     bool IsPtr64 = ABI.ArePtrs64bit();
     bool IsLocalSym =
         Res.getSymA()->getSymbol().isInSection() ||
         Res.getSymA()->getSymbol().isTemporary() ||
         (Res.getSymA()->getSymbol().isELF() &&
          cast<MCSymbolELF>(Res.getSymA()->getSymbol()).getBinding() ==
              ELF::STB_LOCAL);
     bool UseXGOT = STI->getFeatureBits()[Mips::FeatureXGOT] && !IsLocalSym;
 
     // The case where the result register is $25 is somewhat special. If the
     // symbol in the final relocation is external and not modified with a
     // constant then we must use R_MIPS_CALL16 instead of R_MIPS_GOT16
     // or R_MIPS_CALL16 instead of R_MIPS_GOT_DISP in 64-bit case.
     if ((DstReg == Mips::T9 || DstReg == Mips::T9_64) && !UseSrcReg &&
         Res.getConstant() == 0 && !IsLocalSym) {
       if (UseXGOT) {
         const MCExpr *CallHiExpr = MipsMCExpr::create(MipsMCExpr::MEK_CALL_HI16,
                                                       SymExpr, getContext());
         const MCExpr *CallLoExpr = MipsMCExpr::create(MipsMCExpr::MEK_CALL_LO16,
                                                       SymExpr, getContext());
         TOut.emitRX(Mips::LUi, DstReg, MCOperand::createExpr(CallHiExpr), IDLoc,
                     STI);
         TOut.emitRRR(IsPtr64 ? Mips::DADDu : Mips::ADDu, DstReg, DstReg, GPReg,
                      IDLoc, STI);
         TOut.emitRRX(IsPtr64 ? Mips::LD : Mips::LW, DstReg, DstReg,
                      MCOperand::createExpr(CallLoExpr), IDLoc, STI);
       } else {
         const MCExpr *CallExpr =
             MipsMCExpr::create(MipsMCExpr::MEK_GOT_CALL, SymExpr, getContext());
         TOut.emitRRX(IsPtr64 ? Mips::LD : Mips::LW, DstReg, GPReg,
                      MCOperand::createExpr(CallExpr), IDLoc, STI);
       }
       return false;
     }
 
     unsigned TmpReg = DstReg;
     if (UseSrcReg &&
         getContext().getRegisterInfo()->isSuperOrSubRegisterEq(DstReg,
                                                                SrcReg)) {
       // If $rs is the same as $rd, we need to use AT.
       // If it is not available we exit.
       unsigned ATReg = getATReg(IDLoc);
       if (!ATReg)
         return true;
       TmpReg = ATReg;
     }
 
     // FIXME: In case of N32 / N64 ABI and emabled XGOT, local addresses
     // loaded using R_MIPS_GOT_PAGE / R_MIPS_GOT_OFST pair of relocations.
     // FIXME: Implement XGOT for microMIPS.
     if (UseXGOT) {
       // Loading address from XGOT
       //   External GOT: lui $tmp, %got_hi(symbol)($gp)
       //                 addu $tmp, $tmp, $gp
       //                 lw $tmp, %got_lo(symbol)($tmp)
       //                >addiu $tmp, $tmp, offset
       //                >addiu $rd, $tmp, $rs
       // The addiu's marked with a '>' may be omitted if they are redundant. If
       // this happens then the last instruction must use $rd as the result
       // register.
       const MCExpr *CallHiExpr =
           MipsMCExpr::create(MipsMCExpr::MEK_GOT_HI16, SymExpr, getContext());
       const MCExpr *CallLoExpr = MipsMCExpr::create(
           MipsMCExpr::MEK_GOT_LO16, Res.getSymA(), getContext());
 
       TOut.emitRX(Mips::LUi, TmpReg, MCOperand::createExpr(CallHiExpr), IDLoc,
                   STI);
       TOut.emitRRR(IsPtr64 ? Mips::DADDu : Mips::ADDu, TmpReg, TmpReg, GPReg,
                    IDLoc, STI);
       TOut.emitRRX(IsPtr64 ? Mips::LD : Mips::LW, TmpReg, TmpReg,
                    MCOperand::createExpr(CallLoExpr), IDLoc, STI);
 
       if (Res.getConstant() != 0)
         TOut.emitRRX(IsPtr64 ? Mips::DADDiu : Mips::ADDiu, TmpReg, TmpReg,
                      MCOperand::createExpr(MCConstantExpr::create(
                          Res.getConstant(), getContext())),
                      IDLoc, STI);
 
       if (UseSrcReg)
         TOut.emitRRR(IsPtr64 ? Mips::DADDu : Mips::ADDu, DstReg, TmpReg, SrcReg,
                      IDLoc, STI);
       return false;
     }
 
     const MipsMCExpr *GotExpr = nullptr;
     const MCExpr *LoExpr = nullptr;
     if (ABI.IsN32() || ABI.IsN64()) {
       // The remaining cases are:
       //   Small offset: ld $tmp, %got_disp(symbol)($gp)
       //                >daddiu $tmp, $tmp, offset
       //                >daddu $rd, $tmp, $rs
       // The daddiu's marked with a '>' may be omitted if they are redundant. If
       // this happens then the last instruction must use $rd as the result
       // register.
       GotExpr = MipsMCExpr::create(MipsMCExpr::MEK_GOT_DISP, Res.getSymA(),
                                    getContext());
       if (Res.getConstant() != 0) {
         // Symbols fully resolve with just the %got_disp(symbol) but we
         // must still account for any offset to the symbol for
         // expressions like symbol+8.
         LoExpr = MCConstantExpr::create(Res.getConstant(), getContext());
 
         // FIXME: Offsets greater than 16 bits are not yet implemented.
         // FIXME: The correct range is a 32-bit sign-extended number.
         if (Res.getConstant() < -0x8000 || Res.getConstant() > 0x7fff) {
           Error(IDLoc, "macro instruction uses large offset, which is not "
                        "currently supported");
           return true;
         }
       }
     } else {
       // The remaining cases are:
       //   External GOT: lw $tmp, %got(symbol)($gp)
       //                >addiu $tmp, $tmp, offset
       //                >addiu $rd, $tmp, $rs
       //   Local GOT:    lw $tmp, %got(symbol+offset)($gp)
       //                 addiu $tmp, $tmp, %lo(symbol+offset)($gp)
       //                >addiu $rd, $tmp, $rs
       // The addiu's marked with a '>' may be omitted if they are redundant. If
       // this happens then the last instruction must use $rd as the result
       // register.
       if (IsLocalSym) {
         GotExpr =
             MipsMCExpr::create(MipsMCExpr::MEK_GOT, SymExpr, getContext());
         LoExpr = MipsMCExpr::create(MipsMCExpr::MEK_LO, SymExpr, getContext());
       } else {
         // External symbols fully resolve the symbol with just the %got(symbol)
         // but we must still account for any offset to the symbol for
         // expressions like symbol+8.
         GotExpr = MipsMCExpr::create(MipsMCExpr::MEK_GOT, Res.getSymA(),
                                      getContext());
         if (Res.getConstant() != 0)
           LoExpr = MCConstantExpr::create(Res.getConstant(), getContext());
       }
     }
 
     TOut.emitRRX(IsPtr64 ? Mips::LD : Mips::LW, TmpReg, GPReg,
                  MCOperand::createExpr(GotExpr), IDLoc, STI);
 
     if (LoExpr)
       TOut.emitRRX(IsPtr64 ? Mips::DADDiu : Mips::ADDiu, TmpReg, TmpReg,
                    MCOperand::createExpr(LoExpr), IDLoc, STI);
 
     if (UseSrcReg)
       TOut.emitRRR(IsPtr64 ? Mips::DADDu : Mips::ADDu, DstReg, TmpReg, SrcReg,
                    IDLoc, STI);
 
     return false;
   }
 
   const MipsMCExpr *HiExpr =
       MipsMCExpr::create(MipsMCExpr::MEK_HI, SymExpr, getContext());
   const MipsMCExpr *LoExpr =
       MipsMCExpr::create(MipsMCExpr::MEK_LO, SymExpr, getContext());
 
   // This is the 64-bit symbol address expansion.
   if (ABI.ArePtrs64bit() && isGP64bit()) {
     // We need AT for the 64-bit expansion in the cases where the optional
     // source register is the destination register and for the superscalar
     // scheduled form.
     //
     // If it is not available we exit if the destination is the same as the
     // source register.
 
     const MipsMCExpr *HighestExpr =
         MipsMCExpr::create(MipsMCExpr::MEK_HIGHEST, SymExpr, getContext());
     const MipsMCExpr *HigherExpr =
         MipsMCExpr::create(MipsMCExpr::MEK_HIGHER, SymExpr, getContext());
 
     bool RdRegIsRsReg =
         getContext().getRegisterInfo()->isSuperOrSubRegisterEq(DstReg, SrcReg);
 
     if (canUseATReg() && UseSrcReg && RdRegIsRsReg) {
       unsigned ATReg = getATReg(IDLoc);
 
       // If $rs is the same as $rd:
       // (d)la $rd, sym($rd) => lui    $at, %highest(sym)
       //                        daddiu $at, $at, %higher(sym)
       //                        dsll   $at, $at, 16
       //                        daddiu $at, $at, %hi(sym)
       //                        dsll   $at, $at, 16
       //                        daddiu $at, $at, %lo(sym)
       //                        daddu  $rd, $at, $rd
       TOut.emitRX(Mips::LUi, ATReg, MCOperand::createExpr(HighestExpr), IDLoc,
                   STI);
       TOut.emitRRX(Mips::DADDiu, ATReg, ATReg,
                    MCOperand::createExpr(HigherExpr), IDLoc, STI);
       TOut.emitRRI(Mips::DSLL, ATReg, ATReg, 16, IDLoc, STI);
       TOut.emitRRX(Mips::DADDiu, ATReg, ATReg, MCOperand::createExpr(HiExpr),
                    IDLoc, STI);
       TOut.emitRRI(Mips::DSLL, ATReg, ATReg, 16, IDLoc, STI);
       TOut.emitRRX(Mips::DADDiu, ATReg, ATReg, MCOperand::createExpr(LoExpr),
                    IDLoc, STI);
       TOut.emitRRR(Mips::DADDu, DstReg, ATReg, SrcReg, IDLoc, STI);
 
       return false;
     } else if (canUseATReg() && !RdRegIsRsReg && DstReg != getATReg(IDLoc)) {
       unsigned ATReg = getATReg(IDLoc);
 
       // If the $rs is different from $rd or if $rs isn't specified and we
       // have $at available:
       // (d)la $rd, sym/sym($rs) => lui    $rd, %highest(sym)
       //                            lui    $at, %hi(sym)
       //                            daddiu $rd, $rd, %higher(sym)
       //                            daddiu $at, $at, %lo(sym)
       //                            dsll32 $rd, $rd, 0
       //                            daddu  $rd, $rd, $at
       //                            (daddu  $rd, $rd, $rs)
       //
       // Which is preferred for superscalar issue.
       TOut.emitRX(Mips::LUi, DstReg, MCOperand::createExpr(HighestExpr), IDLoc,
                   STI);
       TOut.emitRX(Mips::LUi, ATReg, MCOperand::createExpr(HiExpr), IDLoc, STI);
       TOut.emitRRX(Mips::DADDiu, DstReg, DstReg,
                    MCOperand::createExpr(HigherExpr), IDLoc, STI);
       TOut.emitRRX(Mips::DADDiu, ATReg, ATReg, MCOperand::createExpr(LoExpr),
                    IDLoc, STI);
       TOut.emitRRI(Mips::DSLL32, DstReg, DstReg, 0, IDLoc, STI);
       TOut.emitRRR(Mips::DADDu, DstReg, DstReg, ATReg, IDLoc, STI);
       if (UseSrcReg)
         TOut.emitRRR(Mips::DADDu, DstReg, DstReg, SrcReg, IDLoc, STI);
 
       return false;
     } else if ((!canUseATReg() && !RdRegIsRsReg) ||
                (canUseATReg() && DstReg == getATReg(IDLoc))) {
       // Otherwise, synthesize the address in the destination register
       // serially:
       // (d)la $rd, sym/sym($rs) => lui    $rd, %highest(sym)
       //                            daddiu $rd, $rd, %higher(sym)
       //                            dsll   $rd, $rd, 16
       //                            daddiu $rd, $rd, %hi(sym)
       //                            dsll   $rd, $rd, 16
       //                            daddiu $rd, $rd, %lo(sym)
       TOut.emitRX(Mips::LUi, DstReg, MCOperand::createExpr(HighestExpr), IDLoc,
                   STI);
       TOut.emitRRX(Mips::DADDiu, DstReg, DstReg,
                    MCOperand::createExpr(HigherExpr), IDLoc, STI);
       TOut.emitRRI(Mips::DSLL, DstReg, DstReg, 16, IDLoc, STI);
       TOut.emitRRX(Mips::DADDiu, DstReg, DstReg,
                    MCOperand::createExpr(HiExpr), IDLoc, STI);
       TOut.emitRRI(Mips::DSLL, DstReg, DstReg, 16, IDLoc, STI);
       TOut.emitRRX(Mips::DADDiu, DstReg, DstReg,
                    MCOperand::createExpr(LoExpr), IDLoc, STI);
       if (UseSrcReg)
         TOut.emitRRR(Mips::DADDu, DstReg, DstReg, SrcReg, IDLoc, STI);
 
       return false;
     } else {
       // We have a case where SrcReg == DstReg and we don't have $at
       // available. We can't expand this case, so error out appropriately.
       assert(SrcReg == DstReg && !canUseATReg() &&
              "Could have expanded dla but didn't?");
       reportParseError(IDLoc,
                      "pseudo-instruction requires $at, which is not available");
       return true;
     }
   }
 
   // And now, the 32-bit symbol address expansion:
   // If $rs is the same as $rd:
   // (d)la $rd, sym($rd)     => lui   $at, %hi(sym)
   //                            ori   $at, $at, %lo(sym)
   //                            addu  $rd, $at, $rd
   // Otherwise, if the $rs is different from $rd or if $rs isn't specified:
   // (d)la $rd, sym/sym($rs) => lui   $rd, %hi(sym)
   //                            ori   $rd, $rd, %lo(sym)
   //                            (addu $rd, $rd, $rs)
   unsigned TmpReg = DstReg;
   if (UseSrcReg &&
       getContext().getRegisterInfo()->isSuperOrSubRegisterEq(DstReg, SrcReg)) {
     // If $rs is the same as $rd, we need to use AT.
     // If it is not available we exit.
     unsigned ATReg = getATReg(IDLoc);
     if (!ATReg)
       return true;
     TmpReg = ATReg;
   }
 
   TOut.emitRX(Mips::LUi, TmpReg, MCOperand::createExpr(HiExpr), IDLoc, STI);
   TOut.emitRRX(Mips::ADDiu, TmpReg, TmpReg, MCOperand::createExpr(LoExpr),
                IDLoc, STI);
 
   if (UseSrcReg)
     TOut.emitRRR(Mips::ADDu, DstReg, TmpReg, SrcReg, IDLoc, STI);
   else
     assert(
         getContext().getRegisterInfo()->isSuperOrSubRegisterEq(DstReg, TmpReg));
 
   return false;
 }
 
 // Each double-precision register DO-D15 overlaps with two of the single
 // precision registers F0-F31. As an example, all of the following hold true:
 // D0 + 1 == F1, F1 + 1 == D1, F1 + 1 == F2, depending on the context.
 static unsigned nextReg(unsigned Reg) {
   if (MipsMCRegisterClasses[Mips::FGR32RegClassID].contains(Reg))
     return Reg == (unsigned)Mips::F31 ? (unsigned)Mips::F0 : Reg + 1;
   switch (Reg) {
   default: llvm_unreachable("Unknown register in assembly macro expansion!");
   case Mips::ZERO: return Mips::AT;
   case Mips::AT:   return Mips::V0;
   case Mips::V0:   return Mips::V1;
   case Mips::V1:   return Mips::A0;
   case Mips::A0:   return Mips::A1;
   case Mips::A1:   return Mips::A2;
   case Mips::A2:   return Mips::A3;
   case Mips::A3:   return Mips::T0;
   case Mips::T0:   return Mips::T1;
   case Mips::T1:   return Mips::T2;
   case Mips::T2:   return Mips::T3;
   case Mips::T3:   return Mips::T4;
   case Mips::T4:   return Mips::T5;
   case Mips::T5:   return Mips::T6;
   case Mips::T6:   return Mips::T7;
   case Mips::T7:   return Mips::S0;
   case Mips::S0:   return Mips::S1;
   case Mips::S1:   return Mips::S2;
   case Mips::S2:   return Mips::S3;
   case Mips::S3:   return Mips::S4;
   case Mips::S4:   return Mips::S5;
   case Mips::S5:   return Mips::S6;
   case Mips::S6:   return Mips::S7;
   case Mips::S7:   return Mips::T8;
   case Mips::T8:   return Mips::T9;
   case Mips::T9:   return Mips::K0;
   case Mips::K0:   return Mips::K1;
   case Mips::K1:   return Mips::GP;
   case Mips::GP:   return Mips::SP;
   case Mips::SP:   return Mips::FP;
   case Mips::FP:   return Mips::RA;
   case Mips::RA:   return Mips::ZERO;
   case Mips::D0:   return Mips::F1;
   case Mips::D1:   return Mips::F3;
   case Mips::D2:   return Mips::F5;
   case Mips::D3:   return Mips::F7;
   case Mips::D4:   return Mips::F9;
   case Mips::D5:   return Mips::F11;
   case Mips::D6:   return Mips::F13;
   case Mips::D7:   return Mips::F15;
   case Mips::D8:   return Mips::F17;
   case Mips::D9:   return Mips::F19;
   case Mips::D10:   return Mips::F21;
   case Mips::D11:   return Mips::F23;
   case Mips::D12:   return Mips::F25;
   case Mips::D13:   return Mips::F27;
   case Mips::D14:   return Mips::F29;
   case Mips::D15:   return Mips::F31;
   }
 }
 
 // FIXME: This method is too general. In principle we should compute the number
 // of instructions required to synthesize the immediate inline compared to
 // synthesizing the address inline and relying on non .text sections.
 // For static O32 and N32 this may yield a small benefit, for static N64 this is
 // likely to yield a much larger benefit as we have to synthesize a 64bit
 // address to load a 64 bit value.
 bool MipsAsmParser::emitPartialAddress(MipsTargetStreamer &TOut, SMLoc IDLoc,
                                        MCSymbol *Sym) {
   unsigned ATReg = getATReg(IDLoc);
   if (!ATReg)
     return true;
 
   if(IsPicEnabled) {
     const MCExpr *GotSym =
         MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, getContext());
     const MipsMCExpr *GotExpr =
         MipsMCExpr::create(MipsMCExpr::MEK_GOT, GotSym, getContext());
 
     if(isABI_O32() || isABI_N32()) {
       TOut.emitRRX(Mips::LW, ATReg, GPReg, MCOperand::createExpr(GotExpr),
                    IDLoc, STI);
     } else { //isABI_N64()
       TOut.emitRRX(Mips::LD, ATReg, GPReg, MCOperand::createExpr(GotExpr),
                    IDLoc, STI);
     }
   } else { //!IsPicEnabled
     const MCExpr *HiSym =
         MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, getContext());
     const MipsMCExpr *HiExpr =
         MipsMCExpr::create(MipsMCExpr::MEK_HI, HiSym, getContext());
 
     // FIXME: This is technically correct but gives a different result to gas,
     // but gas is incomplete there (it has a fixme noting it doesn't work with
     // 64-bit addresses).
     // FIXME: With -msym32 option, the address expansion for N64 should probably
     // use the O32 / N32 case. It's safe to use the 64 address expansion as the
     // symbol's value is considered sign extended.
     if(isABI_O32() || isABI_N32()) {
       TOut.emitRX(Mips::LUi, ATReg, MCOperand::createExpr(HiExpr), IDLoc, STI);
     } else { //isABI_N64()
       const MCExpr *HighestSym =
           MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, getContext());
       const MipsMCExpr *HighestExpr =
           MipsMCExpr::create(MipsMCExpr::MEK_HIGHEST, HighestSym, getContext());
       const MCExpr *HigherSym =
           MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, getContext());
       const MipsMCExpr *HigherExpr =
           MipsMCExpr::create(MipsMCExpr::MEK_HIGHER, HigherSym, getContext());
 
       TOut.emitRX(Mips::LUi, ATReg, MCOperand::createExpr(HighestExpr), IDLoc,
                   STI);
       TOut.emitRRX(Mips::DADDiu, ATReg, ATReg,
                    MCOperand::createExpr(HigherExpr), IDLoc, STI);
       TOut.emitRRI(Mips::DSLL, ATReg, ATReg, 16, IDLoc, STI);
       TOut.emitRRX(Mips::DADDiu, ATReg, ATReg, MCOperand::createExpr(HiExpr),
                    IDLoc, STI);
       TOut.emitRRI(Mips::DSLL, ATReg, ATReg, 16, IDLoc, STI);
     }
   }
   return false;
 }
 
 static uint64_t convertIntToDoubleImm(uint64_t ImmOp64) {
   // If ImmOp64 is AsmToken::Integer type (all bits set to zero in the
   // exponent field), convert it to double (e.g. 1 to 1.0)
   if ((Hi_32(ImmOp64) & 0x7ff00000) == 0) {
     APFloat RealVal(APFloat::IEEEdouble(), ImmOp64);
     ImmOp64 = RealVal.bitcastToAPInt().getZExtValue();
   }
   return ImmOp64;
 }
 
 static uint32_t covertDoubleImmToSingleImm(uint64_t ImmOp64) {
   // Conversion of a double in an uint64_t to a float in a uint32_t,
   // retaining the bit pattern of a float.
   double DoubleImm = BitsToDouble(ImmOp64);
   float TmpFloat = static_cast<float>(DoubleImm);
   return FloatToBits(TmpFloat);
 }
 
 bool MipsAsmParser::expandLoadSingleImmToGPR(MCInst &Inst, SMLoc IDLoc,
                                              MCStreamer &Out,
                                              const MCSubtargetInfo *STI) {
   assert(Inst.getNumOperands() == 2 && "Invalid operand count");
   assert(Inst.getOperand(0).isReg() && Inst.getOperand(1).isImm() &&
          "Invalid instruction operand.");
 
   unsigned FirstReg = Inst.getOperand(0).getReg();
   uint64_t ImmOp64 = Inst.getOperand(1).getImm();
 
   uint32_t ImmOp32 = covertDoubleImmToSingleImm(convertIntToDoubleImm(ImmOp64));
 
   return loadImmediate(ImmOp32, FirstReg, Mips::NoRegister, true, false, IDLoc,
                        Out, STI);
 }
 
 bool MipsAsmParser::expandLoadSingleImmToFPR(MCInst &Inst, SMLoc IDLoc,
                                              MCStreamer &Out,
                                              const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   assert(Inst.getNumOperands() == 2 && "Invalid operand count");
   assert(Inst.getOperand(0).isReg() && Inst.getOperand(1).isImm() &&
          "Invalid instruction operand.");
 
   unsigned FirstReg = Inst.getOperand(0).getReg();
   uint64_t ImmOp64 = Inst.getOperand(1).getImm();
 
   ImmOp64 = convertIntToDoubleImm(ImmOp64);
 
   uint32_t ImmOp32 = covertDoubleImmToSingleImm(ImmOp64);
 
   unsigned TmpReg = Mips::ZERO;
   if (ImmOp32 != 0) {
     TmpReg = getATReg(IDLoc);
     if (!TmpReg)
       return true;
   }
 
   if (Lo_32(ImmOp64) == 0) {
     if (TmpReg != Mips::ZERO && loadImmediate(ImmOp32, TmpReg, Mips::NoRegister,
                                               true, false, IDLoc, Out, STI))
       return true;
     TOut.emitRR(Mips::MTC1, FirstReg, TmpReg, IDLoc, STI);
     return false;
   }
 
   MCSection *CS = getStreamer().getCurrentSectionOnly();
   // FIXME: Enhance this expansion to use the .lit4 & .lit8 sections
   // where appropriate.
   MCSection *ReadOnlySection =
       getContext().getELFSection(".rodata", ELF::SHT_PROGBITS, ELF::SHF_ALLOC);
 
   MCSymbol *Sym = getContext().createTempSymbol();
   const MCExpr *LoSym =
       MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, getContext());
   const MipsMCExpr *LoExpr =
       MipsMCExpr::create(MipsMCExpr::MEK_LO, LoSym, getContext());
 
   getStreamer().SwitchSection(ReadOnlySection);
   getStreamer().emitLabel(Sym, IDLoc);
   getStreamer().emitInt32(ImmOp32);
   getStreamer().SwitchSection(CS);
 
   if (emitPartialAddress(TOut, IDLoc, Sym))
     return true;
   TOut.emitRRX(Mips::LWC1, FirstReg, TmpReg, MCOperand::createExpr(LoExpr),
                IDLoc, STI);
   return false;
 }
 
 bool MipsAsmParser::expandLoadDoubleImmToGPR(MCInst &Inst, SMLoc IDLoc,
                                              MCStreamer &Out,
                                              const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   assert(Inst.getNumOperands() == 2 && "Invalid operand count");
   assert(Inst.getOperand(0).isReg() && Inst.getOperand(1).isImm() &&
          "Invalid instruction operand.");
 
   unsigned FirstReg = Inst.getOperand(0).getReg();
   uint64_t ImmOp64 = Inst.getOperand(1).getImm();
 
   ImmOp64 = convertIntToDoubleImm(ImmOp64);
 
   if (Lo_32(ImmOp64) == 0) {
     if (isGP64bit()) {
       if (loadImmediate(ImmOp64, FirstReg, Mips::NoRegister, false, false,
                         IDLoc, Out, STI))
         return true;
     } else {
       if (loadImmediate(Hi_32(ImmOp64), FirstReg, Mips::NoRegister, true, false,
                         IDLoc, Out, STI))
         return true;
 
       if (loadImmediate(0, nextReg(FirstReg), Mips::NoRegister, true, false,
                         IDLoc, Out, STI))
         return true;
     }
     return false;
   }
 
   MCSection *CS = getStreamer().getCurrentSectionOnly();
   MCSection *ReadOnlySection =
       getContext().getELFSection(".rodata", ELF::SHT_PROGBITS, ELF::SHF_ALLOC);
 
   MCSymbol *Sym = getContext().createTempSymbol();
   const MCExpr *LoSym =
       MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, getContext());
   const MipsMCExpr *LoExpr =
       MipsMCExpr::create(MipsMCExpr::MEK_LO, LoSym, getContext());
 
   getStreamer().SwitchSection(ReadOnlySection);
   getStreamer().emitLabel(Sym, IDLoc);
   getStreamer().emitValueToAlignment(8);
   getStreamer().emitIntValue(ImmOp64, 8);
   getStreamer().SwitchSection(CS);
 
   unsigned TmpReg = getATReg(IDLoc);
   if (!TmpReg)
     return true;
 
   if (emitPartialAddress(TOut, IDLoc, Sym))
     return true;
 
   TOut.emitRRX(isABI_N64() ? Mips::DADDiu : Mips::ADDiu, TmpReg, TmpReg,
                MCOperand::createExpr(LoExpr), IDLoc, STI);
 
   if (isGP64bit())
     TOut.emitRRI(Mips::LD, FirstReg, TmpReg, 0, IDLoc, STI);
   else {
     TOut.emitRRI(Mips::LW, FirstReg, TmpReg, 0, IDLoc, STI);
     TOut.emitRRI(Mips::LW, nextReg(FirstReg), TmpReg, 4, IDLoc, STI);
   }
   return false;
 }
 
 bool MipsAsmParser::expandLoadDoubleImmToFPR(MCInst &Inst, bool Is64FPU,
                                              SMLoc IDLoc, MCStreamer &Out,
                                              const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   assert(Inst.getNumOperands() == 2 && "Invalid operand count");
   assert(Inst.getOperand(0).isReg() && Inst.getOperand(1).isImm() &&
          "Invalid instruction operand.");
 
   unsigned FirstReg = Inst.getOperand(0).getReg();
   uint64_t ImmOp64 = Inst.getOperand(1).getImm();
 
   ImmOp64 = convertIntToDoubleImm(ImmOp64);
 
   unsigned TmpReg = Mips::ZERO;
   if (ImmOp64 != 0) {
     TmpReg = getATReg(IDLoc);
     if (!TmpReg)
       return true;
   }
 
   if ((Lo_32(ImmOp64) == 0) &&
       !((Hi_32(ImmOp64) & 0xffff0000) && (Hi_32(ImmOp64) & 0x0000ffff))) {
     if (isGP64bit()) {
       if (TmpReg != Mips::ZERO &&
           loadImmediate(ImmOp64, TmpReg, Mips::NoRegister, false, false, IDLoc,
                         Out, STI))
         return true;
       TOut.emitRR(Mips::DMTC1, FirstReg, TmpReg, IDLoc, STI);
       return false;
     }
 
     if (TmpReg != Mips::ZERO &&
         loadImmediate(Hi_32(ImmOp64), TmpReg, Mips::NoRegister, true, false,
                       IDLoc, Out, STI))
       return true;
 
     if (hasMips32r2()) {
       TOut.emitRR(Mips::MTC1, FirstReg, Mips::ZERO, IDLoc, STI);
       TOut.emitRRR(Mips::MTHC1_D32, FirstReg, FirstReg, TmpReg, IDLoc, STI);
     } else {
       TOut.emitRR(Mips::MTC1, nextReg(FirstReg), TmpReg, IDLoc, STI);
       TOut.emitRR(Mips::MTC1, FirstReg, Mips::ZERO, IDLoc, STI);
     }
     return false;
   }
 
   MCSection *CS = getStreamer().getCurrentSectionOnly();
   // FIXME: Enhance this expansion to use the .lit4 & .lit8 sections
   // where appropriate.
   MCSection *ReadOnlySection =
       getContext().getELFSection(".rodata", ELF::SHT_PROGBITS, ELF::SHF_ALLOC);
 
   MCSymbol *Sym = getContext().createTempSymbol();
   const MCExpr *LoSym =
       MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, getContext());
   const MipsMCExpr *LoExpr =
       MipsMCExpr::create(MipsMCExpr::MEK_LO, LoSym, getContext());
 
   getStreamer().SwitchSection(ReadOnlySection);
   getStreamer().emitLabel(Sym, IDLoc);
   getStreamer().emitValueToAlignment(8);
   getStreamer().emitIntValue(ImmOp64, 8);
   getStreamer().SwitchSection(CS);
 
   if (emitPartialAddress(TOut, IDLoc, Sym))
     return true;
 
   TOut.emitRRX(Is64FPU ? Mips::LDC164 : Mips::LDC1, FirstReg, TmpReg,
                MCOperand::createExpr(LoExpr), IDLoc, STI);
 
   return false;
 }
 
 bool MipsAsmParser::expandUncondBranchMMPseudo(MCInst &Inst, SMLoc IDLoc,
                                                MCStreamer &Out,
                                                const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
 
   assert(getInstDesc(Inst.getOpcode()).getNumOperands() == 1 &&
          "unexpected number of operands");
 
   MCOperand Offset = Inst.getOperand(0);
   if (Offset.isExpr()) {
     Inst.clear();
     Inst.setOpcode(Mips::BEQ_MM);
     Inst.addOperand(MCOperand::createReg(Mips::ZERO));
     Inst.addOperand(MCOperand::createReg(Mips::ZERO));
     Inst.addOperand(MCOperand::createExpr(Offset.getExpr()));
   } else {
     assert(Offset.isImm() && "expected immediate operand kind");
     if (isInt<11>(Offset.getImm())) {
       // If offset fits into 11 bits then this instruction becomes microMIPS
       // 16-bit unconditional branch instruction.
       if (inMicroMipsMode())
         Inst.setOpcode(hasMips32r6() ? Mips::BC16_MMR6 : Mips::B16_MM);
     } else {
       if (!isInt<17>(Offset.getImm()))
         return Error(IDLoc, "branch target out of range");
       if (offsetToAlignment(Offset.getImm(), Align(2)))
         return Error(IDLoc, "branch to misaligned address");
       Inst.clear();
       Inst.setOpcode(Mips::BEQ_MM);
       Inst.addOperand(MCOperand::createReg(Mips::ZERO));
       Inst.addOperand(MCOperand::createReg(Mips::ZERO));
       Inst.addOperand(MCOperand::createImm(Offset.getImm()));
     }
   }
   Out.emitInstruction(Inst, *STI);
 
   // If .set reorder is active and branch instruction has a delay slot,
   // emit a NOP after it.
   const MCInstrDesc &MCID = getInstDesc(Inst.getOpcode());
   if (MCID.hasDelaySlot() && AssemblerOptions.back()->isReorder())
     TOut.emitEmptyDelaySlot(true, IDLoc, STI);
 
   return false;
 }
 
 bool MipsAsmParser::expandBranchImm(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                     const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   const MCOperand &DstRegOp = Inst.getOperand(0);
   assert(DstRegOp.isReg() && "expected register operand kind");
 
   const MCOperand &ImmOp = Inst.getOperand(1);
   assert(ImmOp.isImm() && "expected immediate operand kind");
 
   const MCOperand &MemOffsetOp = Inst.getOperand(2);
   assert((MemOffsetOp.isImm() || MemOffsetOp.isExpr()) &&
          "expected immediate or expression operand");
 
   bool IsLikely = false;
 
   unsigned OpCode = 0;
   switch(Inst.getOpcode()) {
     case Mips::BneImm:
       OpCode = Mips::BNE;
       break;
     case Mips::BeqImm:
       OpCode = Mips::BEQ;
       break;
     case Mips::BEQLImmMacro:
       OpCode = Mips::BEQL;
       IsLikely = true;
       break;
     case Mips::BNELImmMacro:
       OpCode = Mips::BNEL;
       IsLikely = true;
       break;
     default:
       llvm_unreachable("Unknown immediate branch pseudo-instruction.");
       break;
   }
 
   int64_t ImmValue = ImmOp.getImm();
   if (ImmValue == 0) {
     if (IsLikely) {
       TOut.emitRRX(OpCode, DstRegOp.getReg(), Mips::ZERO,
                    MCOperand::createExpr(MemOffsetOp.getExpr()), IDLoc, STI);
       TOut.emitRRI(Mips::SLL, Mips::ZERO, Mips::ZERO, 0, IDLoc, STI);
     } else
       TOut.emitRRX(OpCode, DstRegOp.getReg(), Mips::ZERO, MemOffsetOp, IDLoc,
               STI);
   } else {
     warnIfNoMacro(IDLoc);
 
     unsigned ATReg = getATReg(IDLoc);
     if (!ATReg)
       return true;
 
     if (loadImmediate(ImmValue, ATReg, Mips::NoRegister, !isGP64bit(), true,
                       IDLoc, Out, STI))
       return true;
 
     if (IsLikely) {
       TOut.emitRRX(OpCode, DstRegOp.getReg(), ATReg,
               MCOperand::createExpr(MemOffsetOp.getExpr()), IDLoc, STI);
       TOut.emitRRI(Mips::SLL, Mips::ZERO, Mips::ZERO, 0, IDLoc, STI);
     } else
       TOut.emitRRX(OpCode, DstRegOp.getReg(), ATReg, MemOffsetOp, IDLoc, STI);
   }
   return false;
 }
 
 void MipsAsmParser::expandMem16Inst(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                     const MCSubtargetInfo *STI, bool IsLoad) {
   unsigned NumOp = Inst.getNumOperands();
   assert((NumOp == 3 || NumOp == 4) && "unexpected operands number");
   unsigned StartOp = NumOp == 3 ? 0 : 1;
 
   const MCOperand &DstRegOp = Inst.getOperand(StartOp);
   assert(DstRegOp.isReg() && "expected register operand kind");
   const MCOperand &BaseRegOp = Inst.getOperand(StartOp + 1);
   assert(BaseRegOp.isReg() && "expected register operand kind");
   const MCOperand &OffsetOp = Inst.getOperand(StartOp + 2);
 
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned OpCode = Inst.getOpcode();
   unsigned DstReg = DstRegOp.getReg();
   unsigned BaseReg = BaseRegOp.getReg();
   unsigned TmpReg = DstReg;
 
   const MCInstrDesc &Desc = getInstDesc(OpCode);
   int16_t DstRegClass = Desc.OpInfo[StartOp].RegClass;
   unsigned DstRegClassID =
       getContext().getRegisterInfo()->getRegClass(DstRegClass).getID();
   bool IsGPR = (DstRegClassID == Mips::GPR32RegClassID) ||
                (DstRegClassID == Mips::GPR64RegClassID);
 
   if (!IsLoad || !IsGPR || (BaseReg == DstReg)) {
     // At this point we need AT to perform the expansions
     // and we exit if it is not available.
     TmpReg = getATReg(IDLoc);
     if (!TmpReg)
       return;
   }
 
   auto emitInstWithOffset = [&](const MCOperand &Off) {
     if (NumOp == 3)
       TOut.emitRRX(OpCode, DstReg, TmpReg, Off, IDLoc, STI);
     else
       TOut.emitRRRX(OpCode, DstReg, DstReg, TmpReg, Off, IDLoc, STI);
   };
 
   if (OffsetOp.isImm()) {
     int64_t LoOffset = OffsetOp.getImm() & 0xffff;
     int64_t HiOffset = OffsetOp.getImm() & ~0xffff;
 
     // If msb of LoOffset is 1(negative number) we must increment
     // HiOffset to account for the sign-extension of the low part.
     if (LoOffset & 0x8000)
       HiOffset += 0x10000;
 
     bool IsLargeOffset = HiOffset != 0;
 
     if (IsLargeOffset) {
       bool Is32BitImm = isInt<32>(OffsetOp.getImm());
       if (loadImmediate(HiOffset, TmpReg, Mips::NoRegister, Is32BitImm, true,
                         IDLoc, Out, STI))
         return;
     }
 
     if (BaseReg != Mips::ZERO && BaseReg != Mips::ZERO_64)
       TOut.emitRRR(ABI.ArePtrs64bit() ? Mips::DADDu : Mips::ADDu, TmpReg,
                    TmpReg, BaseReg, IDLoc, STI);
     emitInstWithOffset(MCOperand::createImm(int16_t(LoOffset)));
     return;
   }
 
   if (OffsetOp.isExpr()) {
     if (inPicMode()) {
       // FIXME:
       // c) Check that immediates of R_MIPS_GOT16/R_MIPS_LO16 relocations
       //    do not exceed 16-bit.
       // d) Use R_MIPS_GOT_PAGE/R_MIPS_GOT_OFST relocations instead
       //    of R_MIPS_GOT_DISP in appropriate cases to reduce number
       //    of GOT entries.
       MCValue Res;
       if (!OffsetOp.getExpr()->evaluateAsRelocatable(Res, nullptr, nullptr)) {
         Error(IDLoc, "expected relocatable expression");
         return;
       }
       if (Res.getSymB() != nullptr) {
         Error(IDLoc, "expected relocatable expression with only one symbol");
         return;
       }
 
       loadAndAddSymbolAddress(Res.getSymA(), TmpReg, BaseReg,
                               !ABI.ArePtrs64bit(), IDLoc, Out, STI);
       emitInstWithOffset(MCOperand::createImm(int16_t(Res.getConstant())));
     } else {
       // FIXME: Implement 64-bit case.
       // 1) lw $8, sym => lui $8,  %hi(sym)
       //                  lw  $8,  %lo(sym)($8)
       // 2) sw $8, sym => lui $at, %hi(sym)
       //                  sw  $8,  %lo(sym)($at)
       const MCExpr *OffExpr = OffsetOp.getExpr();
       MCOperand LoOperand = MCOperand::createExpr(
           MipsMCExpr::create(MipsMCExpr::MEK_LO, OffExpr, getContext()));
       MCOperand HiOperand = MCOperand::createExpr(
           MipsMCExpr::create(MipsMCExpr::MEK_HI, OffExpr, getContext()));
 
       if (ABI.IsN64()) {
         MCOperand HighestOperand = MCOperand::createExpr(
             MipsMCExpr::create(MipsMCExpr::MEK_HIGHEST, OffExpr, getContext()));
         MCOperand HigherOperand = MCOperand::createExpr(
             MipsMCExpr::create(MipsMCExpr::MEK_HIGHER, OffExpr, getContext()));
 
         TOut.emitRX(Mips::LUi, TmpReg, HighestOperand, IDLoc, STI);
         TOut.emitRRX(Mips::DADDiu, TmpReg, TmpReg, HigherOperand, IDLoc, STI);
         TOut.emitRRI(Mips::DSLL, TmpReg, TmpReg, 16, IDLoc, STI);
         TOut.emitRRX(Mips::DADDiu, TmpReg, TmpReg, HiOperand, IDLoc, STI);
         TOut.emitRRI(Mips::DSLL, TmpReg, TmpReg, 16, IDLoc, STI);
         if (BaseReg != Mips::ZERO && BaseReg != Mips::ZERO_64)
           TOut.emitRRR(Mips::DADDu, TmpReg, TmpReg, BaseReg, IDLoc, STI);
         emitInstWithOffset(LoOperand);
       } else {
         // Generate the base address in TmpReg.
         TOut.emitRX(Mips::LUi, TmpReg, HiOperand, IDLoc, STI);
         if (BaseReg != Mips::ZERO)
           TOut.emitRRR(Mips::ADDu, TmpReg, TmpReg, BaseReg, IDLoc, STI);
         // Emit the load or store with the adjusted base and offset.
         emitInstWithOffset(LoOperand);
       }
     }
     return;
   }
 
   llvm_unreachable("unexpected operand type");
 }
 
 void MipsAsmParser::expandMem9Inst(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                    const MCSubtargetInfo *STI, bool IsLoad) {
   unsigned NumOp = Inst.getNumOperands();
   assert((NumOp == 3 || NumOp == 4) && "unexpected operands number");
   unsigned StartOp = NumOp == 3 ? 0 : 1;
 
   const MCOperand &DstRegOp = Inst.getOperand(StartOp);
   assert(DstRegOp.isReg() && "expected register operand kind");
   const MCOperand &BaseRegOp = Inst.getOperand(StartOp + 1);
   assert(BaseRegOp.isReg() && "expected register operand kind");
   const MCOperand &OffsetOp = Inst.getOperand(StartOp + 2);
 
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned OpCode = Inst.getOpcode();
   unsigned DstReg = DstRegOp.getReg();
   unsigned BaseReg = BaseRegOp.getReg();
   unsigned TmpReg = DstReg;
 
   const MCInstrDesc &Desc = getInstDesc(OpCode);
   int16_t DstRegClass = Desc.OpInfo[StartOp].RegClass;
   unsigned DstRegClassID =
       getContext().getRegisterInfo()->getRegClass(DstRegClass).getID();
   bool IsGPR = (DstRegClassID == Mips::GPR32RegClassID) ||
                (DstRegClassID == Mips::GPR64RegClassID);
 
   if (!IsLoad || !IsGPR || (BaseReg == DstReg)) {
     // At this point we need AT to perform the expansions
     // and we exit if it is not available.
     TmpReg = getATReg(IDLoc);
     if (!TmpReg)
       return;
   }
 
   auto emitInst = [&]() {
     if (NumOp == 3)
       TOut.emitRRX(OpCode, DstReg, TmpReg, MCOperand::createImm(0), IDLoc, STI);
     else
       TOut.emitRRRX(OpCode, DstReg, DstReg, TmpReg, MCOperand::createImm(0),
                     IDLoc, STI);
   };
 
   if (OffsetOp.isImm()) {
     loadImmediate(OffsetOp.getImm(), TmpReg, BaseReg, !ABI.ArePtrs64bit(), true,
                   IDLoc, Out, STI);
     emitInst();
     return;
   }
 
   if (OffsetOp.isExpr()) {
     loadAndAddSymbolAddress(OffsetOp.getExpr(), TmpReg, BaseReg,
                             !ABI.ArePtrs64bit(), IDLoc, Out, STI);
     emitInst();
     return;
   }
 
   llvm_unreachable("unexpected operand type");
 }
 
 bool MipsAsmParser::expandLoadStoreMultiple(MCInst &Inst, SMLoc IDLoc,
                                             MCStreamer &Out,
                                             const MCSubtargetInfo *STI) {
   unsigned OpNum = Inst.getNumOperands();
   unsigned Opcode = Inst.getOpcode();
   unsigned NewOpcode = Opcode == Mips::SWM_MM ? Mips::SWM32_MM : Mips::LWM32_MM;
 
   assert(Inst.getOperand(OpNum - 1).isImm() &&
          Inst.getOperand(OpNum - 2).isReg() &&
          Inst.getOperand(OpNum - 3).isReg() && "Invalid instruction operand.");
 
   if (OpNum < 8 && Inst.getOperand(OpNum - 1).getImm() <= 60 &&
       Inst.getOperand(OpNum - 1).getImm() >= 0 &&
       (Inst.getOperand(OpNum - 2).getReg() == Mips::SP ||
        Inst.getOperand(OpNum - 2).getReg() == Mips::SP_64) &&
       (Inst.getOperand(OpNum - 3).getReg() == Mips::RA ||
        Inst.getOperand(OpNum - 3).getReg() == Mips::RA_64)) {
     // It can be implemented as SWM16 or LWM16 instruction.
     if (inMicroMipsMode() && hasMips32r6())
       NewOpcode = Opcode == Mips::SWM_MM ? Mips::SWM16_MMR6 : Mips::LWM16_MMR6;
     else
       NewOpcode = Opcode == Mips::SWM_MM ? Mips::SWM16_MM : Mips::LWM16_MM;
   }
 
   Inst.setOpcode(NewOpcode);
   Out.emitInstruction(Inst, *STI);
   return false;
 }
 
 bool MipsAsmParser::expandCondBranches(MCInst &Inst, SMLoc IDLoc,
                                        MCStreamer &Out,
                                        const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   bool EmittedNoMacroWarning = false;
   unsigned PseudoOpcode = Inst.getOpcode();
   unsigned SrcReg = Inst.getOperand(0).getReg();
   const MCOperand &TrgOp = Inst.getOperand(1);
   const MCExpr *OffsetExpr = Inst.getOperand(2).getExpr();
 
   unsigned ZeroSrcOpcode, ZeroTrgOpcode;
   bool ReverseOrderSLT, IsUnsigned, IsLikely, AcceptsEquality;
 
   unsigned TrgReg;
   if (TrgOp.isReg())
     TrgReg = TrgOp.getReg();
   else if (TrgOp.isImm()) {
     warnIfNoMacro(IDLoc);
     EmittedNoMacroWarning = true;
 
     TrgReg = getATReg(IDLoc);
     if (!TrgReg)
       return true;
 
     switch(PseudoOpcode) {
     default:
       llvm_unreachable("unknown opcode for branch pseudo-instruction");
     case Mips::BLTImmMacro:
       PseudoOpcode = Mips::BLT;
       break;
     case Mips::BLEImmMacro:
       PseudoOpcode = Mips::BLE;
       break;
     case Mips::BGEImmMacro:
       PseudoOpcode = Mips::BGE;
       break;
     case Mips::BGTImmMacro:
       PseudoOpcode = Mips::BGT;
       break;
     case Mips::BLTUImmMacro:
       PseudoOpcode = Mips::BLTU;
       break;
     case Mips::BLEUImmMacro:
       PseudoOpcode = Mips::BLEU;
       break;
     case Mips::BGEUImmMacro:
       PseudoOpcode = Mips::BGEU;
       break;
     case Mips::BGTUImmMacro:
       PseudoOpcode = Mips::BGTU;
       break;
     case Mips::BLTLImmMacro:
       PseudoOpcode = Mips::BLTL;
       break;
     case Mips::BLELImmMacro:
       PseudoOpcode = Mips::BLEL;
       break;
     case Mips::BGELImmMacro:
       PseudoOpcode = Mips::BGEL;
       break;
     case Mips::BGTLImmMacro:
       PseudoOpcode = Mips::BGTL;
       break;
     case Mips::BLTULImmMacro:
       PseudoOpcode = Mips::BLTUL;
       break;
     case Mips::BLEULImmMacro:
       PseudoOpcode = Mips::BLEUL;
       break;
     case Mips::BGEULImmMacro:
       PseudoOpcode = Mips::BGEUL;
       break;
     case Mips::BGTULImmMacro:
       PseudoOpcode = Mips::BGTUL;
       break;
     }
 
     if (loadImmediate(TrgOp.getImm(), TrgReg, Mips::NoRegister, !isGP64bit(),
                       false, IDLoc, Out, STI))
       return true;
   }
 
   switch (PseudoOpcode) {
   case Mips::BLT:
   case Mips::BLTU:
   case Mips::BLTL:
   case Mips::BLTUL:
     AcceptsEquality = false;
     ReverseOrderSLT = false;
     IsUnsigned =
         ((PseudoOpcode == Mips::BLTU) || (PseudoOpcode == Mips::BLTUL));
     IsLikely = ((PseudoOpcode == Mips::BLTL) || (PseudoOpcode == Mips::BLTUL));
     ZeroSrcOpcode = Mips::BGTZ;
     ZeroTrgOpcode = Mips::BLTZ;
     break;
   case Mips::BLE:
   case Mips::BLEU:
   case Mips::BLEL:
   case Mips::BLEUL:
     AcceptsEquality = true;
     ReverseOrderSLT = true;
     IsUnsigned =
         ((PseudoOpcode == Mips::BLEU) || (PseudoOpcode == Mips::BLEUL));
     IsLikely = ((PseudoOpcode == Mips::BLEL) || (PseudoOpcode == Mips::BLEUL));
     ZeroSrcOpcode = Mips::BGEZ;
     ZeroTrgOpcode = Mips::BLEZ;
     break;
   case Mips::BGE:
   case Mips::BGEU:
   case Mips::BGEL:
   case Mips::BGEUL:
     AcceptsEquality = true;
     ReverseOrderSLT = false;
     IsUnsigned =
         ((PseudoOpcode == Mips::BGEU) || (PseudoOpcode == Mips::BGEUL));
     IsLikely = ((PseudoOpcode == Mips::BGEL) || (PseudoOpcode == Mips::BGEUL));
     ZeroSrcOpcode = Mips::BLEZ;
     ZeroTrgOpcode = Mips::BGEZ;
     break;
   case Mips::BGT:
   case Mips::BGTU:
   case Mips::BGTL:
   case Mips::BGTUL:
     AcceptsEquality = false;
     ReverseOrderSLT = true;
     IsUnsigned =
         ((PseudoOpcode == Mips::BGTU) || (PseudoOpcode == Mips::BGTUL));
     IsLikely = ((PseudoOpcode == Mips::BGTL) || (PseudoOpcode == Mips::BGTUL));
     ZeroSrcOpcode = Mips::BLTZ;
     ZeroTrgOpcode = Mips::BGTZ;
     break;
   default:
     llvm_unreachable("unknown opcode for branch pseudo-instruction");
   }
 
   bool IsTrgRegZero = (TrgReg == Mips::ZERO);
   bool IsSrcRegZero = (SrcReg == Mips::ZERO);
   if (IsSrcRegZero && IsTrgRegZero) {
     // FIXME: All of these Opcode-specific if's are needed for compatibility
     // with GAS' behaviour. However, they may not generate the most efficient
     // code in some circumstances.
     if (PseudoOpcode == Mips::BLT) {
       TOut.emitRX(Mips::BLTZ, Mips::ZERO, MCOperand::createExpr(OffsetExpr),
                   IDLoc, STI);
       return false;
     }
     if (PseudoOpcode == Mips::BLE) {
       TOut.emitRX(Mips::BLEZ, Mips::ZERO, MCOperand::createExpr(OffsetExpr),
                   IDLoc, STI);
       Warning(IDLoc, "branch is always taken");
       return false;
     }
     if (PseudoOpcode == Mips::BGE) {
       TOut.emitRX(Mips::BGEZ, Mips::ZERO, MCOperand::createExpr(OffsetExpr),
                   IDLoc, STI);
       Warning(IDLoc, "branch is always taken");
       return false;
     }
     if (PseudoOpcode == Mips::BGT) {
       TOut.emitRX(Mips::BGTZ, Mips::ZERO, MCOperand::createExpr(OffsetExpr),
                   IDLoc, STI);
       return false;
     }
     if (PseudoOpcode == Mips::BGTU) {
       TOut.emitRRX(Mips::BNE, Mips::ZERO, Mips::ZERO,
                    MCOperand::createExpr(OffsetExpr), IDLoc, STI);
       return false;
     }
     if (AcceptsEquality) {
       // If both registers are $0 and the pseudo-branch accepts equality, it
       // will always be taken, so we emit an unconditional branch.
       TOut.emitRRX(Mips::BEQ, Mips::ZERO, Mips::ZERO,
                    MCOperand::createExpr(OffsetExpr), IDLoc, STI);
       Warning(IDLoc, "branch is always taken");
       return false;
     }
     // If both registers are $0 and the pseudo-branch does not accept
     // equality, it will never be taken, so we don't have to emit anything.
     return false;
   }
   if (IsSrcRegZero || IsTrgRegZero) {
     if ((IsSrcRegZero && PseudoOpcode == Mips::BGTU) ||
         (IsTrgRegZero && PseudoOpcode == Mips::BLTU)) {
       // If the $rs is $0 and the pseudo-branch is BGTU (0 > x) or
       // if the $rt is $0 and the pseudo-branch is BLTU (x < 0),
       // the pseudo-branch will never be taken, so we don't emit anything.
       // This only applies to unsigned pseudo-branches.
       return false;
     }
     if ((IsSrcRegZero && PseudoOpcode == Mips::BLEU) ||
         (IsTrgRegZero && PseudoOpcode == Mips::BGEU)) {
       // If the $rs is $0 and the pseudo-branch is BLEU (0 <= x) or
       // if the $rt is $0 and the pseudo-branch is BGEU (x >= 0),
       // the pseudo-branch will always be taken, so we emit an unconditional
       // branch.
       // This only applies to unsigned pseudo-branches.
       TOut.emitRRX(Mips::BEQ, Mips::ZERO, Mips::ZERO,
                    MCOperand::createExpr(OffsetExpr), IDLoc, STI);
       Warning(IDLoc, "branch is always taken");
       return false;
     }
     if (IsUnsigned) {
       // If the $rs is $0 and the pseudo-branch is BLTU (0 < x) or
       // if the $rt is $0 and the pseudo-branch is BGTU (x > 0),
       // the pseudo-branch will be taken only when the non-zero register is
       // different from 0, so we emit a BNEZ.
       //
       // If the $rs is $0 and the pseudo-branch is BGEU (0 >= x) or
       // if the $rt is $0 and the pseudo-branch is BLEU (x <= 0),
       // the pseudo-branch will be taken only when the non-zero register is
       // equal to 0, so we emit a BEQZ.
       //
       // Because only BLEU and BGEU branch on equality, we can use the
       // AcceptsEquality variable to decide when to emit the BEQZ.
       TOut.emitRRX(AcceptsEquality ? Mips::BEQ : Mips::BNE,
                    IsSrcRegZero ? TrgReg : SrcReg, Mips::ZERO,
                    MCOperand::createExpr(OffsetExpr), IDLoc, STI);
       return false;
     }
     // If we have a signed pseudo-branch and one of the registers is $0,
     // we can use an appropriate compare-to-zero branch. We select which one
     // to use in the switch statement above.
     TOut.emitRX(IsSrcRegZero ? ZeroSrcOpcode : ZeroTrgOpcode,
                 IsSrcRegZero ? TrgReg : SrcReg,
                 MCOperand::createExpr(OffsetExpr), IDLoc, STI);
     return false;
   }
 
   // If neither the SrcReg nor the TrgReg are $0, we need AT to perform the
   // expansions. If it is not available, we return.
   unsigned ATRegNum = getATReg(IDLoc);
   if (!ATRegNum)
     return true;
 
   if (!EmittedNoMacroWarning)
     warnIfNoMacro(IDLoc);
 
   // SLT fits well with 2 of our 4 pseudo-branches:
   //   BLT, where $rs < $rt, translates into "slt $at, $rs, $rt" and
   //   BGT, where $rs > $rt, translates into "slt $at, $rt, $rs".
   // If the result of the SLT is 1, we branch, and if it's 0, we don't.
   // This is accomplished by using a BNEZ with the result of the SLT.
   //
   // The other 2 pseudo-branches are opposites of the above 2 (BGE with BLT
   // and BLE with BGT), so we change the BNEZ into a BEQZ.
   // Because only BGE and BLE branch on equality, we can use the
   // AcceptsEquality variable to decide when to emit the BEQZ.
   // Note that the order of the SLT arguments doesn't change between
   // opposites.
   //
   // The same applies to the unsigned variants, except that SLTu is used
   // instead of SLT.
   TOut.emitRRR(IsUnsigned ? Mips::SLTu : Mips::SLT, ATRegNum,
                ReverseOrderSLT ? TrgReg : SrcReg,
                ReverseOrderSLT ? SrcReg : TrgReg, IDLoc, STI);
 
   TOut.emitRRX(IsLikely ? (AcceptsEquality ? Mips::BEQL : Mips::BNEL)
                         : (AcceptsEquality ? Mips::BEQ : Mips::BNE),
                ATRegNum, Mips::ZERO, MCOperand::createExpr(OffsetExpr), IDLoc,
                STI);
   return false;
 }
 
 // Expand a integer division macro.
 //
 // Notably we don't have to emit a warning when encountering $rt as the $zero
 // register, or 0 as an immediate. processInstruction() has already done that.
 //
 // The destination register can only be $zero when expanding (S)DivIMacro or
 // D(S)DivMacro.
 
 bool MipsAsmParser::expandDivRem(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                  const MCSubtargetInfo *STI,
                                  const bool IsMips64, const bool Signed) {
   MipsTargetStreamer &TOut = getTargetStreamer();
 
   warnIfNoMacro(IDLoc);
 
   const MCOperand &RdRegOp = Inst.getOperand(0);
   assert(RdRegOp.isReg() && "expected register operand kind");
   unsigned RdReg = RdRegOp.getReg();
 
   const MCOperand &RsRegOp = Inst.getOperand(1);
   assert(RsRegOp.isReg() && "expected register operand kind");
   unsigned RsReg = RsRegOp.getReg();
 
   unsigned RtReg;
   int64_t ImmValue;
 
   const MCOperand &RtOp = Inst.getOperand(2);
   assert((RtOp.isReg() || RtOp.isImm()) &&
          "expected register or immediate operand kind");
   if (RtOp.isReg())
     RtReg = RtOp.getReg();
   else
     ImmValue = RtOp.getImm();
 
   unsigned DivOp;
   unsigned ZeroReg;
   unsigned SubOp;
 
   if (IsMips64) {
     DivOp = Signed ? Mips::DSDIV : Mips::DUDIV;
     ZeroReg = Mips::ZERO_64;
     SubOp = Mips::DSUB;
   } else {
     DivOp = Signed ? Mips::SDIV : Mips::UDIV;
     ZeroReg = Mips::ZERO;
     SubOp = Mips::SUB;
   }
 
   bool UseTraps = useTraps();
 
   unsigned Opcode = Inst.getOpcode();
   bool isDiv = Opcode == Mips::SDivMacro || Opcode == Mips::SDivIMacro ||
                Opcode == Mips::UDivMacro || Opcode == Mips::UDivIMacro ||
                Opcode == Mips::DSDivMacro || Opcode == Mips::DSDivIMacro ||
                Opcode == Mips::DUDivMacro || Opcode == Mips::DUDivIMacro;
 
   bool isRem = Opcode == Mips::SRemMacro || Opcode == Mips::SRemIMacro ||
                Opcode == Mips::URemMacro || Opcode == Mips::URemIMacro ||
                Opcode == Mips::DSRemMacro || Opcode == Mips::DSRemIMacro ||
                Opcode == Mips::DURemMacro || Opcode == Mips::DURemIMacro;
 
   if (RtOp.isImm()) {
     unsigned ATReg = getATReg(IDLoc);
     if (!ATReg)
       return true;
 
     if (ImmValue == 0) {
       if (UseTraps)
         TOut.emitRRI(Mips::TEQ, ZeroReg, ZeroReg, 0x7, IDLoc, STI);
       else
         TOut.emitII(Mips::BREAK, 0x7, 0, IDLoc, STI);
       return false;
     }
 
     if (isRem && (ImmValue == 1 || (Signed && (ImmValue == -1)))) {
       TOut.emitRRR(Mips::OR, RdReg, ZeroReg, ZeroReg, IDLoc, STI);
       return false;
     } else if (isDiv && ImmValue == 1) {
       TOut.emitRRR(Mips::OR, RdReg, RsReg, Mips::ZERO, IDLoc, STI);
       return false;
     } else if (isDiv && Signed && ImmValue == -1) {
       TOut.emitRRR(SubOp, RdReg, ZeroReg, RsReg, IDLoc, STI);
       return false;
     } else {
       if (loadImmediate(ImmValue, ATReg, Mips::NoRegister, isInt<32>(ImmValue),
                         false, Inst.getLoc(), Out, STI))
         return true;
       TOut.emitRR(DivOp, RsReg, ATReg, IDLoc, STI);
       TOut.emitR(isDiv ? Mips::MFLO : Mips::MFHI, RdReg, IDLoc, STI);
       return false;
     }
     return true;
   }
 
   // If the macro expansion of (d)div(u) or (d)rem(u) would always trap or
   // break, insert the trap/break and exit. This gives a different result to
   // GAS. GAS has an inconsistency/missed optimization in that not all cases
   // are handled equivalently. As the observed behaviour is the same, we're ok.
   if (RtReg == Mips::ZERO || RtReg == Mips::ZERO_64) {
     if (UseTraps) {
       TOut.emitRRI(Mips::TEQ, ZeroReg, ZeroReg, 0x7, IDLoc, STI);
       return false;
     }
     TOut.emitII(Mips::BREAK, 0x7, 0, IDLoc, STI);
     return false;
   }
 
   // (d)rem(u) $0, $X, $Y is a special case. Like div $zero, $X, $Y, it does
   // not expand to macro sequence.
   if (isRem && (RdReg == Mips::ZERO || RdReg == Mips::ZERO_64)) {
     TOut.emitRR(DivOp, RsReg, RtReg, IDLoc, STI);
     return false;
   }
 
   // Temporary label for first branch traget
   MCContext &Context = TOut.getStreamer().getContext();
   MCSymbol *BrTarget;
   MCOperand LabelOp;
 
   if (UseTraps) {
     TOut.emitRRI(Mips::TEQ, RtReg, ZeroReg, 0x7, IDLoc, STI);
   } else {
     // Branch to the li instruction.
     BrTarget = Context.createTempSymbol();
     LabelOp = MCOperand::createExpr(MCSymbolRefExpr::create(BrTarget, Context));
     TOut.emitRRX(Mips::BNE, RtReg, ZeroReg, LabelOp, IDLoc, STI);
   }
 
   TOut.emitRR(DivOp, RsReg, RtReg, IDLoc, STI);
 
   if (!UseTraps)
     TOut.emitII(Mips::BREAK, 0x7, 0, IDLoc, STI);
 
   if (!Signed) {
     if (!UseTraps)
       TOut.getStreamer().emitLabel(BrTarget);
 
     TOut.emitR(isDiv ? Mips::MFLO : Mips::MFHI, RdReg, IDLoc, STI);
     return false;
   }
 
   unsigned ATReg = getATReg(IDLoc);
   if (!ATReg)
     return true;
 
   if (!UseTraps)
     TOut.getStreamer().emitLabel(BrTarget);
 
   TOut.emitRRI(Mips::ADDiu, ATReg, ZeroReg, -1, IDLoc, STI);
 
   // Temporary label for the second branch target.
   MCSymbol *BrTargetEnd = Context.createTempSymbol();
   MCOperand LabelOpEnd =
       MCOperand::createExpr(MCSymbolRefExpr::create(BrTargetEnd, Context));
 
   // Branch to the mflo instruction.
   TOut.emitRRX(Mips::BNE, RtReg, ATReg, LabelOpEnd, IDLoc, STI);
 
   if (IsMips64) {
     TOut.emitRRI(Mips::ADDiu, ATReg, ZeroReg, 1, IDLoc, STI);
     TOut.emitDSLL(ATReg, ATReg, 63, IDLoc, STI);
   } else {
     TOut.emitRI(Mips::LUi, ATReg, (uint16_t)0x8000, IDLoc, STI);
   }
 
   if (UseTraps)
     TOut.emitRRI(Mips::TEQ, RsReg, ATReg, 0x6, IDLoc, STI);
   else {
     // Branch to the mflo instruction.
     TOut.emitRRX(Mips::BNE, RsReg, ATReg, LabelOpEnd, IDLoc, STI);
     TOut.emitNop(IDLoc, STI);
     TOut.emitII(Mips::BREAK, 0x6, 0, IDLoc, STI);
   }
 
   TOut.getStreamer().emitLabel(BrTargetEnd);
   TOut.emitR(isDiv ? Mips::MFLO : Mips::MFHI, RdReg, IDLoc, STI);
   return false;
 }
 
 bool MipsAsmParser::expandTrunc(MCInst &Inst, bool IsDouble, bool Is64FPU,
                                 SMLoc IDLoc, MCStreamer &Out,
                                 const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
 
   assert(Inst.getNumOperands() == 3 && "Invalid operand count");
   assert(Inst.getOperand(0).isReg() && Inst.getOperand(1).isReg() &&
          Inst.getOperand(2).isReg() && "Invalid instruction operand.");
 
   unsigned FirstReg = Inst.getOperand(0).getReg();
   unsigned SecondReg = Inst.getOperand(1).getReg();
   unsigned ThirdReg = Inst.getOperand(2).getReg();
 
   if (hasMips1() && !hasMips2()) {
     unsigned ATReg = getATReg(IDLoc);
     if (!ATReg)
       return true;
     TOut.emitRR(Mips::CFC1, ThirdReg, Mips::RA, IDLoc, STI);
     TOut.emitRR(Mips::CFC1, ThirdReg, Mips::RA, IDLoc, STI);
     TOut.emitNop(IDLoc, STI);
     TOut.emitRRI(Mips::ORi, ATReg, ThirdReg, 0x3, IDLoc, STI);
     TOut.emitRRI(Mips::XORi, ATReg, ATReg, 0x2, IDLoc, STI);
     TOut.emitRR(Mips::CTC1, Mips::RA, ATReg, IDLoc, STI);
     TOut.emitNop(IDLoc, STI);
     TOut.emitRR(IsDouble ? (Is64FPU ? Mips::CVT_W_D64 : Mips::CVT_W_D32)
                          : Mips::CVT_W_S,
                 FirstReg, SecondReg, IDLoc, STI);
     TOut.emitRR(Mips::CTC1, Mips::RA, ThirdReg, IDLoc, STI);
     TOut.emitNop(IDLoc, STI);
     return false;
   }
 
   TOut.emitRR(IsDouble ? (Is64FPU ? Mips::TRUNC_W_D64 : Mips::TRUNC_W_D32)
                        : Mips::TRUNC_W_S,
               FirstReg, SecondReg, IDLoc, STI);
 
   return false;
 }
 
 bool MipsAsmParser::expandUlh(MCInst &Inst, bool Signed, SMLoc IDLoc,
                               MCStreamer &Out, const MCSubtargetInfo *STI) {
   if (hasMips32r6() || hasMips64r6()) {
     return Error(IDLoc, "instruction not supported on mips32r6 or mips64r6");
   }
 
   const MCOperand &DstRegOp = Inst.getOperand(0);
   assert(DstRegOp.isReg() && "expected register operand kind");
   const MCOperand &SrcRegOp = Inst.getOperand(1);
   assert(SrcRegOp.isReg() && "expected register operand kind");
   const MCOperand &OffsetImmOp = Inst.getOperand(2);
   assert(OffsetImmOp.isImm() && "expected immediate operand kind");
 
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned DstReg = DstRegOp.getReg();
   unsigned SrcReg = SrcRegOp.getReg();
   int64_t OffsetValue = OffsetImmOp.getImm();
 
   // NOTE: We always need AT for ULHU, as it is always used as the source
   // register for one of the LBu's.
   warnIfNoMacro(IDLoc);
   unsigned ATReg = getATReg(IDLoc);
   if (!ATReg)
     return true;
 
   bool IsLargeOffset = !(isInt<16>(OffsetValue + 1) && isInt<16>(OffsetValue));
   if (IsLargeOffset) {
     if (loadImmediate(OffsetValue, ATReg, SrcReg, !ABI.ArePtrs64bit(), true,
                       IDLoc, Out, STI))
       return true;
   }
 
   int64_t FirstOffset = IsLargeOffset ? 0 : OffsetValue;
   int64_t SecondOffset = IsLargeOffset ? 1 : (OffsetValue + 1);
   if (isLittle())
     std::swap(FirstOffset, SecondOffset);
 
   unsigned FirstLbuDstReg = IsLargeOffset ? DstReg : ATReg;
   unsigned SecondLbuDstReg = IsLargeOffset ? ATReg : DstReg;
 
   unsigned LbuSrcReg = IsLargeOffset ? ATReg : SrcReg;
   unsigned SllReg = IsLargeOffset ? DstReg : ATReg;
 
   TOut.emitRRI(Signed ? Mips::LB : Mips::LBu, FirstLbuDstReg, LbuSrcReg,
                FirstOffset, IDLoc, STI);
   TOut.emitRRI(Mips::LBu, SecondLbuDstReg, LbuSrcReg, SecondOffset, IDLoc, STI);
   TOut.emitRRI(Mips::SLL, SllReg, SllReg, 8, IDLoc, STI);
   TOut.emitRRR(Mips::OR, DstReg, DstReg, ATReg, IDLoc, STI);
 
   return false;
 }
 
 bool MipsAsmParser::expandUsh(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                               const MCSubtargetInfo *STI) {
   if (hasMips32r6() || hasMips64r6()) {
     return Error(IDLoc, "instruction not supported on mips32r6 or mips64r6");
   }
 
   const MCOperand &DstRegOp = Inst.getOperand(0);
   assert(DstRegOp.isReg() && "expected register operand kind");
   const MCOperand &SrcRegOp = Inst.getOperand(1);
   assert(SrcRegOp.isReg() && "expected register operand kind");
   const MCOperand &OffsetImmOp = Inst.getOperand(2);
   assert(OffsetImmOp.isImm() && "expected immediate operand kind");
 
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned DstReg = DstRegOp.getReg();
   unsigned SrcReg = SrcRegOp.getReg();
   int64_t OffsetValue = OffsetImmOp.getImm();
 
   warnIfNoMacro(IDLoc);
   unsigned ATReg = getATReg(IDLoc);
   if (!ATReg)
     return true;
 
   bool IsLargeOffset = !(isInt<16>(OffsetValue + 1) && isInt<16>(OffsetValue));
   if (IsLargeOffset) {
     if (loadImmediate(OffsetValue, ATReg, SrcReg, !ABI.ArePtrs64bit(), true,
                       IDLoc, Out, STI))
       return true;
   }
 
   int64_t FirstOffset = IsLargeOffset ? 1 : (OffsetValue + 1);
   int64_t SecondOffset = IsLargeOffset ? 0 : OffsetValue;
   if (isLittle())
     std::swap(FirstOffset, SecondOffset);
 
   if (IsLargeOffset) {
     TOut.emitRRI(Mips::SB, DstReg, ATReg, FirstOffset, IDLoc, STI);
     TOut.emitRRI(Mips::SRL, DstReg, DstReg, 8, IDLoc, STI);
     TOut.emitRRI(Mips::SB, DstReg, ATReg, SecondOffset, IDLoc, STI);
     TOut.emitRRI(Mips::LBu, ATReg, ATReg, 0, IDLoc, STI);
     TOut.emitRRI(Mips::SLL, DstReg, DstReg, 8, IDLoc, STI);
     TOut.emitRRR(Mips::OR, DstReg, DstReg, ATReg, IDLoc, STI);
   } else {
     TOut.emitRRI(Mips::SB, DstReg, SrcReg, FirstOffset, IDLoc, STI);
     TOut.emitRRI(Mips::SRL, ATReg, DstReg, 8, IDLoc, STI);
     TOut.emitRRI(Mips::SB, ATReg, SrcReg, SecondOffset, IDLoc, STI);
   }
 
   return false;
 }
 
 bool MipsAsmParser::expandUxw(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                               const MCSubtargetInfo *STI) {
   if (hasMips32r6() || hasMips64r6()) {
     return Error(IDLoc, "instruction not supported on mips32r6 or mips64r6");
   }
 
   const MCOperand &DstRegOp = Inst.getOperand(0);
   assert(DstRegOp.isReg() && "expected register operand kind");
   const MCOperand &SrcRegOp = Inst.getOperand(1);
   assert(SrcRegOp.isReg() && "expected register operand kind");
   const MCOperand &OffsetImmOp = Inst.getOperand(2);
   assert(OffsetImmOp.isImm() && "expected immediate operand kind");
 
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned DstReg = DstRegOp.getReg();
   unsigned SrcReg = SrcRegOp.getReg();
   int64_t OffsetValue = OffsetImmOp.getImm();
 
   // Compute left/right load/store offsets.
   bool IsLargeOffset = !(isInt<16>(OffsetValue + 3) && isInt<16>(OffsetValue));
   int64_t LxlOffset = IsLargeOffset ? 0 : OffsetValue;
   int64_t LxrOffset = IsLargeOffset ? 3 : (OffsetValue + 3);
   if (isLittle())
     std::swap(LxlOffset, LxrOffset);
 
   bool IsLoadInst = (Inst.getOpcode() == Mips::Ulw);
   bool DoMove = IsLoadInst && (SrcReg == DstReg) && !IsLargeOffset;
   unsigned TmpReg = SrcReg;
   if (IsLargeOffset || DoMove) {
     warnIfNoMacro(IDLoc);
     TmpReg = getATReg(IDLoc);
     if (!TmpReg)
       return true;
   }
 
   if (IsLargeOffset) {
     if (loadImmediate(OffsetValue, TmpReg, SrcReg, !ABI.ArePtrs64bit(), true,
                       IDLoc, Out, STI))
       return true;
   }
 
   if (DoMove)
     std::swap(DstReg, TmpReg);
 
   unsigned XWL = IsLoadInst ? Mips::LWL : Mips::SWL;
   unsigned XWR = IsLoadInst ? Mips::LWR : Mips::SWR;
   TOut.emitRRI(XWL, DstReg, TmpReg, LxlOffset, IDLoc, STI);
   TOut.emitRRI(XWR, DstReg, TmpReg, LxrOffset, IDLoc, STI);
 
   if (DoMove)
     TOut.emitRRR(Mips::OR, TmpReg, DstReg, Mips::ZERO, IDLoc, STI);
 
   return false;
 }
 
 bool MipsAsmParser::expandSge(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                               const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
 
   assert(Inst.getNumOperands() == 3 && "Invalid operand count");
   assert(Inst.getOperand(0).isReg() &&
          Inst.getOperand(1).isReg() &&
          Inst.getOperand(2).isReg() && "Invalid instruction operand.");
 
   unsigned DstReg = Inst.getOperand(0).getReg();
   unsigned SrcReg = Inst.getOperand(1).getReg();
   unsigned OpReg = Inst.getOperand(2).getReg();
   unsigned OpCode;
 
   warnIfNoMacro(IDLoc);
 
   switch (Inst.getOpcode()) {
   case Mips::SGE:
     OpCode = Mips::SLT;
     break;
   case Mips::SGEU:
     OpCode = Mips::SLTu;
     break;
   default:
     llvm_unreachable("unexpected 'sge' opcode");
   }
 
   // $SrcReg >= $OpReg is equal to (not ($SrcReg < $OpReg))
   TOut.emitRRR(OpCode, DstReg, SrcReg, OpReg, IDLoc, STI);
   TOut.emitRRI(Mips::XORi, DstReg, DstReg, 1, IDLoc, STI);
 
   return false;
 }
 
 bool MipsAsmParser::expandSgeImm(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                  const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
 
   assert(Inst.getNumOperands() == 3 && "Invalid operand count");
   assert(Inst.getOperand(0).isReg() &&
          Inst.getOperand(1).isReg() &&
          Inst.getOperand(2).isImm() && "Invalid instruction operand.");
 
   unsigned DstReg = Inst.getOperand(0).getReg();
   unsigned SrcReg = Inst.getOperand(1).getReg();
   int64_t ImmValue = Inst.getOperand(2).getImm();
   unsigned OpRegCode, OpImmCode;
 
   warnIfNoMacro(IDLoc);
 
   switch (Inst.getOpcode()) {
   case Mips::SGEImm:
   case Mips::SGEImm64:
     OpRegCode = Mips::SLT;
     OpImmCode = Mips::SLTi;
     break;
   case Mips::SGEUImm:
   case Mips::SGEUImm64:
     OpRegCode = Mips::SLTu;
     OpImmCode = Mips::SLTiu;
     break;
   default:
     llvm_unreachable("unexpected 'sge' opcode with immediate");
   }
 
   // $SrcReg >= Imm is equal to (not ($SrcReg < Imm))
   if (isInt<16>(ImmValue)) {
     // Use immediate version of STL.
     TOut.emitRRI(OpImmCode, DstReg, SrcReg, ImmValue, IDLoc, STI);
     TOut.emitRRI(Mips::XORi, DstReg, DstReg, 1, IDLoc, STI);
   } else {
     unsigned ImmReg = DstReg;
     if (DstReg == SrcReg) {
       unsigned ATReg = getATReg(Inst.getLoc());
       if (!ATReg)
         return true;
       ImmReg = ATReg;
     }
 
     if (loadImmediate(ImmValue, ImmReg, Mips::NoRegister, isInt<32>(ImmValue),
                       false, IDLoc, Out, STI))
       return true;
 
     TOut.emitRRR(OpRegCode, DstReg, SrcReg, ImmReg, IDLoc, STI);
     TOut.emitRRI(Mips::XORi, DstReg, DstReg, 1, IDLoc, STI);
   }
 
   return false;
 }
 
 bool MipsAsmParser::expandSgtImm(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                  const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
 
   assert(Inst.getNumOperands() == 3 && "Invalid operand count");
   assert(Inst.getOperand(0).isReg() &&
          Inst.getOperand(1).isReg() &&
          Inst.getOperand(2).isImm() && "Invalid instruction operand.");
 
   unsigned DstReg = Inst.getOperand(0).getReg();
   unsigned SrcReg = Inst.getOperand(1).getReg();
   unsigned ImmReg = DstReg;
   int64_t ImmValue = Inst.getOperand(2).getImm();
   unsigned OpCode;
 
   warnIfNoMacro(IDLoc);
 
   switch (Inst.getOpcode()) {
   case Mips::SGTImm:
   case Mips::SGTImm64:
     OpCode = Mips::SLT;
     break;
   case Mips::SGTUImm:
   case Mips::SGTUImm64:
     OpCode = Mips::SLTu;
     break;
   default:
     llvm_unreachable("unexpected 'sgt' opcode with immediate");
   }
 
   if (DstReg == SrcReg) {
     unsigned ATReg = getATReg(Inst.getLoc());
     if (!ATReg)
       return true;
     ImmReg = ATReg;
   }
 
   if (loadImmediate(ImmValue, ImmReg, Mips::NoRegister, isInt<32>(ImmValue),
                     false, IDLoc, Out, STI))
     return true;
 
   // $SrcReg > $ImmReg is equal to $ImmReg < $SrcReg
   TOut.emitRRR(OpCode, DstReg, ImmReg, SrcReg, IDLoc, STI);
 
   return false;
 }
 
 bool MipsAsmParser::expandSle(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                               const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
 
   assert(Inst.getNumOperands() == 3 && "Invalid operand count");
   assert(Inst.getOperand(0).isReg() &&
          Inst.getOperand(1).isReg() &&
          Inst.getOperand(2).isReg() && "Invalid instruction operand.");
 
   unsigned DstReg = Inst.getOperand(0).getReg();
   unsigned SrcReg = Inst.getOperand(1).getReg();
   unsigned OpReg = Inst.getOperand(2).getReg();
   unsigned OpCode;
 
   warnIfNoMacro(IDLoc);
 
   switch (Inst.getOpcode()) {
   case Mips::SLE:
     OpCode = Mips::SLT;
     break;
   case Mips::SLEU:
     OpCode = Mips::SLTu;
     break;
   default:
     llvm_unreachable("unexpected 'sge' opcode");
   }
 
   // $SrcReg <= $OpReg is equal to (not ($OpReg < $SrcReg))
   TOut.emitRRR(OpCode, DstReg, OpReg, SrcReg, IDLoc, STI);
   TOut.emitRRI(Mips::XORi, DstReg, DstReg, 1, IDLoc, STI);
 
   return false;
 }
 
 bool MipsAsmParser::expandSleImm(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                  const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
 
   assert(Inst.getNumOperands() == 3 && "Invalid operand count");
   assert(Inst.getOperand(0).isReg() &&
          Inst.getOperand(1).isReg() &&
          Inst.getOperand(2).isImm() && "Invalid instruction operand.");
 
   unsigned DstReg = Inst.getOperand(0).getReg();
   unsigned SrcReg = Inst.getOperand(1).getReg();
   int64_t ImmValue = Inst.getOperand(2).getImm();
   unsigned OpRegCode;
 
   warnIfNoMacro(IDLoc);
 
   switch (Inst.getOpcode()) {
   case Mips::SLEImm:
   case Mips::SLEImm64:
     OpRegCode = Mips::SLT;
     break;
   case Mips::SLEUImm:
   case Mips::SLEUImm64:
     OpRegCode = Mips::SLTu;
     break;
   default:
     llvm_unreachable("unexpected 'sge' opcode with immediate");
   }
 
   // $SrcReg <= Imm is equal to (not (Imm < $SrcReg))
   unsigned ImmReg = DstReg;
   if (DstReg == SrcReg) {
     unsigned ATReg = getATReg(Inst.getLoc());
     if (!ATReg)
       return true;
     ImmReg = ATReg;
   }
 
   if (loadImmediate(ImmValue, ImmReg, Mips::NoRegister, isInt<32>(ImmValue),
                     false, IDLoc, Out, STI))
     return true;
 
   TOut.emitRRR(OpRegCode, DstReg, ImmReg, SrcReg, IDLoc, STI);
   TOut.emitRRI(Mips::XORi, DstReg, DstReg, 1, IDLoc, STI);
 
   return false;
 }
 
 bool MipsAsmParser::expandAliasImmediate(MCInst &Inst, SMLoc IDLoc,
                                          MCStreamer &Out,
                                          const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
 
   assert(Inst.getNumOperands() == 3 && "Invalid operand count");
   assert(Inst.getOperand(0).isReg() &&
          Inst.getOperand(1).isReg() &&
          Inst.getOperand(2).isImm() && "Invalid instruction operand.");
 
   unsigned ATReg = Mips::NoRegister;
   unsigned FinalDstReg = Mips::NoRegister;
   unsigned DstReg = Inst.getOperand(0).getReg();
   unsigned SrcReg = Inst.getOperand(1).getReg();
   int64_t ImmValue = Inst.getOperand(2).getImm();
 
   bool Is32Bit = isInt<32>(ImmValue) || (!isGP64bit() && isUInt<32>(ImmValue));
 
   unsigned FinalOpcode = Inst.getOpcode();
 
   if (DstReg == SrcReg) {
     ATReg = getATReg(Inst.getLoc());
     if (!ATReg)
       return true;
     FinalDstReg = DstReg;
     DstReg = ATReg;
   }
 
   if (!loadImmediate(ImmValue, DstReg, Mips::NoRegister, Is32Bit, false,
                      Inst.getLoc(), Out, STI)) {
     switch (FinalOpcode) {
     default:
       llvm_unreachable("unimplemented expansion");
     case Mips::ADDi:
       FinalOpcode = Mips::ADD;
       break;
     case Mips::ADDiu:
       FinalOpcode = Mips::ADDu;
       break;
     case Mips::ANDi:
       FinalOpcode = Mips::AND;
       break;
     case Mips::NORImm:
       FinalOpcode = Mips::NOR;
       break;
     case Mips::ORi:
       FinalOpcode = Mips::OR;
       break;
     case Mips::SLTi:
       FinalOpcode = Mips::SLT;
       break;
     case Mips::SLTiu:
       FinalOpcode = Mips::SLTu;
       break;
     case Mips::XORi:
       FinalOpcode = Mips::XOR;
       break;
     case Mips::ADDi_MM:
       FinalOpcode = Mips::ADD_MM;
       break;
     case Mips::ADDiu_MM:
       FinalOpcode = Mips::ADDu_MM;
       break;
     case Mips::ANDi_MM:
       FinalOpcode = Mips::AND_MM;
       break;
     case Mips::ORi_MM:
       FinalOpcode = Mips::OR_MM;
       break;
     case Mips::SLTi_MM:
       FinalOpcode = Mips::SLT_MM;
       break;
     case Mips::SLTiu_MM:
       FinalOpcode = Mips::SLTu_MM;
       break;
     case Mips::XORi_MM:
       FinalOpcode = Mips::XOR_MM;
       break;
     case Mips::ANDi64:
       FinalOpcode = Mips::AND64;
       break;
     case Mips::NORImm64:
       FinalOpcode = Mips::NOR64;
       break;
     case Mips::ORi64:
       FinalOpcode = Mips::OR64;
       break;
     case Mips::SLTImm64:
       FinalOpcode = Mips::SLT64;
       break;
     case Mips::SLTUImm64:
       FinalOpcode = Mips::SLTu64;
       break;
     case Mips::XORi64:
       FinalOpcode = Mips::XOR64;
       break;
     }
 
     if (FinalDstReg == Mips::NoRegister)
       TOut.emitRRR(FinalOpcode, DstReg, DstReg, SrcReg, IDLoc, STI);
     else
       TOut.emitRRR(FinalOpcode, FinalDstReg, FinalDstReg, DstReg, IDLoc, STI);
     return false;
   }
   return true;
 }
 
 bool MipsAsmParser::expandRotation(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                    const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned ATReg = Mips::NoRegister;
   unsigned DReg = Inst.getOperand(0).getReg();
   unsigned SReg = Inst.getOperand(1).getReg();
   unsigned TReg = Inst.getOperand(2).getReg();
   unsigned TmpReg = DReg;
 
   unsigned FirstShift = Mips::NOP;
   unsigned SecondShift = Mips::NOP;
 
   if (hasMips32r2()) {
     if (DReg == SReg) {
       TmpReg = getATReg(Inst.getLoc());
       if (!TmpReg)
         return true;
     }
 
     if (Inst.getOpcode() == Mips::ROL) {
       TOut.emitRRR(Mips::SUBu, TmpReg, Mips::ZERO, TReg, Inst.getLoc(), STI);
       TOut.emitRRR(Mips::ROTRV, DReg, SReg, TmpReg, Inst.getLoc(), STI);
       return false;
     }
 
     if (Inst.getOpcode() == Mips::ROR) {
       TOut.emitRRR(Mips::ROTRV, DReg, SReg, TReg, Inst.getLoc(), STI);
       return false;
     }
 
     return true;
   }
 
   if (hasMips32()) {
     switch (Inst.getOpcode()) {
     default:
       llvm_unreachable("unexpected instruction opcode");
     case Mips::ROL:
       FirstShift = Mips::SRLV;
       SecondShift = Mips::SLLV;
       break;
     case Mips::ROR:
       FirstShift = Mips::SLLV;
       SecondShift = Mips::SRLV;
       break;
     }
 
     ATReg = getATReg(Inst.getLoc());
     if (!ATReg)
       return true;
 
     TOut.emitRRR(Mips::SUBu, ATReg, Mips::ZERO, TReg, Inst.getLoc(), STI);
     TOut.emitRRR(FirstShift, ATReg, SReg, ATReg, Inst.getLoc(), STI);
     TOut.emitRRR(SecondShift, DReg, SReg, TReg, Inst.getLoc(), STI);
     TOut.emitRRR(Mips::OR, DReg, DReg, ATReg, Inst.getLoc(), STI);
 
     return false;
   }
 
   return true;
 }
 
 bool MipsAsmParser::expandRotationImm(MCInst &Inst, SMLoc IDLoc,
                                       MCStreamer &Out,
                                       const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned ATReg = Mips::NoRegister;
   unsigned DReg = Inst.getOperand(0).getReg();
   unsigned SReg = Inst.getOperand(1).getReg();
   int64_t ImmValue = Inst.getOperand(2).getImm();
 
   unsigned FirstShift = Mips::NOP;
   unsigned SecondShift = Mips::NOP;
 
   if (hasMips32r2()) {
     if (Inst.getOpcode() == Mips::ROLImm) {
       uint64_t MaxShift = 32;
       uint64_t ShiftValue = ImmValue;
       if (ImmValue != 0)
         ShiftValue = MaxShift - ImmValue;
       TOut.emitRRI(Mips::ROTR, DReg, SReg, ShiftValue, Inst.getLoc(), STI);
       return false;
     }
 
     if (Inst.getOpcode() == Mips::RORImm) {
       TOut.emitRRI(Mips::ROTR, DReg, SReg, ImmValue, Inst.getLoc(), STI);
       return false;
     }
 
     return true;
   }
 
   if (hasMips32()) {
     if (ImmValue == 0) {
       TOut.emitRRI(Mips::SRL, DReg, SReg, 0, Inst.getLoc(), STI);
       return false;
     }
 
     switch (Inst.getOpcode()) {
     default:
       llvm_unreachable("unexpected instruction opcode");
     case Mips::ROLImm:
       FirstShift = Mips::SLL;
       SecondShift = Mips::SRL;
       break;
     case Mips::RORImm:
       FirstShift = Mips::SRL;
       SecondShift = Mips::SLL;
       break;
     }
 
     ATReg = getATReg(Inst.getLoc());
     if (!ATReg)
       return true;
 
     TOut.emitRRI(FirstShift, ATReg, SReg, ImmValue, Inst.getLoc(), STI);
     TOut.emitRRI(SecondShift, DReg, SReg, 32 - ImmValue, Inst.getLoc(), STI);
     TOut.emitRRR(Mips::OR, DReg, DReg, ATReg, Inst.getLoc(), STI);
 
     return false;
   }
 
   return true;
 }
 
 bool MipsAsmParser::expandDRotation(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                     const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned ATReg = Mips::NoRegister;
   unsigned DReg = Inst.getOperand(0).getReg();
   unsigned SReg = Inst.getOperand(1).getReg();
   unsigned TReg = Inst.getOperand(2).getReg();
   unsigned TmpReg = DReg;
 
   unsigned FirstShift = Mips::NOP;
   unsigned SecondShift = Mips::NOP;
 
   if (hasMips64r2()) {
     if (TmpReg == SReg) {
       TmpReg = getATReg(Inst.getLoc());
       if (!TmpReg)
         return true;
     }
 
     if (Inst.getOpcode() == Mips::DROL) {
       TOut.emitRRR(Mips::DSUBu, TmpReg, Mips::ZERO, TReg, Inst.getLoc(), STI);
       TOut.emitRRR(Mips::DROTRV, DReg, SReg, TmpReg, Inst.getLoc(), STI);
       return false;
     }
 
     if (Inst.getOpcode() == Mips::DROR) {
       TOut.emitRRR(Mips::DROTRV, DReg, SReg, TReg, Inst.getLoc(), STI);
       return false;
     }
 
     return true;
   }
 
   if (hasMips64()) {
     switch (Inst.getOpcode()) {
     default:
       llvm_unreachable("unexpected instruction opcode");
     case Mips::DROL:
       FirstShift = Mips::DSRLV;
       SecondShift = Mips::DSLLV;
       break;
     case Mips::DROR:
       FirstShift = Mips::DSLLV;
       SecondShift = Mips::DSRLV;
       break;
     }
 
     ATReg = getATReg(Inst.getLoc());
     if (!ATReg)
       return true;
 
     TOut.emitRRR(Mips::DSUBu, ATReg, Mips::ZERO, TReg, Inst.getLoc(), STI);
     TOut.emitRRR(FirstShift, ATReg, SReg, ATReg, Inst.getLoc(), STI);
     TOut.emitRRR(SecondShift, DReg, SReg, TReg, Inst.getLoc(), STI);
     TOut.emitRRR(Mips::OR, DReg, DReg, ATReg, Inst.getLoc(), STI);
 
     return false;
   }
 
   return true;
 }
 
 bool MipsAsmParser::expandDRotationImm(MCInst &Inst, SMLoc IDLoc,
                                        MCStreamer &Out,
                                        const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned ATReg = Mips::NoRegister;
   unsigned DReg = Inst.getOperand(0).getReg();
   unsigned SReg = Inst.getOperand(1).getReg();
   int64_t ImmValue = Inst.getOperand(2).getImm() % 64;
 
   unsigned FirstShift = Mips::NOP;
   unsigned SecondShift = Mips::NOP;
 
   MCInst TmpInst;
 
   if (hasMips64r2()) {
     unsigned FinalOpcode = Mips::NOP;
     if (ImmValue == 0)
       FinalOpcode = Mips::DROTR;
     else if (ImmValue % 32 == 0)
       FinalOpcode = Mips::DROTR32;
     else if ((ImmValue >= 1) && (ImmValue <= 32)) {
       if (Inst.getOpcode() == Mips::DROLImm)
         FinalOpcode = Mips::DROTR32;
       else
         FinalOpcode = Mips::DROTR;
     } else if (ImmValue >= 33) {
       if (Inst.getOpcode() == Mips::DROLImm)
         FinalOpcode = Mips::DROTR;
       else
         FinalOpcode = Mips::DROTR32;
     }
 
     uint64_t ShiftValue = ImmValue % 32;
     if (Inst.getOpcode() == Mips::DROLImm)
       ShiftValue = (32 - ImmValue % 32) % 32;
 
     TOut.emitRRI(FinalOpcode, DReg, SReg, ShiftValue, Inst.getLoc(), STI);
 
     return false;
   }
 
   if (hasMips64()) {
     if (ImmValue == 0) {
       TOut.emitRRI(Mips::DSRL, DReg, SReg, 0, Inst.getLoc(), STI);
       return false;
     }
 
     switch (Inst.getOpcode()) {
     default:
       llvm_unreachable("unexpected instruction opcode");
     case Mips::DROLImm:
       if ((ImmValue >= 1) && (ImmValue <= 31)) {
         FirstShift = Mips::DSLL;
         SecondShift = Mips::DSRL32;
       }
       if (ImmValue == 32) {
         FirstShift = Mips::DSLL32;
         SecondShift = Mips::DSRL32;
       }
       if ((ImmValue >= 33) && (ImmValue <= 63)) {
         FirstShift = Mips::DSLL32;
         SecondShift = Mips::DSRL;
       }
       break;
     case Mips::DRORImm:
       if ((ImmValue >= 1) && (ImmValue <= 31)) {
         FirstShift = Mips::DSRL;
         SecondShift = Mips::DSLL32;
       }
       if (ImmValue == 32) {
         FirstShift = Mips::DSRL32;
         SecondShift = Mips::DSLL32;
       }
       if ((ImmValue >= 33) && (ImmValue <= 63)) {
         FirstShift = Mips::DSRL32;
         SecondShift = Mips::DSLL;
       }
       break;
     }
 
     ATReg = getATReg(Inst.getLoc());
     if (!ATReg)
       return true;
 
     TOut.emitRRI(FirstShift, ATReg, SReg, ImmValue % 32, Inst.getLoc(), STI);
     TOut.emitRRI(SecondShift, DReg, SReg, (32 - ImmValue % 32) % 32,
                  Inst.getLoc(), STI);
     TOut.emitRRR(Mips::OR, DReg, DReg, ATReg, Inst.getLoc(), STI);
 
     return false;
   }
 
   return true;
 }
 
 bool MipsAsmParser::expandAbs(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                               const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned FirstRegOp = Inst.getOperand(0).getReg();
   unsigned SecondRegOp = Inst.getOperand(1).getReg();
 
   TOut.emitRI(Mips::BGEZ, SecondRegOp, 8, IDLoc, STI);
   if (FirstRegOp != SecondRegOp)
     TOut.emitRRR(Mips::ADDu, FirstRegOp, SecondRegOp, Mips::ZERO, IDLoc, STI);
   else
     TOut.emitEmptyDelaySlot(false, IDLoc, STI);
   TOut.emitRRR(Mips::SUB, FirstRegOp, Mips::ZERO, SecondRegOp, IDLoc, STI);
 
   return false;
 }
 
 bool MipsAsmParser::expandMulImm(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                  const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned ATReg = Mips::NoRegister;
   unsigned DstReg = Inst.getOperand(0).getReg();
   unsigned SrcReg = Inst.getOperand(1).getReg();
   int32_t ImmValue = Inst.getOperand(2).getImm();
 
   ATReg = getATReg(IDLoc);
   if (!ATReg)
     return true;
 
   loadImmediate(ImmValue, ATReg, Mips::NoRegister, true, false, IDLoc, Out,
                 STI);
 
   TOut.emitRR(Inst.getOpcode() == Mips::MULImmMacro ? Mips::MULT : Mips::DMULT,
               SrcReg, ATReg, IDLoc, STI);
 
   TOut.emitR(Mips::MFLO, DstReg, IDLoc, STI);
 
   return false;
 }
 
 bool MipsAsmParser::expandMulO(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned ATReg = Mips::NoRegister;
   unsigned DstReg = Inst.getOperand(0).getReg();
   unsigned SrcReg = Inst.getOperand(1).getReg();
   unsigned TmpReg = Inst.getOperand(2).getReg();
 
   ATReg = getATReg(Inst.getLoc());
   if (!ATReg)
     return true;
 
   TOut.emitRR(Inst.getOpcode() == Mips::MULOMacro ? Mips::MULT : Mips::DMULT,
               SrcReg, TmpReg, IDLoc, STI);
 
   TOut.emitR(Mips::MFLO, DstReg, IDLoc, STI);
 
   TOut.emitRRI(Inst.getOpcode() == Mips::MULOMacro ? Mips::SRA : Mips::DSRA32,
                DstReg, DstReg, 0x1F, IDLoc, STI);
 
   TOut.emitR(Mips::MFHI, ATReg, IDLoc, STI);
 
   if (useTraps()) {
     TOut.emitRRI(Mips::TNE, DstReg, ATReg, 6, IDLoc, STI);
   } else {
     MCContext & Context = TOut.getStreamer().getContext();
     MCSymbol * BrTarget = Context.createTempSymbol();
     MCOperand LabelOp =
         MCOperand::createExpr(MCSymbolRefExpr::create(BrTarget, Context));
 
     TOut.emitRRX(Mips::BEQ, DstReg, ATReg, LabelOp, IDLoc, STI);
     if (AssemblerOptions.back()->isReorder())
       TOut.emitNop(IDLoc, STI);
     TOut.emitII(Mips::BREAK, 6, 0, IDLoc, STI);
 
     TOut.getStreamer().emitLabel(BrTarget);
   }
   TOut.emitR(Mips::MFLO, DstReg, IDLoc, STI);
 
   return false;
 }
 
 bool MipsAsmParser::expandMulOU(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                 const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned ATReg = Mips::NoRegister;
   unsigned DstReg = Inst.getOperand(0).getReg();
   unsigned SrcReg = Inst.getOperand(1).getReg();
   unsigned TmpReg = Inst.getOperand(2).getReg();
 
   ATReg = getATReg(IDLoc);
   if (!ATReg)
     return true;
 
   TOut.emitRR(Inst.getOpcode() == Mips::MULOUMacro ? Mips::MULTu : Mips::DMULTu,
               SrcReg, TmpReg, IDLoc, STI);
 
   TOut.emitR(Mips::MFHI, ATReg, IDLoc, STI);
   TOut.emitR(Mips::MFLO, DstReg, IDLoc, STI);
   if (useTraps()) {
     TOut.emitRRI(Mips::TNE, ATReg, Mips::ZERO, 6, IDLoc, STI);
   } else {
     MCContext & Context = TOut.getStreamer().getContext();
     MCSymbol * BrTarget = Context.createTempSymbol();
     MCOperand LabelOp =
         MCOperand::createExpr(MCSymbolRefExpr::create(BrTarget, Context));
 
     TOut.emitRRX(Mips::BEQ, ATReg, Mips::ZERO, LabelOp, IDLoc, STI);
     if (AssemblerOptions.back()->isReorder())
       TOut.emitNop(IDLoc, STI);
     TOut.emitII(Mips::BREAK, 6, 0, IDLoc, STI);
 
     TOut.getStreamer().emitLabel(BrTarget);
   }
 
   return false;
 }
 
 bool MipsAsmParser::expandDMULMacro(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                     const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned DstReg = Inst.getOperand(0).getReg();
   unsigned SrcReg = Inst.getOperand(1).getReg();
   unsigned TmpReg = Inst.getOperand(2).getReg();
 
   TOut.emitRR(Mips::DMULTu, SrcReg, TmpReg, IDLoc, STI);
   TOut.emitR(Mips::MFLO, DstReg, IDLoc, STI);
 
   return false;
 }
 
 // Expand 'ld $<reg> offset($reg2)' to 'lw $<reg>, offset($reg2);
 //                                      lw $<reg+1>>, offset+4($reg2)'
 // or expand 'sd $<reg> offset($reg2)' to 'sw $<reg>, offset($reg2);
 //                                         sw $<reg+1>>, offset+4($reg2)'
 // for O32.
 bool MipsAsmParser::expandLoadStoreDMacro(MCInst &Inst, SMLoc IDLoc,
                                           MCStreamer &Out,
                                           const MCSubtargetInfo *STI,
                                           bool IsLoad) {
   if (!isABI_O32())
     return true;
 
   warnIfNoMacro(IDLoc);
 
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned Opcode = IsLoad ? Mips::LW : Mips::SW;
   unsigned FirstReg = Inst.getOperand(0).getReg();
   unsigned SecondReg = nextReg(FirstReg);
   unsigned BaseReg = Inst.getOperand(1).getReg();
   if (!SecondReg)
     return true;
 
   warnIfRegIndexIsAT(FirstReg, IDLoc);
 
   assert(Inst.getOperand(2).isImm() &&
          "Offset for load macro is not immediate!");
 
   MCOperand &FirstOffset = Inst.getOperand(2);
   signed NextOffset = FirstOffset.getImm() + 4;
   MCOperand SecondOffset = MCOperand::createImm(NextOffset);
 
   if (!isInt<16>(FirstOffset.getImm()) || !isInt<16>(NextOffset))
     return true;
 
   // For loads, clobber the base register with the second load instead of the
   // first if the BaseReg == FirstReg.
   if (FirstReg != BaseReg || !IsLoad) {
     TOut.emitRRX(Opcode, FirstReg, BaseReg, FirstOffset, IDLoc, STI);
     TOut.emitRRX(Opcode, SecondReg, BaseReg, SecondOffset, IDLoc, STI);
   } else {
     TOut.emitRRX(Opcode, SecondReg, BaseReg, SecondOffset, IDLoc, STI);
     TOut.emitRRX(Opcode, FirstReg, BaseReg, FirstOffset, IDLoc, STI);
   }
 
   return false;
 }
 
 
 // Expand 's.d $<reg> offset($reg2)' to 'swc1 $<reg+1>, offset($reg2);
 //                                       swc1 $<reg>, offset+4($reg2)'
 // or if little endian to 'swc1 $<reg>, offset($reg2);
 //                         swc1 $<reg+1>, offset+4($reg2)'
 // for Mips1.
 bool MipsAsmParser::expandStoreDM1Macro(MCInst &Inst, SMLoc IDLoc,
                                         MCStreamer &Out,
                                         const MCSubtargetInfo *STI) {
   if (!isABI_O32())
     return true;
 
   warnIfNoMacro(IDLoc);
 
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned Opcode = Mips::SWC1;
   unsigned FirstReg = Inst.getOperand(0).getReg();
   unsigned SecondReg = nextReg(FirstReg);
   unsigned BaseReg = Inst.getOperand(1).getReg();
   if (!SecondReg)
     return true;
 
   warnIfRegIndexIsAT(FirstReg, IDLoc);
 
   assert(Inst.getOperand(2).isImm() &&
          "Offset for macro is not immediate!");
 
   MCOperand &FirstOffset = Inst.getOperand(2);
   signed NextOffset = FirstOffset.getImm() + 4;
   MCOperand SecondOffset = MCOperand::createImm(NextOffset);
 
   if (!isInt<16>(FirstOffset.getImm()) || !isInt<16>(NextOffset))
     return true;
 
   if (!IsLittleEndian)
     std::swap(FirstReg, SecondReg);
 
   TOut.emitRRX(Opcode, FirstReg, BaseReg, FirstOffset, IDLoc, STI);
   TOut.emitRRX(Opcode, SecondReg, BaseReg, SecondOffset, IDLoc, STI);
 
   return false;
 }
 
 bool MipsAsmParser::expandSeq(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                               const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
 
   assert(Inst.getNumOperands() == 3 && "Invalid operand count");
   assert(Inst.getOperand(0).isReg() &&
          Inst.getOperand(1).isReg() &&
          Inst.getOperand(2).isReg() && "Invalid instruction operand.");
 
   unsigned DstReg = Inst.getOperand(0).getReg();
   unsigned SrcReg = Inst.getOperand(1).getReg();
   unsigned OpReg = Inst.getOperand(2).getReg();
 
   warnIfNoMacro(IDLoc);
 
   if (SrcReg != Mips::ZERO && OpReg != Mips::ZERO) {
     TOut.emitRRR(Mips::XOR, DstReg, SrcReg, OpReg, IDLoc, STI);
     TOut.emitRRI(Mips::SLTiu, DstReg, DstReg, 1, IDLoc, STI);
     return false;
   }
 
   unsigned Reg = SrcReg == Mips::ZERO ? OpReg : SrcReg;
   TOut.emitRRI(Mips::SLTiu, DstReg, Reg, 1, IDLoc, STI);
   return false;
 }
 
 bool MipsAsmParser::expandSeqI(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
 
   assert(Inst.getNumOperands() == 3 && "Invalid operand count");
   assert(Inst.getOperand(0).isReg() &&
          Inst.getOperand(1).isReg() &&
          Inst.getOperand(2).isImm() && "Invalid instruction operand.");
 
   unsigned DstReg = Inst.getOperand(0).getReg();
   unsigned SrcReg = Inst.getOperand(1).getReg();
   int64_t Imm = Inst.getOperand(2).getImm();
 
   warnIfNoMacro(IDLoc);
 
   if (Imm == 0) {
     TOut.emitRRI(Mips::SLTiu, DstReg, SrcReg, 1, IDLoc, STI);
     return false;
   }
 
   if (SrcReg == Mips::ZERO) {
     Warning(IDLoc, "comparison is always false");
     TOut.emitRRR(isGP64bit() ? Mips::DADDu : Mips::ADDu,
                  DstReg, SrcReg, SrcReg, IDLoc, STI);
     return false;
   }
 
   unsigned Opc;
   if (Imm > -0x8000 && Imm < 0) {
     Imm = -Imm;
     Opc = isGP64bit() ? Mips::DADDiu : Mips::ADDiu;
   } else {
     Opc = Mips::XORi;
   }
 
   if (!isUInt<16>(Imm)) {
     unsigned ATReg = getATReg(IDLoc);
     if (!ATReg)
       return true;
 
     if (loadImmediate(Imm, ATReg, Mips::NoRegister, true, isGP64bit(), IDLoc,
                       Out, STI))
       return true;
 
     TOut.emitRRR(Mips::XOR, DstReg, SrcReg, ATReg, IDLoc, STI);
     TOut.emitRRI(Mips::SLTiu, DstReg, DstReg, 1, IDLoc, STI);
     return false;
   }
 
   TOut.emitRRI(Opc, DstReg, SrcReg, Imm, IDLoc, STI);
   TOut.emitRRI(Mips::SLTiu, DstReg, DstReg, 1, IDLoc, STI);
   return false;
 }
 
 bool MipsAsmParser::expandSne(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                               const MCSubtargetInfo *STI) {
 
   MipsTargetStreamer &TOut = getTargetStreamer();
 
   assert(Inst.getNumOperands() == 3 && "Invalid operand count");
   assert(Inst.getOperand(0).isReg() &&
          Inst.getOperand(1).isReg() &&
          Inst.getOperand(2).isReg() && "Invalid instruction operand.");
 
   unsigned DstReg = Inst.getOperand(0).getReg();
   unsigned SrcReg = Inst.getOperand(1).getReg();
   unsigned OpReg = Inst.getOperand(2).getReg();
 
   warnIfNoMacro(IDLoc);
 
   if (SrcReg != Mips::ZERO && OpReg != Mips::ZERO) {
     TOut.emitRRR(Mips::XOR, DstReg, SrcReg, OpReg, IDLoc, STI);
     TOut.emitRRR(Mips::SLTu, DstReg, Mips::ZERO, DstReg, IDLoc, STI);
     return false;
   }
 
   unsigned Reg = SrcReg == Mips::ZERO ? OpReg : SrcReg;
   TOut.emitRRR(Mips::SLTu, DstReg, Mips::ZERO, Reg, IDLoc, STI);
   return false;
 }
 
 bool MipsAsmParser::expandSneI(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
 
   assert(Inst.getNumOperands() == 3 && "Invalid operand count");
   assert(Inst.getOperand(0).isReg() &&
          Inst.getOperand(1).isReg() &&
          Inst.getOperand(2).isImm() && "Invalid instruction operand.");
 
   unsigned DstReg = Inst.getOperand(0).getReg();
   unsigned SrcReg = Inst.getOperand(1).getReg();
   int64_t ImmValue = Inst.getOperand(2).getImm();
 
   warnIfNoMacro(IDLoc);
 
   if (ImmValue == 0) {
     TOut.emitRRR(Mips::SLTu, DstReg, Mips::ZERO, SrcReg, IDLoc, STI);
     return false;
   }
 
   if (SrcReg == Mips::ZERO) {
     Warning(IDLoc, "comparison is always true");
     if (loadImmediate(1, DstReg, Mips::NoRegister, true, false, IDLoc, Out,
                       STI))
       return true;
     return false;
   }
 
   unsigned Opc;
   if (ImmValue > -0x8000 && ImmValue < 0) {
     ImmValue = -ImmValue;
     Opc = isGP64bit() ? Mips::DADDiu : Mips::ADDiu;
   } else {
     Opc = Mips::XORi;
   }
 
   if (isUInt<16>(ImmValue)) {
     TOut.emitRRI(Opc, DstReg, SrcReg, ImmValue, IDLoc, STI);
     TOut.emitRRR(Mips::SLTu, DstReg, Mips::ZERO, DstReg, IDLoc, STI);
     return false;
   }
 
   unsigned ATReg = getATReg(IDLoc);
   if (!ATReg)
     return true;
 
   if (loadImmediate(ImmValue, ATReg, Mips::NoRegister, isInt<32>(ImmValue),
                     false, IDLoc, Out, STI))
     return true;
 
   TOut.emitRRR(Mips::XOR, DstReg, SrcReg, ATReg, IDLoc, STI);
   TOut.emitRRR(Mips::SLTu, DstReg, Mips::ZERO, DstReg, IDLoc, STI);
   return false;
 }
 
 // Map the DSP accumulator and control register to the corresponding gpr
 // operand. Unlike the other alias, the m(f|t)t(lo|hi|acx) instructions
 // do not map the DSP registers contigously to gpr registers.
 static unsigned getRegisterForMxtrDSP(MCInst &Inst, bool IsMFDSP) {
   switch (Inst.getOpcode()) {
     case Mips::MFTLO:
     case Mips::MTTLO:
       switch (Inst.getOperand(IsMFDSP ? 1 : 0).getReg()) {
         case Mips::AC0:
           return Mips::ZERO;
         case Mips::AC1:
           return Mips::A0;
         case Mips::AC2:
           return Mips::T0;
         case Mips::AC3:
           return Mips::T4;
         default:
           llvm_unreachable("Unknown register for 'mttr' alias!");
     }
     case Mips::MFTHI:
     case Mips::MTTHI:
       switch (Inst.getOperand(IsMFDSP ? 1 : 0).getReg()) {
         case Mips::AC0:
           return Mips::AT;
         case Mips::AC1:
           return Mips::A1;
         case Mips::AC2:
           return Mips::T1;
         case Mips::AC3:
           return Mips::T5;
         default:
           llvm_unreachable("Unknown register for 'mttr' alias!");
     }
     case Mips::MFTACX:
     case Mips::MTTACX:
       switch (Inst.getOperand(IsMFDSP ? 1 : 0).getReg()) {
         case Mips::AC0:
           return Mips::V0;
         case Mips::AC1:
           return Mips::A2;
         case Mips::AC2:
           return Mips::T2;
         case Mips::AC3:
           return Mips::T6;
         default:
           llvm_unreachable("Unknown register for 'mttr' alias!");
     }
     case Mips::MFTDSP:
     case Mips::MTTDSP:
       return Mips::S0;
     default:
       llvm_unreachable("Unknown instruction for 'mttr' dsp alias!");
   }
 }
 
 // Map the floating point register operand to the corresponding register
 // operand.
 static unsigned getRegisterForMxtrFP(MCInst &Inst, bool IsMFTC1) {
   switch (Inst.getOperand(IsMFTC1 ? 1 : 0).getReg()) {
     case Mips::F0:  return Mips::ZERO;
     case Mips::F1:  return Mips::AT;
     case Mips::F2:  return Mips::V0;
     case Mips::F3:  return Mips::V1;
     case Mips::F4:  return Mips::A0;
     case Mips::F5:  return Mips::A1;
     case Mips::F6:  return Mips::A2;
     case Mips::F7:  return Mips::A3;
     case Mips::F8:  return Mips::T0;
     case Mips::F9:  return Mips::T1;
     case Mips::F10: return Mips::T2;
     case Mips::F11: return Mips::T3;
     case Mips::F12: return Mips::T4;
     case Mips::F13: return Mips::T5;
     case Mips::F14: return Mips::T6;
     case Mips::F15: return Mips::T7;
     case Mips::F16: return Mips::S0;
     case Mips::F17: return Mips::S1;
     case Mips::F18: return Mips::S2;
     case Mips::F19: return Mips::S3;
     case Mips::F20: return Mips::S4;
     case Mips::F21: return Mips::S5;
     case Mips::F22: return Mips::S6;
     case Mips::F23: return Mips::S7;
     case Mips::F24: return Mips::T8;
     case Mips::F25: return Mips::T9;
     case Mips::F26: return Mips::K0;
     case Mips::F27: return Mips::K1;
     case Mips::F28: return Mips::GP;
     case Mips::F29: return Mips::SP;
     case Mips::F30: return Mips::FP;
     case Mips::F31: return Mips::RA;
     default: llvm_unreachable("Unknown register for mttc1 alias!");
   }
 }
 
 // Map the coprocessor operand the corresponding gpr register operand.
 static unsigned getRegisterForMxtrC0(MCInst &Inst, bool IsMFTC0) {
   switch (Inst.getOperand(IsMFTC0 ? 1 : 0).getReg()) {
     case Mips::COP00:  return Mips::ZERO;
     case Mips::COP01:  return Mips::AT;
     case Mips::COP02:  return Mips::V0;
     case Mips::COP03:  return Mips::V1;
     case Mips::COP04:  return Mips::A0;
     case Mips::COP05:  return Mips::A1;
     case Mips::COP06:  return Mips::A2;
     case Mips::COP07:  return Mips::A3;
     case Mips::COP08:  return Mips::T0;
     case Mips::COP09:  return Mips::T1;
     case Mips::COP010: return Mips::T2;
     case Mips::COP011: return Mips::T3;
     case Mips::COP012: return Mips::T4;
     case Mips::COP013: return Mips::T5;
     case Mips::COP014: return Mips::T6;
     case Mips::COP015: return Mips::T7;
     case Mips::COP016: return Mips::S0;
     case Mips::COP017: return Mips::S1;
     case Mips::COP018: return Mips::S2;
     case Mips::COP019: return Mips::S3;
     case Mips::COP020: return Mips::S4;
     case Mips::COP021: return Mips::S5;
     case Mips::COP022: return Mips::S6;
     case Mips::COP023: return Mips::S7;
     case Mips::COP024: return Mips::T8;
     case Mips::COP025: return Mips::T9;
     case Mips::COP026: return Mips::K0;
     case Mips::COP027: return Mips::K1;
     case Mips::COP028: return Mips::GP;
     case Mips::COP029: return Mips::SP;
     case Mips::COP030: return Mips::FP;
     case Mips::COP031: return Mips::RA;
     default: llvm_unreachable("Unknown register for mttc0 alias!");
   }
 }
 
 /// Expand an alias of 'mftr' or 'mttr' into the full instruction, by producing
 /// an mftr or mttr with the correctly mapped gpr register, u, sel and h bits.
 bool MipsAsmParser::expandMXTRAlias(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                     const MCSubtargetInfo *STI) {
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned rd = 0;
   unsigned u = 1;
   unsigned sel = 0;
   unsigned h = 0;
   bool IsMFTR = false;
   switch (Inst.getOpcode()) {
     case Mips::MFTC0:
       IsMFTR = true;
       LLVM_FALLTHROUGH;
     case Mips::MTTC0:
       u = 0;
       rd = getRegisterForMxtrC0(Inst, IsMFTR);
       sel = Inst.getOperand(2).getImm();
       break;
     case Mips::MFTGPR:
       IsMFTR = true;
       LLVM_FALLTHROUGH;
     case Mips::MTTGPR:
       rd = Inst.getOperand(IsMFTR ? 1 : 0).getReg();
       break;
     case Mips::MFTLO:
     case Mips::MFTHI:
     case Mips::MFTACX:
     case Mips::MFTDSP:
       IsMFTR = true;
       LLVM_FALLTHROUGH;
     case Mips::MTTLO:
     case Mips::MTTHI:
     case Mips::MTTACX:
     case Mips::MTTDSP:
       rd = getRegisterForMxtrDSP(Inst, IsMFTR);
       sel = 1;
       break;
     case Mips::MFTHC1:
       h = 1;
       LLVM_FALLTHROUGH;
     case Mips::MFTC1:
       IsMFTR = true;
       rd = getRegisterForMxtrFP(Inst, IsMFTR);
       sel = 2;
       break;
     case Mips::MTTHC1:
       h = 1;
       LLVM_FALLTHROUGH;
     case Mips::MTTC1:
       rd = getRegisterForMxtrFP(Inst, IsMFTR);
       sel = 2;
       break;
     case Mips::CFTC1:
       IsMFTR = true;
       LLVM_FALLTHROUGH;
     case Mips::CTTC1:
       rd = getRegisterForMxtrFP(Inst, IsMFTR);
       sel = 3;
       break;
   }
   unsigned Op0 = IsMFTR ? Inst.getOperand(0).getReg() : rd;
   unsigned Op1 =
       IsMFTR ? rd
              : (Inst.getOpcode() != Mips::MTTDSP ? Inst.getOperand(1).getReg()
                                                  : Inst.getOperand(0).getReg());
 
   TOut.emitRRIII(IsMFTR ? Mips::MFTR : Mips::MTTR, Op0, Op1, u, sel, h, IDLoc,
                  STI);
   return false;
 }
 
 bool MipsAsmParser::expandSaaAddr(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out,
                                   const MCSubtargetInfo *STI) {
   assert(Inst.getNumOperands() == 3 && "expected three operands");
   assert(Inst.getOperand(0).isReg() && "expected register operand kind");
   assert(Inst.getOperand(1).isReg() && "expected register operand kind");
 
   warnIfNoMacro(IDLoc);
 
   MipsTargetStreamer &TOut = getTargetStreamer();
   unsigned Opcode = Inst.getOpcode() == Mips::SaaAddr ? Mips::SAA : Mips::SAAD;
   unsigned RtReg = Inst.getOperand(0).getReg();
   unsigned BaseReg = Inst.getOperand(1).getReg();
   const MCOperand &BaseOp = Inst.getOperand(2);
 
   if (BaseOp.isImm()) {
     int64_t ImmValue = BaseOp.getImm();
     if (ImmValue == 0) {
       TOut.emitRR(Opcode, RtReg, BaseReg, IDLoc, STI);
       return false;
     }
   }
 
   unsigned ATReg = getATReg(IDLoc);
   if (!ATReg)
     return true;
 
   if (expandLoadAddress(ATReg, BaseReg, BaseOp, !isGP64bit(), IDLoc, Out, STI))
     return true;
 
   TOut.emitRR(Opcode, RtReg, ATReg, IDLoc, STI);
   return false;
 }
 
 unsigned
 MipsAsmParser::checkEarlyTargetMatchPredicate(MCInst &Inst,
                                               const OperandVector &Operands) {
   switch (Inst.getOpcode()) {
   default:
     return Match_Success;
   case Mips::DATI:
   case Mips::DAHI:
     if (static_cast<MipsOperand &>(*Operands[1])
             .isValidForTie(static_cast<MipsOperand &>(*Operands[2])))
       return Match_Success;
     return Match_RequiresSameSrcAndDst;
   }
 }
 
 unsigned MipsAsmParser::checkTargetMatchPredicate(MCInst &Inst) {
   switch (Inst.getOpcode()) {
   // As described by the MIPSR6 spec, daui must not use the zero operand for
   // its source operand.
   case Mips::DAUI:
     if (Inst.getOperand(1).getReg() == Mips::ZERO ||
         Inst.getOperand(1).getReg() == Mips::ZERO_64)
       return Match_RequiresNoZeroRegister;
     return Match_Success;
   // As described by the Mips32r2 spec, the registers Rd and Rs for
   // jalr.hb must be different.
   // It also applies for registers Rt and Rs of microMIPSr6 jalrc.hb instruction
   // and registers Rd and Base for microMIPS lwp instruction
   case Mips::JALR_HB:
   case Mips::JALR_HB64:
   case Mips::JALRC_HB_MMR6:
   case Mips::JALRC_MMR6:
     if (Inst.getOperand(0).getReg() == Inst.getOperand(1).getReg())
       return Match_RequiresDifferentSrcAndDst;
     return Match_Success;
   case Mips::LWP_MM:
     if (Inst.getOperand(0).getReg() == Inst.getOperand(2).getReg())
       return Match_RequiresDifferentSrcAndDst;
     return Match_Success;
   case Mips::SYNC:
     if (Inst.getOperand(0).getImm() != 0 && !hasMips32())
       return Match_NonZeroOperandForSync;
     return Match_Success;
   case Mips::MFC0:
   case Mips::MTC0:
   case Mips::MTC2:
   case Mips::MFC2:
     if (Inst.getOperand(2).getImm() != 0 && !hasMips32())
       return Match_NonZeroOperandForMTCX;
     return Match_Success;
   // As described the MIPSR6 spec, the compact branches that compare registers
   // must:
   // a) Not use the zero register.
   // b) Not use the same register twice.
   // c) rs < rt for bnec, beqc.
   //    NB: For this case, the encoding will swap the operands as their
   //    ordering doesn't matter. GAS performs this transformation  too.
   //    Hence, that constraint does not have to be enforced.
   //
   // The compact branches that branch iff the signed addition of two registers
   // would overflow must have rs >= rt. That can be handled like beqc/bnec with
   // operand swapping. They do not have restriction of using the zero register.
   case Mips::BLEZC:   case Mips::BLEZC_MMR6:
   case Mips::BGEZC:   case Mips::BGEZC_MMR6:
   case Mips::BGTZC:   case Mips::BGTZC_MMR6:
   case Mips::BLTZC:   case Mips::BLTZC_MMR6:
   case Mips::BEQZC:   case Mips::BEQZC_MMR6:
   case Mips::BNEZC:   case Mips::BNEZC_MMR6:
   case Mips::BLEZC64:
   case Mips::BGEZC64:
   case Mips::BGTZC64:
   case Mips::BLTZC64:
   case Mips::BEQZC64:
   case Mips::BNEZC64:
     if (Inst.getOperand(0).getReg() == Mips::ZERO ||
         Inst.getOperand(0).getReg() == Mips::ZERO_64)
       return Match_RequiresNoZeroRegister;
     return Match_Success;
   case Mips::BGEC:    case Mips::BGEC_MMR6:
   case Mips::BLTC:    case Mips::BLTC_MMR6:
   case Mips::BGEUC:   case Mips::BGEUC_MMR6:
   case Mips::BLTUC:   case Mips::BLTUC_MMR6:
   case Mips::BEQC:    case Mips::BEQC_MMR6:
   case Mips::BNEC:    case Mips::BNEC_MMR6:
   case Mips::BGEC64:
   case Mips::BLTC64:
   case Mips::BGEUC64:
   case Mips::BLTUC64:
   case Mips::BEQC64:
   case Mips::BNEC64:
     if (Inst.getOperand(0).getReg() == Mips::ZERO ||
         Inst.getOperand(0).getReg() == Mips::ZERO_64)
       return Match_RequiresNoZeroRegister;
     if (Inst.getOperand(1).getReg() == Mips::ZERO ||
         Inst.getOperand(1).getReg() == Mips::ZERO_64)
       return Match_RequiresNoZeroRegister;
     if (Inst.getOperand(0).getReg() == Inst.getOperand(1).getReg())
       return Match_RequiresDifferentOperands;
     return Match_Success;
   case Mips::DINS: {
     assert(Inst.getOperand(2).isImm() && Inst.getOperand(3).isImm() &&
            "Operands must be immediates for dins!");
     const signed Pos = Inst.getOperand(2).getImm();
     const signed Size = Inst.getOperand(3).getImm();
     if ((0 > (Pos + Size)) || ((Pos + Size) > 32))
       return Match_RequiresPosSizeRange0_32;
     return Match_Success;
   }
   case Mips::DINSM:
   case Mips::DINSU: {
     assert(Inst.getOperand(2).isImm() && Inst.getOperand(3).isImm() &&
            "Operands must be immediates for dinsm/dinsu!");
     const signed Pos = Inst.getOperand(2).getImm();
     const signed Size = Inst.getOperand(3).getImm();
     if ((32 >= (Pos + Size)) || ((Pos + Size) > 64))
       return Match_RequiresPosSizeRange33_64;
     return Match_Success;
   }
   case Mips::DEXT: {
     assert(Inst.getOperand(2).isImm() && Inst.getOperand(3).isImm() &&
            "Operands must be immediates for DEXTM!");
     const signed Pos = Inst.getOperand(2).getImm();
     const signed Size = Inst.getOperand(3).getImm();
     if ((1 > (Pos + Size)) || ((Pos + Size) > 63))
       return Match_RequiresPosSizeUImm6;
     return Match_Success;
   }
   case Mips::DEXTM:
   case Mips::DEXTU: {
     assert(Inst.getOperand(2).isImm() && Inst.getOperand(3).isImm() &&
            "Operands must be immediates for dextm/dextu!");
     const signed Pos = Inst.getOperand(2).getImm();
     const signed Size = Inst.getOperand(3).getImm();
     if ((32 > (Pos + Size)) || ((Pos + Size) > 64))
       return Match_RequiresPosSizeRange33_64;
     return Match_Success;
   }
   case Mips::CRC32B: case Mips::CRC32CB:
   case Mips::CRC32H: case Mips::CRC32CH:
   case Mips::CRC32W: case Mips::CRC32CW:
   case Mips::CRC32D: case Mips::CRC32CD:
     if (Inst.getOperand(0).getReg() != Inst.getOperand(2).getReg())
       return Match_RequiresSameSrcAndDst;
     return Match_Success;
   }
 
   uint64_t TSFlags = getInstDesc(Inst.getOpcode()).TSFlags;
   if ((TSFlags & MipsII::HasFCCRegOperand) &&
       (Inst.getOperand(0).getReg() != Mips::FCC0) && !hasEightFccRegisters())
     return Match_NoFCCRegisterForCurrentISA;
 
   return Match_Success;
 
 }
 
 static SMLoc RefineErrorLoc(const SMLoc Loc, const OperandVector &Operands,
                             uint64_t ErrorInfo) {
   if (ErrorInfo != ~0ULL && ErrorInfo < Operands.size()) {
     SMLoc ErrorLoc = Operands[ErrorInfo]->getStartLoc();
     if (ErrorLoc == SMLoc())
       return Loc;
     return ErrorLoc;
   }
   return Loc;
 }
 
 bool MipsAsmParser::MatchAndEmitInstruction(SMLoc IDLoc, unsigned &Opcode,
                                             OperandVector &Operands,
                                             MCStreamer &Out,
                                             uint64_t &ErrorInfo,
                                             bool MatchingInlineAsm) {
   MCInst Inst;
   unsigned MatchResult =
       MatchInstructionImpl(Operands, Inst, ErrorInfo, MatchingInlineAsm);
 
   switch (MatchResult) {
   case Match_Success:
     if (processInstruction(Inst, IDLoc, Out, STI))
       return true;
     return false;
   case Match_MissingFeature:
     Error(IDLoc, "instruction requires a CPU feature not currently enabled");
     return true;
   case Match_InvalidOperand: {
     SMLoc ErrorLoc = IDLoc;
     if (ErrorInfo != ~0ULL) {
       if (ErrorInfo >= Operands.size())
         return Error(IDLoc, "too few operands for instruction");
 
       ErrorLoc = Operands[ErrorInfo]->getStartLoc();
       if (ErrorLoc == SMLoc())
         ErrorLoc = IDLoc;
     }
 
     return Error(ErrorLoc, "invalid operand for instruction");
   }
   case Match_NonZeroOperandForSync:
     return Error(IDLoc,
                  "s-type must be zero or unspecified for pre-MIPS32 ISAs");
   case Match_NonZeroOperandForMTCX:
     return Error(IDLoc, "selector must be zero for pre-MIPS32 ISAs");
   case Match_MnemonicFail:
     return Error(IDLoc, "invalid instruction");
   case Match_RequiresDifferentSrcAndDst:
     return Error(IDLoc, "source and destination must be different");
   case Match_RequiresDifferentOperands:
     return Error(IDLoc, "registers must be different");
   case Match_RequiresNoZeroRegister:
     return Error(IDLoc, "invalid operand ($zero) for instruction");
   case Match_RequiresSameSrcAndDst:
     return Error(IDLoc, "source and destination must match");
   case Match_NoFCCRegisterForCurrentISA:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "non-zero fcc register doesn't exist in current ISA level");
   case Match_Immz:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo), "expected '0'");
   case Match_UImm1_0:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 1-bit unsigned immediate");
   case Match_UImm2_0:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 2-bit unsigned immediate");
   case Match_UImm2_1:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected immediate in range 1 .. 4");
   case Match_UImm3_0:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 3-bit unsigned immediate");
   case Match_UImm4_0:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 4-bit unsigned immediate");
   case Match_SImm4_0:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 4-bit signed immediate");
   case Match_UImm5_0:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 5-bit unsigned immediate");
   case Match_SImm5_0:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 5-bit signed immediate");
   case Match_UImm5_1:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected immediate in range 1 .. 32");
   case Match_UImm5_32:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected immediate in range 32 .. 63");
   case Match_UImm5_33:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected immediate in range 33 .. 64");
   case Match_UImm5_0_Report_UImm6:
     // This is used on UImm5 operands that have a corresponding UImm5_32
     // operand to avoid confusing the user.
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 6-bit unsigned immediate");
   case Match_UImm5_Lsl2:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected both 7-bit unsigned immediate and multiple of 4");
   case Match_UImmRange2_64:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected immediate in range 2 .. 64");
   case Match_UImm6_0:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 6-bit unsigned immediate");
   case Match_UImm6_Lsl2:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected both 8-bit unsigned immediate and multiple of 4");
   case Match_SImm6_0:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 6-bit signed immediate");
   case Match_UImm7_0:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 7-bit unsigned immediate");
   case Match_UImm7_N1:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected immediate in range -1 .. 126");
   case Match_SImm7_Lsl2:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected both 9-bit signed immediate and multiple of 4");
   case Match_UImm8_0:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 8-bit unsigned immediate");
   case Match_UImm10_0:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 10-bit unsigned immediate");
   case Match_SImm10_0:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 10-bit signed immediate");
   case Match_SImm11_0:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 11-bit signed immediate");
   case Match_UImm16:
   case Match_UImm16_Relaxed:
   case Match_UImm16_AltRelaxed:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 16-bit unsigned immediate");
   case Match_SImm16:
   case Match_SImm16_Relaxed:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 16-bit signed immediate");
   case Match_SImm19_Lsl2:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected both 19-bit signed immediate and multiple of 4");
   case Match_UImm20_0:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 20-bit unsigned immediate");
   case Match_UImm26_0:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 26-bit unsigned immediate");
   case Match_SImm32:
   case Match_SImm32_Relaxed:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 32-bit signed immediate");
   case Match_UImm32_Coerced:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected 32-bit immediate");
   case Match_MemSImm9:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected memory with 9-bit signed offset");
   case Match_MemSImm10:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected memory with 10-bit signed offset");
   case Match_MemSImm10Lsl1:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected memory with 11-bit signed offset and multiple of 2");
   case Match_MemSImm10Lsl2:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected memory with 12-bit signed offset and multiple of 4");
   case Match_MemSImm10Lsl3:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected memory with 13-bit signed offset and multiple of 8");
   case Match_MemSImm11:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected memory with 11-bit signed offset");
   case Match_MemSImm12:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected memory with 12-bit signed offset");
   case Match_MemSImm16:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected memory with 16-bit signed offset");
   case Match_MemSImmPtr:
     return Error(RefineErrorLoc(IDLoc, Operands, ErrorInfo),
                  "expected memory with 32-bit signed offset");
   case Match_RequiresPosSizeRange0_32: {
     SMLoc ErrorStart = Operands[3]->getStartLoc();
     SMLoc ErrorEnd = Operands[4]->getEndLoc();
     return Error(ErrorStart, "size plus position are not in the range 0 .. 32",
                  SMRange(ErrorStart, ErrorEnd));
     }
   case Match_RequiresPosSizeUImm6: {
     SMLoc ErrorStart = Operands[3]->getStartLoc();
     SMLoc ErrorEnd = Operands[4]->getEndLoc();
     return Error(ErrorStart, "size plus position are not in the range 1 .. 63",
                  SMRange(ErrorStart, ErrorEnd));
     }
   case Match_RequiresPosSizeRange33_64: {
     SMLoc ErrorStart = Operands[3]->getStartLoc();
     SMLoc ErrorEnd = Operands[4]->getEndLoc();
     return Error(ErrorStart, "size plus position are not in the range 33 .. 64",
                  SMRange(ErrorStart, ErrorEnd));
     }
   }
 
   llvm_unreachable("Implement any new match types added!");
 }
 
 void MipsAsmParser::warnIfRegIndexIsAT(unsigned RegIndex, SMLoc Loc) {
   if (RegIndex != 0 && AssemblerOptions.back()->getATRegIndex() == RegIndex)
     Warning(Loc, "used $at (currently $" + Twine(RegIndex) +
                      ") without \".set noat\"");
 }
 
 void MipsAsmParser::warnIfNoMacro(SMLoc Loc) {
   if (!AssemblerOptions.back()->isMacro())
     Warning(Loc, "macro instruction expanded into multiple instructions");
 }
 
 void MipsAsmParser::ConvertXWPOperands(MCInst &Inst,
                                        const OperandVector &Operands) {
   assert(
       (Inst.getOpcode() == Mips::LWP_MM || Inst.getOpcode() == Mips::SWP_MM) &&
       "Unexpected instruction!");
   ((MipsOperand &)*Operands[1]).addGPR32ZeroAsmRegOperands(Inst, 1);
   int NextReg = nextReg(((MipsOperand &)*Operands[1]).getGPR32Reg());
   Inst.addOperand(MCOperand::createReg(NextReg));
   ((MipsOperand &)*Operands[2]).addMemOperands(Inst, 2);
 }
 
 void
 MipsAsmParser::printWarningWithFixIt(const Twine &Msg, const Twine &FixMsg,
                                      SMRange Range, bool ShowColors) {
   getSourceManager().PrintMessage(Range.Start, SourceMgr::DK_Warning, Msg,
                                   Range, SMFixIt(Range, FixMsg),
                                   ShowColors);
 }
 
 int MipsAsmParser::matchCPURegisterName(StringRef Name) {
   int CC;
 
   CC = StringSwitch<unsigned>(Name)
            .Case("zero", 0)
            .Cases("at", "AT", 1)
            .Case("a0", 4)
            .Case("a1", 5)
            .Case("a2", 6)
            .Case("a3", 7)
            .Case("v0", 2)
            .Case("v1", 3)
            .Case("s0", 16)
            .Case("s1", 17)
            .Case("s2", 18)
            .Case("s3", 19)
            .Case("s4", 20)
            .Case("s5", 21)
            .Case("s6", 22)
            .Case("s7", 23)
            .Case("k0", 26)
            .Case("k1", 27)
            .Case("gp", 28)
            .Case("sp", 29)
            .Case("fp", 30)
            .Case("s8", 30)
            .Case("ra", 31)
            .Case("t0", 8)
            .Case("t1", 9)
            .Case("t2", 10)
            .Case("t3", 11)
            .Case("t4", 12)
            .Case("t5", 13)
            .Case("t6", 14)
            .Case("t7", 15)
            .Case("t8", 24)
            .Case("t9", 25)
            .Default(-1);
 
   if (!(isABI_N32() || isABI_N64()))
     return CC;
 
   if (12 <= CC && CC <= 15) {
     // Name is one of t4-t7
     AsmToken RegTok = getLexer().peekTok();
     SMRange RegRange = RegTok.getLocRange();
 
     StringRef FixedName = StringSwitch<StringRef>(Name)
                               .Case("t4", "t0")
                               .Case("t5", "t1")
                               .Case("t6", "t2")
                               .Case("t7", "t3")
                               .Default("");
     assert(FixedName != "" &&  "Register name is not one of t4-t7.");
 
     printWarningWithFixIt("register names $t4-$t7 are only available in O32.",
                           "Did you mean $" + FixedName + "?", RegRange);
   }
 
   // Although SGI documentation just cuts out t0-t3 for n32/n64,
   // GNU pushes the values of t0-t3 to override the o32/o64 values for t4-t7
   // We are supporting both cases, so for t0-t3 we'll just push them to t4-t7.
   if (8 <= CC && CC <= 11)
     CC += 4;
 
   if (CC == -1)
     CC = StringSwitch<unsigned>(Name)
              .Case("a4", 8)
              .Case("a5", 9)
              .Case("a6", 10)
              .Case("a7", 11)
              .Case("kt0", 26)
              .Case("kt1", 27)
              .Default(-1);
 
   return CC;
 }
 
 int MipsAsmParser::matchHWRegsRegisterName(StringRef Name) {
   int CC;
 
   CC = StringSwitch<unsigned>(Name)
             .Case("hwr_cpunum", 0)
             .Case("hwr_synci_step", 1)
             .Case("hwr_cc", 2)
             .Case("hwr_ccres", 3)
             .Case("hwr_ulr", 29)
             .Default(-1);
 
   return CC;
 }
 
 int MipsAsmParser::matchFPURegisterName(StringRef Name) {
   if (Name[0] == 'f') {
     StringRef NumString = Name.substr(1);
     unsigned IntVal;
     if (NumString.getAsInteger(10, IntVal))
       return -1;     // This is not an integer.
     if (IntVal > 31) // Maximum index for fpu register.
       return -1;
     return IntVal;
   }
   return -1;
 }
 
 int MipsAsmParser::matchFCCRegisterName(StringRef Name) {
   if (Name.startswith("fcc")) {
     StringRef NumString = Name.substr(3);
     unsigned IntVal;
     if (NumString.getAsInteger(10, IntVal))
       return -1;    // This is not an integer.
     if (IntVal > 7) // There are only 8 fcc registers.
       return -1;
     return IntVal;
   }
   return -1;
 }
 
 int MipsAsmParser::matchACRegisterName(StringRef Name) {
   if (Name.startswith("ac")) {
     StringRef NumString = Name.substr(2);
     unsigned IntVal;
     if (NumString.getAsInteger(10, IntVal))
       return -1;    // This is not an integer.
     if (IntVal > 3) // There are only 3 acc registers.
       return -1;
     return IntVal;
   }
   return -1;
 }
 
 int MipsAsmParser::matchMSA128RegisterName(StringRef Name) {
   unsigned IntVal;
 
   if (Name.front() != 'w' || Name.drop_front(1).getAsInteger(10, IntVal))
     return -1;
 
   if (IntVal > 31)
     return -1;
 
   return IntVal;
 }
 
 int MipsAsmParser::matchMSA128CtrlRegisterName(StringRef Name) {
   int CC;
 
   CC = StringSwitch<unsigned>(Name)
            .Case("msair", 0)
            .Case("msacsr", 1)
            .Case("msaaccess", 2)
            .Case("msasave", 3)
            .Case("msamodify", 4)
            .Case("msarequest", 5)
            .Case("msamap", 6)
            .Case("msaunmap", 7)
            .Default(-1);
 
   return CC;
 }
 
 bool MipsAsmParser::canUseATReg() {
   return AssemblerOptions.back()->getATRegIndex() != 0;
 }
 
 unsigned MipsAsmParser::getATReg(SMLoc Loc) {
   unsigned ATIndex = AssemblerOptions.back()->getATRegIndex();
   if (ATIndex == 0) {
     reportParseError(Loc,
                      "pseudo-instruction requires $at, which is not available");
     return 0;
   }
   unsigned AT = getReg(
       (isGP64bit()) ? Mips::GPR64RegClassID : Mips::GPR32RegClassID, ATIndex);
   return AT;
 }
 
 unsigned MipsAsmParser::getReg(int RC, int RegNo) {
   return *(getContext().getRegisterInfo()->getRegClass(RC).begin() + RegNo);
 }
 
 bool MipsAsmParser::parseOperand(OperandVector &Operands, StringRef Mnemonic) {
   MCAsmParser &Parser = getParser();
   LLVM_DEBUG(dbgs() << "parseOperand\n");
 
   // Check if the current operand has a custom associated parser, if so, try to
   // custom parse the operand, or fallback to the general approach.
   OperandMatchResultTy ResTy = MatchOperandParserImpl(Operands, Mnemonic);
   if (ResTy == MatchOperand_Success)
     return false;
   // If there wasn't a custom match, try the generic matcher below. Otherwise,
   // there was a match, but an error occurred, in which case, just return that
   // the operand parsing failed.
   if (ResTy == MatchOperand_ParseFail)
     return true;
 
   LLVM_DEBUG(dbgs() << ".. Generic Parser\n");
 
   switch (getLexer().getKind()) {
   case AsmToken::Dollar: {
     // Parse the register.
     SMLoc S = Parser.getTok().getLoc();
 
     // Almost all registers have been parsed by custom parsers. There is only
     // one exception to this. $zero (and it's alias $0) will reach this point
     // for div, divu, and similar instructions because it is not an operand
     // to the instruction definition but an explicit register. Special case
     // this situation for now.
     if (parseAnyRegister(Operands) != MatchOperand_NoMatch)
       return false;
 
     // Maybe it is a symbol reference.
     StringRef Identifier;
     if (Parser.parseIdentifier(Identifier))
       return true;
 
     SMLoc E = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);
     MCSymbol *Sym = getContext().getOrCreateSymbol("$" + Identifier);
     // Otherwise create a symbol reference.
     const MCExpr *Res =
         MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, getContext());
 
     Operands.push_back(MipsOperand::CreateImm(Res, S, E, *this));
     return false;
   }
   default: {
     LLVM_DEBUG(dbgs() << ".. generic integer expression\n");
 
     const MCExpr *Expr;
     SMLoc S = Parser.getTok().getLoc(); // Start location of the operand.
     if (getParser().parseExpression(Expr))
       return true;
 
     SMLoc E = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);
 
     Operands.push_back(MipsOperand::CreateImm(Expr, S, E, *this));
     return false;
   }
   } // switch(getLexer().getKind())
   return true;
 }
 
 bool MipsAsmParser::ParseRegister(unsigned &RegNo, SMLoc &StartLoc,
                                   SMLoc &EndLoc) {
   return tryParseRegister(RegNo, StartLoc, EndLoc) != MatchOperand_Success;
 }
 
 OperandMatchResultTy MipsAsmParser::tryParseRegister(unsigned &RegNo,
                                                      SMLoc &StartLoc,
                                                      SMLoc &EndLoc) {
   SmallVector<std::unique_ptr<MCParsedAsmOperand>, 1> Operands;
   OperandMatchResultTy ResTy = parseAnyRegister(Operands);
   if (ResTy == MatchOperand_Success) {
     assert(Operands.size() == 1);
     MipsOperand &Operand = static_cast<MipsOperand &>(*Operands.front());
     StartLoc = Operand.getStartLoc();
     EndLoc = Operand.getEndLoc();
 
     // AFAIK, we only support numeric registers and named GPR's in CFI
     // directives.
     // Don't worry about eating tokens before failing. Using an unrecognised
     // register is a parse error.
     if (Operand.isGPRAsmReg()) {
       // Resolve to GPR32 or GPR64 appropriately.
       RegNo = isGP64bit() ? Operand.getGPR64Reg() : Operand.getGPR32Reg();
     }
 
     return (RegNo == (unsigned)-1) ? MatchOperand_NoMatch
                                    : MatchOperand_Success;
   }
 
   assert(Operands.size() == 0);
   return (RegNo == (unsigned)-1) ? MatchOperand_NoMatch : MatchOperand_Success;
 }
 
 bool MipsAsmParser::parseMemOffset(const MCExpr *&Res, bool isParenExpr) {
   SMLoc S;
 
   if (isParenExpr)
     return getParser().parseParenExprOfDepth(0, Res, S);
   return getParser().parseExpression(Res);
 }
 
 OperandMatchResultTy
 MipsAsmParser::parseMemOperand(OperandVector &Operands) {
   MCAsmParser &Parser = getParser();
   LLVM_DEBUG(dbgs() << "parseMemOperand\n");
   const MCExpr *IdVal = nullptr;
   SMLoc S;
   bool isParenExpr = false;
   OperandMatchResultTy Res = MatchOperand_NoMatch;
   // First operand is the offset.
   S = Parser.getTok().getLoc();
 
   if (getLexer().getKind() == AsmToken::LParen) {
     Parser.Lex();
     isParenExpr = true;
   }
 
   if (getLexer().getKind() != AsmToken::Dollar) {
     if (parseMemOffset(IdVal, isParenExpr))
       return MatchOperand_ParseFail;
 
     const AsmToken &Tok = Parser.getTok(); // Get the next token.
     if (Tok.isNot(AsmToken::LParen)) {
       MipsOperand &Mnemonic = static_cast<MipsOperand &>(*Operands[0]);
       if (Mnemonic.getToken() == "la" || Mnemonic.getToken() == "dla") {
         SMLoc E =
             SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);
         Operands.push_back(MipsOperand::CreateImm(IdVal, S, E, *this));
         return MatchOperand_Success;
       }
       if (Tok.is(AsmToken::EndOfStatement)) {
         SMLoc E =
             SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);
 
         // Zero register assumed, add a memory operand with ZERO as its base.
         // "Base" will be managed by k_Memory.
         auto Base = MipsOperand::createGPRReg(
             0, "0", getContext().getRegisterInfo(), S, E, *this);
         Operands.push_back(
             MipsOperand::CreateMem(std::move(Base), IdVal, S, E, *this));
         return MatchOperand_Success;
       }
       MCBinaryExpr::Opcode Opcode;
       // GAS and LLVM treat comparison operators different. GAS will generate -1
       // or 0, while LLVM will generate 0 or 1. Since a comparsion operator is
       // highly unlikely to be found in a memory offset expression, we don't
       // handle them.
       switch (Tok.getKind()) {
       case AsmToken::Plus:
         Opcode = MCBinaryExpr::Add;
         Parser.Lex();
         break;
       case AsmToken::Minus:
         Opcode = MCBinaryExpr::Sub;
         Parser.Lex();
         break;
       case AsmToken::Star:
         Opcode = MCBinaryExpr::Mul;
         Parser.Lex();
         break;
       case AsmToken::Pipe:
         Opcode = MCBinaryExpr::Or;
         Parser.Lex();
         break;
       case AsmToken::Amp:
         Opcode = MCBinaryExpr::And;
         Parser.Lex();
         break;
       case AsmToken::LessLess:
         Opcode = MCBinaryExpr::Shl;
         Parser.Lex();
         break;
       case AsmToken::GreaterGreater:
         Opcode = MCBinaryExpr::LShr;
         Parser.Lex();
         break;
       case AsmToken::Caret:
         Opcode = MCBinaryExpr::Xor;
         Parser.Lex();
         break;
       case AsmToken::Slash:
         Opcode = MCBinaryExpr::Div;
         Parser.Lex();
         break;
       case AsmToken::Percent:
         Opcode = MCBinaryExpr::Mod;
         Parser.Lex();
         break;
       default:
         Error(Parser.getTok().getLoc(), "'(' or expression expected");
         return MatchOperand_ParseFail;
       }
       const MCExpr * NextExpr;
       if (getParser().parseExpression(NextExpr))
         return MatchOperand_ParseFail;
       IdVal = MCBinaryExpr::create(Opcode, IdVal, NextExpr, getContext());
     }
 
     Parser.Lex(); // Eat the '(' token.
   }
 
   Res = parseAnyRegister(Operands);
   if (Res != MatchOperand_Success)
     return Res;
 
   if (Parser.getTok().isNot(AsmToken::RParen)) {
     Error(Parser.getTok().getLoc(), "')' expected");
     return MatchOperand_ParseFail;
   }
 
   SMLoc E = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);
 
   Parser.Lex(); // Eat the ')' token.
 
   if (!IdVal)
     IdVal = MCConstantExpr::create(0, getContext());
 
   // Replace the register operand with the memory operand.
   std::unique_ptr<MipsOperand> op(
       static_cast<MipsOperand *>(Operands.back().release()));
   // Remove the register from the operands.
   // "op" will be managed by k_Memory.
   Operands.pop_back();
   // Add the memory operand.
   if (const MCBinaryExpr *BE = dyn_cast<MCBinaryExpr>(IdVal)) {
     int64_t Imm;
     if (IdVal->evaluateAsAbsolute(Imm))
       IdVal = MCConstantExpr::create(Imm, getContext());
     else if (BE->getLHS()->getKind() != MCExpr::SymbolRef)
       IdVal = MCBinaryExpr::create(BE->getOpcode(), BE->getRHS(), BE->getLHS(),
                                    getContext());
   }
 
   Operands.push_back(MipsOperand::CreateMem(std::move(op), IdVal, S, E, *this));
   return MatchOperand_Success;
 }
 
 bool MipsAsmParser::searchSymbolAlias(OperandVector &Operands) {
   MCAsmParser &Parser = getParser();
   MCSymbol *Sym = getContext().lookupSymbol(Parser.getTok().getIdentifier());
   if (!Sym)
     return false;
 
   SMLoc S = Parser.getTok().getLoc();
   if (Sym->isVariable()) {
     const MCExpr *Expr = Sym->getVariableValue();
     if (Expr->getKind() == MCExpr::SymbolRef) {
       const MCSymbolRefExpr *Ref = static_cast<const MCSymbolRefExpr *>(Expr);
       StringRef DefSymbol = Ref->getSymbol().getName();
       if (DefSymbol.startswith("$")) {
         OperandMatchResultTy ResTy =
             matchAnyRegisterNameWithoutDollar(Operands, DefSymbol.substr(1), S);
         if (ResTy == MatchOperand_Success) {
           Parser.Lex();
           return true;
         }
         if (ResTy == MatchOperand_ParseFail)
           llvm_unreachable("Should never ParseFail");
       }
     }
   } else if (Sym->isUnset()) {
     // If symbol is unset, it might be created in the `parseSetAssignment`
     // routine as an alias for a numeric register name.
     // Lookup in the aliases list.
     auto Entry = RegisterSets.find(Sym->getName());
     if (Entry != RegisterSets.end()) {
       OperandMatchResultTy ResTy =
           matchAnyRegisterWithoutDollar(Operands, Entry->getValue(), S);
       if (ResTy == MatchOperand_Success) {
         Parser.Lex();
         return true;
       }
     }
   }
 
   return false;
 }
 
 OperandMatchResultTy
 MipsAsmParser::matchAnyRegisterNameWithoutDollar(OperandVector &Operands,
                                                  StringRef Identifier,
                                                  SMLoc S) {
   int Index = matchCPURegisterName(Identifier);
   if (Index != -1) {
     Operands.push_back(MipsOperand::createGPRReg(
         Index, Identifier, getContext().getRegisterInfo(), S,
         getLexer().getLoc(), *this));
     return MatchOperand_Success;
   }
 
   Index = matchHWRegsRegisterName(Identifier);
   if (Index != -1) {
     Operands.push_back(MipsOperand::createHWRegsReg(
         Index, Identifier, getContext().getRegisterInfo(), S,
         getLexer().getLoc(), *this));
     return MatchOperand_Success;
   }
 
   Index = matchFPURegisterName(Identifier);
   if (Index != -1) {
     Operands.push_back(MipsOperand::createFGRReg(
         Index, Identifier, getContext().getRegisterInfo(), S,
         getLexer().getLoc(), *this));
     return MatchOperand_Success;
   }
 
   Index = matchFCCRegisterName(Identifier);
   if (Index != -1) {
     Operands.push_back(MipsOperand::createFCCReg(
         Index, Identifier, getContext().getRegisterInfo(), S,
         getLexer().getLoc(), *this));
     return MatchOperand_Success;
   }
 
   Index = matchACRegisterName(Identifier);
   if (Index != -1) {
     Operands.push_back(MipsOperand::createACCReg(
         Index, Identifier, getContext().getRegisterInfo(), S,
         getLexer().getLoc(), *this));
     return MatchOperand_Success;
   }
 
   Index = matchMSA128RegisterName(Identifier);
   if (Index != -1) {
     Operands.push_back(MipsOperand::createMSA128Reg(
         Index, Identifier, getContext().getRegisterInfo(), S,
         getLexer().getLoc(), *this));
     return MatchOperand_Success;
   }
 
   Index = matchMSA128CtrlRegisterName(Identifier);
   if (Index != -1) {
     Operands.push_back(MipsOperand::createMSACtrlReg(
         Index, Identifier, getContext().getRegisterInfo(), S,
         getLexer().getLoc(), *this));
     return MatchOperand_Success;
   }
 
   return MatchOperand_NoMatch;
 }
 
 OperandMatchResultTy
 MipsAsmParser::matchAnyRegisterWithoutDollar(OperandVector &Operands,
                                              const AsmToken &Token, SMLoc S) {
   if (Token.is(AsmToken::Identifier)) {
     LLVM_DEBUG(dbgs() << ".. identifier\n");
     StringRef Identifier = Token.getIdentifier();
     OperandMatchResultTy ResTy =
         matchAnyRegisterNameWithoutDollar(Operands, Identifier, S);
     return ResTy;
   } else if (Token.is(AsmToken::Integer)) {
     LLVM_DEBUG(dbgs() << ".. integer\n");
     int64_t RegNum = Token.getIntVal();
     if (RegNum < 0 || RegNum > 31) {
       // Show the error, but treat invalid register
       // number as a normal one to continue parsing
       // and catch other possible errors.
       Error(getLexer().getLoc(), "invalid register number");
     }
     Operands.push_back(MipsOperand::createNumericReg(
         RegNum, Token.getString(), getContext().getRegisterInfo(), S,
         Token.getLoc(), *this));
     return MatchOperand_Success;
   }
 
   LLVM_DEBUG(dbgs() << Token.getKind() << "\n");
 
   return MatchOperand_NoMatch;
 }
 
 OperandMatchResultTy
 MipsAsmParser::matchAnyRegisterWithoutDollar(OperandVector &Operands, SMLoc S) {
   auto Token = getLexer().peekTok(false);
   return matchAnyRegisterWithoutDollar(Operands, Token, S);
 }
 
 OperandMatchResultTy
 MipsAsmParser::parseAnyRegister(OperandVector &Operands) {
   MCAsmParser &Parser = getParser();
   LLVM_DEBUG(dbgs() << "parseAnyRegister\n");
 
   auto Token = Parser.getTok();
 
   SMLoc S = Token.getLoc();
 
   if (Token.isNot(AsmToken::Dollar)) {
     LLVM_DEBUG(dbgs() << ".. !$ -> try sym aliasing\n");
     if (Token.is(AsmToken::Identifier)) {
       if (searchSymbolAlias(Operands))
         return MatchOperand_Success;
     }
     LLVM_DEBUG(dbgs() << ".. !symalias -> NoMatch\n");
     return MatchOperand_NoMatch;
   }
   LLVM_DEBUG(dbgs() << ".. $\n");
 
   OperandMatchResultTy ResTy = matchAnyRegisterWithoutDollar(Operands, S);
   if (ResTy == MatchOperand_Success) {
     Parser.Lex(); // $
     Parser.Lex(); // identifier
   }
   return ResTy;
 }
 
 OperandMatchResultTy
 MipsAsmParser::parseJumpTarget(OperandVector &Operands) {
   MCAsmParser &Parser = getParser();
   LLVM_DEBUG(dbgs() << "parseJumpTarget\n");
 
   SMLoc S = getLexer().getLoc();
 
   // Registers are a valid target and have priority over symbols.
   OperandMatchResultTy ResTy = parseAnyRegister(Operands);
   if (ResTy != MatchOperand_NoMatch)
     return ResTy;
 
   // Integers and expressions are acceptable
   const MCExpr *Expr = nullptr;
   if (Parser.parseExpression(Expr)) {
     // We have no way of knowing if a symbol was consumed so we must ParseFail
     return MatchOperand_ParseFail;
   }
   Operands.push_back(
       MipsOperand::CreateImm(Expr, S, getLexer().getLoc(), *this));
   return MatchOperand_Success;
 }
 
 OperandMatchResultTy
 MipsAsmParser::parseInvNum(OperandVector &Operands) {
   MCAsmParser &Parser = getParser();
   const MCExpr *IdVal;
   // If the first token is '$' we may have register operand. We have to reject
   // cases where it is not a register. Complicating the matter is that
   // register names are not reserved across all ABIs.
   // Peek past the dollar to see if it's a register name for this ABI.
   SMLoc S = Parser.getTok().getLoc();
   if (Parser.getTok().is(AsmToken::Dollar)) {
     return matchCPURegisterName(Parser.getLexer().peekTok().getString()) == -1
                ? MatchOperand_ParseFail
                : MatchOperand_NoMatch;
   }
   if (getParser().parseExpression(IdVal))
     return MatchOperand_ParseFail;
   const MCConstantExpr *MCE = dyn_cast<MCConstantExpr>(IdVal);
   if (!MCE)
     return MatchOperand_NoMatch;
   int64_t Val = MCE->getValue();
   SMLoc E = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);
   Operands.push_back(MipsOperand::CreateImm(
       MCConstantExpr::create(0 - Val, getContext()), S, E, *this));
   return MatchOperand_Success;
 }
 
 OperandMatchResultTy
 MipsAsmParser::parseRegisterList(OperandVector &Operands) {
   MCAsmParser &Parser = getParser();
   SmallVector<unsigned, 10> Regs;
   unsigned RegNo;
   unsigned PrevReg = Mips::NoRegister;
   bool RegRange = false;
   SmallVector<std::unique_ptr<MCParsedAsmOperand>, 8> TmpOperands;
 
   if (Parser.getTok().isNot(AsmToken::Dollar))
     return MatchOperand_ParseFail;
 
   SMLoc S = Parser.getTok().getLoc();
   while (parseAnyRegister(TmpOperands) == MatchOperand_Success) {
     SMLoc E = getLexer().getLoc();
     MipsOperand &Reg = static_cast<MipsOperand &>(*TmpOperands.back());
     RegNo = isGP64bit() ? Reg.getGPR64Reg() : Reg.getGPR32Reg();
     if (RegRange) {
       // Remove last register operand because registers from register range
       // should be inserted first.
       if ((isGP64bit() && RegNo == Mips::RA_64) ||
           (!isGP64bit() && RegNo == Mips::RA)) {
         Regs.push_back(RegNo);
       } else {
         unsigned TmpReg = PrevReg + 1;
         while (TmpReg <= RegNo) {
           if ((((TmpReg < Mips::S0) || (TmpReg > Mips::S7)) && !isGP64bit()) ||
               (((TmpReg < Mips::S0_64) || (TmpReg > Mips::S7_64)) &&
                isGP64bit())) {
             Error(E, "invalid register operand");
             return MatchOperand_ParseFail;
           }
 
           PrevReg = TmpReg;
           Regs.push_back(TmpReg++);
         }
       }
 
       RegRange = false;
     } else {
       if ((PrevReg == Mips::NoRegister) &&
           ((isGP64bit() && (RegNo != Mips::S0_64) && (RegNo != Mips::RA_64)) ||
           (!isGP64bit() && (RegNo != Mips::S0) && (RegNo != Mips::RA)))) {
         Error(E, "$16 or $31 expected");
         return MatchOperand_ParseFail;
       } else if (!(((RegNo == Mips::FP || RegNo == Mips::RA ||
                     (RegNo >= Mips::S0 && RegNo <= Mips::S7)) &&
                     !isGP64bit()) ||
                    ((RegNo == Mips::FP_64 || RegNo == Mips::RA_64 ||
                     (RegNo >= Mips::S0_64 && RegNo <= Mips::S7_64)) &&
                     isGP64bit()))) {
         Error(E, "invalid register operand");
         return MatchOperand_ParseFail;
       } else if ((PrevReg != Mips::NoRegister) && (RegNo != PrevReg + 1) &&
                  ((RegNo != Mips::FP && RegNo != Mips::RA && !isGP64bit()) ||
                   (RegNo != Mips::FP_64 && RegNo != Mips::RA_64 &&
                    isGP64bit()))) {
         Error(E, "consecutive register numbers expected");
         return MatchOperand_ParseFail;
       }
 
       Regs.push_back(RegNo);
     }
 
     if (Parser.getTok().is(AsmToken::Minus))
       RegRange = true;
 
     if (!Parser.getTok().isNot(AsmToken::Minus) &&
         !Parser.getTok().isNot(AsmToken::Comma)) {
       Error(E, "',' or '-' expected");
       return MatchOperand_ParseFail;
     }
 
     Lex(); // Consume comma or minus
     if (Parser.getTok().isNot(AsmToken::Dollar))
       break;
 
     PrevReg = RegNo;
   }
 
   SMLoc E = Parser.getTok().getLoc();
   Operands.push_back(MipsOperand::CreateRegList(Regs, S, E, *this));
   parseMemOperand(Operands);
   return MatchOperand_Success;
 }
 
 /// Sometimes (i.e. load/stores) the operand may be followed immediately by
 /// either this.
 /// ::= '(', register, ')'
 /// handle it before we iterate so we don't get tripped up by the lack of
 /// a comma.
 bool MipsAsmParser::parseParenSuffix(StringRef Name, OperandVector &Operands) {
   MCAsmParser &Parser = getParser();
   if (getLexer().is(AsmToken::LParen)) {
     Operands.push_back(
         MipsOperand::CreateToken("(", getLexer().getLoc(), *this));
     Parser.Lex();
     if (parseOperand(Operands, Name)) {
       SMLoc Loc = getLexer().getLoc();
       return Error(Loc, "unexpected token in argument list");
     }
     if (Parser.getTok().isNot(AsmToken::RParen)) {
       SMLoc Loc = getLexer().getLoc();
       return Error(Loc, "unexpected token, expected ')'");
     }
     Operands.push_back(
         MipsOperand::CreateToken(")", getLexer().getLoc(), *this));
     Parser.Lex();
   }
   return false;
 }
 
 /// Sometimes (i.e. in MSA) the operand may be followed immediately by
 /// either one of these.
 /// ::= '[', register, ']'
 /// ::= '[', integer, ']'
 /// handle it before we iterate so we don't get tripped up by the lack of
 /// a comma.
 bool MipsAsmParser::parseBracketSuffix(StringRef Name,
                                        OperandVector &Operands) {
   MCAsmParser &Parser = getParser();
   if (getLexer().is(AsmToken::LBrac)) {
     Operands.push_back(
         MipsOperand::CreateToken("[", getLexer().getLoc(), *this));
     Parser.Lex();
     if (parseOperand(Operands, Name)) {
       SMLoc Loc = getLexer().getLoc();
       return Error(Loc, "unexpected token in argument list");
     }
     if (Parser.getTok().isNot(AsmToken::RBrac)) {
       SMLoc Loc = getLexer().getLoc();
       return Error(Loc, "unexpected token, expected ']'");
     }
     Operands.push_back(
         MipsOperand::CreateToken("]", getLexer().getLoc(), *this));
     Parser.Lex();
   }
   return false;
 }
 
 static std::string MipsMnemonicSpellCheck(StringRef S, const FeatureBitset &FBS,
                                           unsigned VariantID = 0);
 
 bool MipsAsmParser::ParseInstruction(ParseInstructionInfo &Info, StringRef Name,
                                      SMLoc NameLoc, OperandVector &Operands) {
   MCAsmParser &Parser = getParser();
   LLVM_DEBUG(dbgs() << "ParseInstruction\n");
 
   // We have reached first instruction, module directive are now forbidden.
   getTargetStreamer().forbidModuleDirective();
 
   // Check if we have valid mnemonic
   if (!mnemonicIsValid(Name, 0)) {
     FeatureBitset FBS = ComputeAvailableFeatures(getSTI().getFeatureBits());
     std::string Suggestion = MipsMnemonicSpellCheck(Name, FBS);
     return Error(NameLoc, "unknown instruction" + Suggestion);
   }
   // First operand in MCInst is instruction mnemonic.
   Operands.push_back(MipsOperand::CreateToken(Name, NameLoc, *this));
 
   // Read the remaining operands.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     // Read the first operand.
     if (parseOperand(Operands, Name)) {
       SMLoc Loc = getLexer().getLoc();
       return Error(Loc, "unexpected token in argument list");
     }
     if (getLexer().is(AsmToken::LBrac) && parseBracketSuffix(Name, Operands))
       return true;
     // AFAIK, parenthesis suffixes are never on the first operand
 
     while (getLexer().is(AsmToken::Comma)) {
       Parser.Lex(); // Eat the comma.
       // Parse and remember the operand.
       if (parseOperand(Operands, Name)) {
         SMLoc Loc = getLexer().getLoc();
         return Error(Loc, "unexpected token in argument list");
       }
       // Parse bracket and parenthesis suffixes before we iterate
       if (getLexer().is(AsmToken::LBrac)) {
         if (parseBracketSuffix(Name, Operands))
           return true;
       } else if (getLexer().is(AsmToken::LParen) &&
                  parseParenSuffix(Name, Operands))
         return true;
     }
   }
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     SMLoc Loc = getLexer().getLoc();
     return Error(Loc, "unexpected token in argument list");
   }
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 // FIXME: Given that these have the same name, these should both be
 // consistent on affecting the Parser.
 bool MipsAsmParser::reportParseError(const Twine &ErrorMsg) {
   SMLoc Loc = getLexer().getLoc();
   return Error(Loc, ErrorMsg);
 }
 
 bool MipsAsmParser::reportParseError(SMLoc Loc, const Twine &ErrorMsg) {
   return Error(Loc, ErrorMsg);
 }
 
 bool MipsAsmParser::parseSetNoAtDirective() {
   MCAsmParser &Parser = getParser();
   // Line should look like: ".set noat".
 
   // Set the $at register to $0.
   AssemblerOptions.back()->setATRegIndex(0);
 
   Parser.Lex(); // Eat "noat".
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   getTargetStreamer().emitDirectiveSetNoAt();
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 bool MipsAsmParser::parseSetAtDirective() {
   // Line can be: ".set at", which sets $at to $1
   //          or  ".set at=$reg", which sets $at to $reg.
   MCAsmParser &Parser = getParser();
   Parser.Lex(); // Eat "at".
 
   if (getLexer().is(AsmToken::EndOfStatement)) {
     // No register was specified, so we set $at to $1.
     AssemblerOptions.back()->setATRegIndex(1);
 
     getTargetStreamer().emitDirectiveSetAt();
     Parser.Lex(); // Consume the EndOfStatement.
     return false;
   }
 
   if (getLexer().isNot(AsmToken::Equal)) {
     reportParseError("unexpected token, expected equals sign");
     return false;
   }
   Parser.Lex(); // Eat "=".
 
   if (getLexer().isNot(AsmToken::Dollar)) {
     if (getLexer().is(AsmToken::EndOfStatement)) {
       reportParseError("no register specified");
       return false;
     } else {
       reportParseError("unexpected token, expected dollar sign '$'");
       return false;
     }
   }
   Parser.Lex(); // Eat "$".
 
   // Find out what "reg" is.
   unsigned AtRegNo;
   const AsmToken &Reg = Parser.getTok();
   if (Reg.is(AsmToken::Identifier)) {
     AtRegNo = matchCPURegisterName(Reg.getIdentifier());
   } else if (Reg.is(AsmToken::Integer)) {
     AtRegNo = Reg.getIntVal();
   } else {
     reportParseError("unexpected token, expected identifier or integer");
     return false;
   }
 
   // Check if $reg is a valid register. If it is, set $at to $reg.
   if (!AssemblerOptions.back()->setATRegIndex(AtRegNo)) {
     reportParseError("invalid register");
     return false;
   }
   Parser.Lex(); // Eat "reg".
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   getTargetStreamer().emitDirectiveSetAtWithArg(AtRegNo);
 
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 bool MipsAsmParser::parseSetReorderDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex();
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
   AssemblerOptions.back()->setReorder();
   getTargetStreamer().emitDirectiveSetReorder();
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 bool MipsAsmParser::parseSetNoReorderDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex();
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
   AssemblerOptions.back()->setNoReorder();
   getTargetStreamer().emitDirectiveSetNoReorder();
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 bool MipsAsmParser::parseSetMacroDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex();
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
   AssemblerOptions.back()->setMacro();
   getTargetStreamer().emitDirectiveSetMacro();
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 bool MipsAsmParser::parseSetNoMacroDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex();
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
   if (AssemblerOptions.back()->isReorder()) {
     reportParseError("`noreorder' must be set before `nomacro'");
     return false;
   }
   AssemblerOptions.back()->setNoMacro();
   getTargetStreamer().emitDirectiveSetNoMacro();
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 bool MipsAsmParser::parseSetMsaDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex();
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement))
     return reportParseError("unexpected token, expected end of statement");
 
   setFeatureBits(Mips::FeatureMSA, "msa");
   getTargetStreamer().emitDirectiveSetMsa();
   return false;
 }
 
 bool MipsAsmParser::parseSetNoMsaDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex();
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement))
     return reportParseError("unexpected token, expected end of statement");
 
   clearFeatureBits(Mips::FeatureMSA, "msa");
   getTargetStreamer().emitDirectiveSetNoMsa();
   return false;
 }
 
 bool MipsAsmParser::parseSetNoDspDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex(); // Eat "nodsp".
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   clearFeatureBits(Mips::FeatureDSP, "dsp");
   getTargetStreamer().emitDirectiveSetNoDsp();
   return false;
 }
 
 bool MipsAsmParser::parseSetNoMips3DDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex(); // Eat "nomips3d".
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   clearFeatureBits(Mips::FeatureMips3D, "mips3d");
   getTargetStreamer().emitDirectiveSetNoMips3D();
   return false;
 }
 
 bool MipsAsmParser::parseSetMips16Directive() {
   MCAsmParser &Parser = getParser();
   Parser.Lex(); // Eat "mips16".
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   setFeatureBits(Mips::FeatureMips16, "mips16");
   getTargetStreamer().emitDirectiveSetMips16();
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 bool MipsAsmParser::parseSetNoMips16Directive() {
   MCAsmParser &Parser = getParser();
   Parser.Lex(); // Eat "nomips16".
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   clearFeatureBits(Mips::FeatureMips16, "mips16");
   getTargetStreamer().emitDirectiveSetNoMips16();
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 bool MipsAsmParser::parseSetFpDirective() {
   MCAsmParser &Parser = getParser();
   MipsABIFlagsSection::FpABIKind FpAbiVal;
   // Line can be: .set fp=32
   //              .set fp=xx
   //              .set fp=64
   Parser.Lex(); // Eat fp token
   AsmToken Tok = Parser.getTok();
   if (Tok.isNot(AsmToken::Equal)) {
     reportParseError("unexpected token, expected equals sign '='");
     return false;
   }
   Parser.Lex(); // Eat '=' token.
   Tok = Parser.getTok();
 
   if (!parseFpABIValue(FpAbiVal, ".set"))
     return false;
 
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
   getTargetStreamer().emitDirectiveSetFp(FpAbiVal);
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 bool MipsAsmParser::parseSetOddSPRegDirective() {
   MCAsmParser &Parser = getParser();
 
   Parser.Lex(); // Eat "oddspreg".
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   clearFeatureBits(Mips::FeatureNoOddSPReg, "nooddspreg");
   getTargetStreamer().emitDirectiveSetOddSPReg();
   return false;
 }
 
 bool MipsAsmParser::parseSetNoOddSPRegDirective() {
   MCAsmParser &Parser = getParser();
 
   Parser.Lex(); // Eat "nooddspreg".
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   setFeatureBits(Mips::FeatureNoOddSPReg, "nooddspreg");
   getTargetStreamer().emitDirectiveSetNoOddSPReg();
   return false;
 }
 
 bool MipsAsmParser::parseSetMtDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex(); // Eat "mt".
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   setFeatureBits(Mips::FeatureMT, "mt");
   getTargetStreamer().emitDirectiveSetMt();
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 bool MipsAsmParser::parseSetNoMtDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex(); // Eat "nomt".
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   clearFeatureBits(Mips::FeatureMT, "mt");
 
   getTargetStreamer().emitDirectiveSetNoMt();
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 bool MipsAsmParser::parseSetNoCRCDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex(); // Eat "nocrc".
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   clearFeatureBits(Mips::FeatureCRC, "crc");
 
   getTargetStreamer().emitDirectiveSetNoCRC();
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 bool MipsAsmParser::parseSetNoVirtDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex(); // Eat "novirt".
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   clearFeatureBits(Mips::FeatureVirt, "virt");
 
   getTargetStreamer().emitDirectiveSetNoVirt();
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 bool MipsAsmParser::parseSetNoGINVDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex(); // Eat "noginv".
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   clearFeatureBits(Mips::FeatureGINV, "ginv");
 
   getTargetStreamer().emitDirectiveSetNoGINV();
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 bool MipsAsmParser::parseSetPopDirective() {
   MCAsmParser &Parser = getParser();
   SMLoc Loc = getLexer().getLoc();
 
   Parser.Lex();
   if (getLexer().isNot(AsmToken::EndOfStatement))
     return reportParseError("unexpected token, expected end of statement");
 
   // Always keep an element on the options "stack" to prevent the user
   // from changing the initial options. This is how we remember them.
   if (AssemblerOptions.size() == 2)
     return reportParseError(Loc, ".set pop with no .set push");
 
   MCSubtargetInfo &STI = copySTI();
   AssemblerOptions.pop_back();
   setAvailableFeatures(
       ComputeAvailableFeatures(AssemblerOptions.back()->getFeatures()));
   STI.setFeatureBits(AssemblerOptions.back()->getFeatures());
 
   getTargetStreamer().emitDirectiveSetPop();
   return false;
 }
 
 bool MipsAsmParser::parseSetPushDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex();
   if (getLexer().isNot(AsmToken::EndOfStatement))
     return reportParseError("unexpected token, expected end of statement");
 
   // Create a copy of the current assembler options environment and push it.
   AssemblerOptions.push_back(
         std::make_unique<MipsAssemblerOptions>(AssemblerOptions.back().get()));
 
   getTargetStreamer().emitDirectiveSetPush();
   return false;
 }
 
 bool MipsAsmParser::parseSetSoftFloatDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex();
   if (getLexer().isNot(AsmToken::EndOfStatement))
     return reportParseError("unexpected token, expected end of statement");
 
   setFeatureBits(Mips::FeatureSoftFloat, "soft-float");
   getTargetStreamer().emitDirectiveSetSoftFloat();
   return false;
 }
 
 bool MipsAsmParser::parseSetHardFloatDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex();
   if (getLexer().isNot(AsmToken::EndOfStatement))
     return reportParseError("unexpected token, expected end of statement");
 
   clearFeatureBits(Mips::FeatureSoftFloat, "soft-float");
   getTargetStreamer().emitDirectiveSetHardFloat();
   return false;
 }
 
 bool MipsAsmParser::parseSetAssignment() {
   StringRef Name;
   MCAsmParser &Parser = getParser();
 
   if (Parser.parseIdentifier(Name))
     return reportParseError("expected identifier after .set");
 
   if (getLexer().isNot(AsmToken::Comma))
     return reportParseError("unexpected token, expected comma");
   Lex(); // Eat comma
 
   if (getLexer().is(AsmToken::Dollar) &&
       getLexer().peekTok().is(AsmToken::Integer)) {
     // Parse assignment of a numeric register:
     //   .set r1,$1
     Parser.Lex(); // Eat $.
     RegisterSets[Name] = Parser.getTok();
     Parser.Lex(); // Eat identifier.
     getContext().getOrCreateSymbol(Name);
     return false;
   }
 
   MCSymbol *Sym;
   const MCExpr *Value;
   if (MCParserUtils::parseAssignmentExpression(Name, /* allow_redef */ true,
                                                Parser, Sym, Value))
     return true;
   Sym->setVariableValue(Value);
 
   return false;
 }
 
 bool MipsAsmParser::parseSetMips0Directive() {
   MCAsmParser &Parser = getParser();
   Parser.Lex();
   if (getLexer().isNot(AsmToken::EndOfStatement))
     return reportParseError("unexpected token, expected end of statement");
 
   // Reset assembler options to their initial values.
   MCSubtargetInfo &STI = copySTI();
   setAvailableFeatures(
       ComputeAvailableFeatures(AssemblerOptions.front()->getFeatures()));
   STI.setFeatureBits(AssemblerOptions.front()->getFeatures());
   AssemblerOptions.back()->setFeatures(AssemblerOptions.front()->getFeatures());
 
   getTargetStreamer().emitDirectiveSetMips0();
   return false;
 }
 
 bool MipsAsmParser::parseSetArchDirective() {
   MCAsmParser &Parser = getParser();
   Parser.Lex();
   if (getLexer().isNot(AsmToken::Equal))
     return reportParseError("unexpected token, expected equals sign");
 
   Parser.Lex();
   StringRef Arch = getParser().parseStringToEndOfStatement().trim();
   if (Arch.empty())
     return reportParseError("expected arch identifier");
 
   StringRef ArchFeatureName =
       StringSwitch<StringRef>(Arch)
           .Case("mips1", "mips1")
           .Case("mips2", "mips2")
           .Case("mips3", "mips3")
           .Case("mips4", "mips4")
           .Case("mips5", "mips5")
           .Case("mips32", "mips32")
           .Case("mips32r2", "mips32r2")
           .Case("mips32r3", "mips32r3")
           .Case("mips32r5", "mips32r5")
           .Case("mips32r6", "mips32r6")
           .Case("mips64", "mips64")
           .Case("mips64r2", "mips64r2")
           .Case("mips64r3", "mips64r3")
           .Case("mips64r5", "mips64r5")
           .Case("mips64r6", "mips64r6")
           .Case("octeon", "cnmips")
           .Case("octeon+", "cnmipsp")
           .Case("r4000", "mips3") // This is an implementation of Mips3.
           .Default("");
 
   if (ArchFeatureName.empty())
     return reportParseError("unsupported architecture");
 
   if (ArchFeatureName == "mips64r6" && inMicroMipsMode())
     return reportParseError("mips64r6 does not support microMIPS");
 
   selectArch(ArchFeatureName);
   getTargetStreamer().emitDirectiveSetArch(Arch);
   return false;
 }
 
 bool MipsAsmParser::parseSetFeature(uint64_t Feature) {
   MCAsmParser &Parser = getParser();
   Parser.Lex();
   if (getLexer().isNot(AsmToken::EndOfStatement))
     return reportParseError("unexpected token, expected end of statement");
 
   switch (Feature) {
   default:
     llvm_unreachable("Unimplemented feature");
   case Mips::FeatureMips3D:
     setFeatureBits(Mips::FeatureMips3D, "mips3d");
     getTargetStreamer().emitDirectiveSetMips3D();
     break;
   case Mips::FeatureDSP:
     setFeatureBits(Mips::FeatureDSP, "dsp");
     getTargetStreamer().emitDirectiveSetDsp();
     break;
   case Mips::FeatureDSPR2:
     setFeatureBits(Mips::FeatureDSPR2, "dspr2");
     getTargetStreamer().emitDirectiveSetDspr2();
     break;
   case Mips::FeatureMicroMips:
     setFeatureBits(Mips::FeatureMicroMips, "micromips");
     getTargetStreamer().emitDirectiveSetMicroMips();
     break;
   case Mips::FeatureMips1:
     selectArch("mips1");
     getTargetStreamer().emitDirectiveSetMips1();
     break;
   case Mips::FeatureMips2:
     selectArch("mips2");
     getTargetStreamer().emitDirectiveSetMips2();
     break;
   case Mips::FeatureMips3:
     selectArch("mips3");
     getTargetStreamer().emitDirectiveSetMips3();
     break;
   case Mips::FeatureMips4:
     selectArch("mips4");
     getTargetStreamer().emitDirectiveSetMips4();
     break;
   case Mips::FeatureMips5:
     selectArch("mips5");
     getTargetStreamer().emitDirectiveSetMips5();
     break;
   case Mips::FeatureMips32:
     selectArch("mips32");
     getTargetStreamer().emitDirectiveSetMips32();
     break;
   case Mips::FeatureMips32r2:
     selectArch("mips32r2");
     getTargetStreamer().emitDirectiveSetMips32R2();
     break;
   case Mips::FeatureMips32r3:
     selectArch("mips32r3");
     getTargetStreamer().emitDirectiveSetMips32R3();
     break;
   case Mips::FeatureMips32r5:
     selectArch("mips32r5");
     getTargetStreamer().emitDirectiveSetMips32R5();
     break;
   case Mips::FeatureMips32r6:
     selectArch("mips32r6");
     getTargetStreamer().emitDirectiveSetMips32R6();
     break;
   case Mips::FeatureMips64:
     selectArch("mips64");
     getTargetStreamer().emitDirectiveSetMips64();
     break;
   case Mips::FeatureMips64r2:
     selectArch("mips64r2");
     getTargetStreamer().emitDirectiveSetMips64R2();
     break;
   case Mips::FeatureMips64r3:
     selectArch("mips64r3");
     getTargetStreamer().emitDirectiveSetMips64R3();
     break;
   case Mips::FeatureMips64r5:
     selectArch("mips64r5");
     getTargetStreamer().emitDirectiveSetMips64R5();
     break;
   case Mips::FeatureMips64r6:
     selectArch("mips64r6");
     getTargetStreamer().emitDirectiveSetMips64R6();
     break;
   case Mips::FeatureCRC:
     setFeatureBits(Mips::FeatureCRC, "crc");
     getTargetStreamer().emitDirectiveSetCRC();
     break;
   case Mips::FeatureVirt:
     setFeatureBits(Mips::FeatureVirt, "virt");
     getTargetStreamer().emitDirectiveSetVirt();
     break;
   case Mips::FeatureGINV:
     setFeatureBits(Mips::FeatureGINV, "ginv");
     getTargetStreamer().emitDirectiveSetGINV();
     break;
   }
   return false;
 }
 
 bool MipsAsmParser::eatComma(StringRef ErrorStr) {
   MCAsmParser &Parser = getParser();
   if (getLexer().isNot(AsmToken::Comma)) {
     SMLoc Loc = getLexer().getLoc();
     return Error(Loc, ErrorStr);
   }
 
   Parser.Lex(); // Eat the comma.
   return true;
 }
 
 // Used to determine if .cpload, .cprestore, and .cpsetup have any effect.
 // In this class, it is only used for .cprestore.
 // FIXME: Only keep track of IsPicEnabled in one place, instead of in both
 // MipsTargetELFStreamer and MipsAsmParser.
 bool MipsAsmParser::isPicAndNotNxxAbi() {
   return inPicMode() && !(isABI_N32() || isABI_N64());
 }
 
 bool MipsAsmParser::parseDirectiveCpAdd(SMLoc Loc) {
   SmallVector<std::unique_ptr<MCParsedAsmOperand>, 1> Reg;
   OperandMatchResultTy ResTy = parseAnyRegister(Reg);
   if (ResTy == MatchOperand_NoMatch || ResTy == MatchOperand_ParseFail) {
     reportParseError("expected register");
     return false;
   }
 
   MipsOperand &RegOpnd = static_cast<MipsOperand &>(*Reg[0]);
   if (!RegOpnd.isGPRAsmReg()) {
     reportParseError(RegOpnd.getStartLoc(), "invalid register");
     return false;
   }
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
   getParser().Lex(); // Consume the EndOfStatement.
 
   getTargetStreamer().emitDirectiveCpAdd(RegOpnd.getGPR32Reg());
   return false;
 }
 
 bool MipsAsmParser::parseDirectiveCpLoad(SMLoc Loc) {
   if (AssemblerOptions.back()->isReorder())
     Warning(Loc, ".cpload should be inside a noreorder section");
 
   if (inMips16Mode()) {
     reportParseError(".cpload is not supported in Mips16 mode");
     return false;
   }
 
   SmallVector<std::unique_ptr<MCParsedAsmOperand>, 1> Reg;
   OperandMatchResultTy ResTy = parseAnyRegister(Reg);
   if (ResTy == MatchOperand_NoMatch || ResTy == MatchOperand_ParseFail) {
     reportParseError("expected register containing function address");
     return false;
   }
 
   MipsOperand &RegOpnd = static_cast<MipsOperand &>(*Reg[0]);
   if (!RegOpnd.isGPRAsmReg()) {
     reportParseError(RegOpnd.getStartLoc(), "invalid register");
     return false;
   }
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   getTargetStreamer().emitDirectiveCpLoad(RegOpnd.getGPR32Reg());
   return false;
 }
 
 bool MipsAsmParser::parseDirectiveCpLocal(SMLoc Loc) {
   if (!isABI_N32() && !isABI_N64()) {
     reportParseError(".cplocal is allowed only in N32 or N64 mode");
     return false;
   }
 
   SmallVector<std::unique_ptr<MCParsedAsmOperand>, 1> Reg;
   OperandMatchResultTy ResTy = parseAnyRegister(Reg);
   if (ResTy == MatchOperand_NoMatch || ResTy == MatchOperand_ParseFail) {
     reportParseError("expected register containing global pointer");
     return false;
   }
 
   MipsOperand &RegOpnd = static_cast<MipsOperand &>(*Reg[0]);
   if (!RegOpnd.isGPRAsmReg()) {
     reportParseError(RegOpnd.getStartLoc(), "invalid register");
     return false;
   }
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
   getParser().Lex(); // Consume the EndOfStatement.
 
   unsigned NewReg = RegOpnd.getGPR32Reg();
   if (IsPicEnabled)
     GPReg = NewReg;
 
   getTargetStreamer().emitDirectiveCpLocal(NewReg);
   return false;
 }
 
 bool MipsAsmParser::parseDirectiveCpRestore(SMLoc Loc) {
   MCAsmParser &Parser = getParser();
 
   // Note that .cprestore is ignored if used with the N32 and N64 ABIs or if it
   // is used in non-PIC mode.
 
   if (inMips16Mode()) {
     reportParseError(".cprestore is not supported in Mips16 mode");
     return false;
   }
 
   // Get the stack offset value.
   const MCExpr *StackOffset;
   int64_t StackOffsetVal;
   if (Parser.parseExpression(StackOffset)) {
     reportParseError("expected stack offset value");
     return false;
   }
 
   if (!StackOffset->evaluateAsAbsolute(StackOffsetVal)) {
     reportParseError("stack offset is not an absolute expression");
     return false;
   }
 
   if (StackOffsetVal < 0) {
     Warning(Loc, ".cprestore with negative stack offset has no effect");
     IsCpRestoreSet = false;
   } else {
     IsCpRestoreSet = true;
     CpRestoreOffset = StackOffsetVal;
   }
 
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   if (!getTargetStreamer().emitDirectiveCpRestore(
           CpRestoreOffset, [&]() { return getATReg(Loc); }, Loc, STI))
     return true;
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 bool MipsAsmParser::parseDirectiveCPSetup() {
   MCAsmParser &Parser = getParser();
   unsigned FuncReg;
   unsigned Save;
   bool SaveIsReg = true;
 
   SmallVector<std::unique_ptr<MCParsedAsmOperand>, 1> TmpReg;
   OperandMatchResultTy ResTy = parseAnyRegister(TmpReg);
   if (ResTy == MatchOperand_NoMatch) {
     reportParseError("expected register containing function address");
     return false;
   }
 
   MipsOperand &FuncRegOpnd = static_cast<MipsOperand &>(*TmpReg[0]);
   if (!FuncRegOpnd.isGPRAsmReg()) {
     reportParseError(FuncRegOpnd.getStartLoc(), "invalid register");
     return false;
   }
 
   FuncReg = FuncRegOpnd.getGPR32Reg();
   TmpReg.clear();
 
   if (!eatComma("unexpected token, expected comma"))
     return true;
 
   ResTy = parseAnyRegister(TmpReg);
   if (ResTy == MatchOperand_NoMatch) {
     const MCExpr *OffsetExpr;
     int64_t OffsetVal;
     SMLoc ExprLoc = getLexer().getLoc();
 
     if (Parser.parseExpression(OffsetExpr) ||
         !OffsetExpr->evaluateAsAbsolute(OffsetVal)) {
       reportParseError(ExprLoc, "expected save register or stack offset");
       return false;
     }
 
     Save = OffsetVal;
     SaveIsReg = false;
   } else {
     MipsOperand &SaveOpnd = static_cast<MipsOperand &>(*TmpReg[0]);
     if (!SaveOpnd.isGPRAsmReg()) {
       reportParseError(SaveOpnd.getStartLoc(), "invalid register");
       return false;
     }
     Save = SaveOpnd.getGPR32Reg();
   }
 
   if (!eatComma("unexpected token, expected comma"))
     return true;
 
   const MCExpr *Expr;
   if (Parser.parseExpression(Expr)) {
     reportParseError("expected expression");
     return false;
   }
 
   if (Expr->getKind() != MCExpr::SymbolRef) {
     reportParseError("expected symbol");
     return false;
   }
   const MCSymbolRefExpr *Ref = static_cast<const MCSymbolRefExpr *>(Expr);
 
   CpSaveLocation = Save;
   CpSaveLocationIsRegister = SaveIsReg;
 
   getTargetStreamer().emitDirectiveCpsetup(FuncReg, Save, Ref->getSymbol(),
                                            SaveIsReg);
   return false;
 }
 
 bool MipsAsmParser::parseDirectiveCPReturn() {
   getTargetStreamer().emitDirectiveCpreturn(CpSaveLocation,
                                             CpSaveLocationIsRegister);
   return false;
 }
 
 bool MipsAsmParser::parseDirectiveNaN() {
   MCAsmParser &Parser = getParser();
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     const AsmToken &Tok = Parser.getTok();
 
     if (Tok.getString() == "2008") {
       Parser.Lex();
       getTargetStreamer().emitDirectiveNaN2008();
       return false;
     } else if (Tok.getString() == "legacy") {
       Parser.Lex();
       getTargetStreamer().emitDirectiveNaNLegacy();
       return false;
     }
   }
   // If we don't recognize the option passed to the .nan
   // directive (e.g. no option or unknown option), emit an error.
   reportParseError("invalid option in .nan directive");
   return false;
 }
 
 bool MipsAsmParser::parseDirectiveSet() {
   const AsmToken &Tok = getParser().getTok();
   StringRef IdVal = Tok.getString();
   SMLoc Loc = Tok.getLoc();
 
   if (IdVal == "noat")
     return parseSetNoAtDirective();
   if (IdVal == "at")
     return parseSetAtDirective();
   if (IdVal == "arch")
     return parseSetArchDirective();
   if (IdVal == "bopt") {
     Warning(Loc, "'bopt' feature is unsupported");
     getParser().Lex();
     return false;
   }
   if (IdVal == "nobopt") {
     // We're already running in nobopt mode, so nothing to do.
     getParser().Lex();
     return false;
   }
   if (IdVal == "fp")
     return parseSetFpDirective();
   if (IdVal == "oddspreg")
     return parseSetOddSPRegDirective();
   if (IdVal == "nooddspreg")
     return parseSetNoOddSPRegDirective();
   if (IdVal == "pop")
     return parseSetPopDirective();
   if (IdVal == "push")
     return parseSetPushDirective();
   if (IdVal == "reorder")
     return parseSetReorderDirective();
   if (IdVal == "noreorder")
     return parseSetNoReorderDirective();
   if (IdVal == "macro")
     return parseSetMacroDirective();
   if (IdVal == "nomacro")
     return parseSetNoMacroDirective();
   if (IdVal == "mips16")
     return parseSetMips16Directive();
   if (IdVal == "nomips16")
     return parseSetNoMips16Directive();
   if (IdVal == "nomicromips") {
     clearFeatureBits(Mips::FeatureMicroMips, "micromips");
     getTargetStreamer().emitDirectiveSetNoMicroMips();
     getParser().eatToEndOfStatement();
     return false;
   }
   if (IdVal == "micromips") {
     if (hasMips64r6()) {
       Error(Loc, ".set micromips directive is not supported with MIPS64R6");
       return false;
     }
     return parseSetFeature(Mips::FeatureMicroMips);
   }
   if (IdVal == "mips0")
     return parseSetMips0Directive();
   if (IdVal == "mips1")
     return parseSetFeature(Mips::FeatureMips1);
   if (IdVal == "mips2")
     return parseSetFeature(Mips::FeatureMips2);
   if (IdVal == "mips3")
     return parseSetFeature(Mips::FeatureMips3);
   if (IdVal == "mips4")
     return parseSetFeature(Mips::FeatureMips4);
   if (IdVal == "mips5")
     return parseSetFeature(Mips::FeatureMips5);
   if (IdVal == "mips32")
     return parseSetFeature(Mips::FeatureMips32);
   if (IdVal == "mips32r2")
     return parseSetFeature(Mips::FeatureMips32r2);
   if (IdVal == "mips32r3")
     return parseSetFeature(Mips::FeatureMips32r3);
   if (IdVal == "mips32r5")
     return parseSetFeature(Mips::FeatureMips32r5);
   if (IdVal == "mips32r6")
     return parseSetFeature(Mips::FeatureMips32r6);
   if (IdVal == "mips64")
     return parseSetFeature(Mips::FeatureMips64);
   if (IdVal == "mips64r2")
     return parseSetFeature(Mips::FeatureMips64r2);
   if (IdVal == "mips64r3")
     return parseSetFeature(Mips::FeatureMips64r3);
   if (IdVal == "mips64r5")
     return parseSetFeature(Mips::FeatureMips64r5);
   if (IdVal == "mips64r6") {
     if (inMicroMipsMode()) {
       Error(Loc, "MIPS64R6 is not supported with microMIPS");
       return false;
     }
     return parseSetFeature(Mips::FeatureMips64r6);
   }
   if (IdVal == "dsp")
     return parseSetFeature(Mips::FeatureDSP);
   if (IdVal == "dspr2")
     return parseSetFeature(Mips::FeatureDSPR2);
   if (IdVal == "nodsp")
     return parseSetNoDspDirective();
   if (IdVal == "mips3d")
     return parseSetFeature(Mips::FeatureMips3D);
   if (IdVal == "nomips3d")
     return parseSetNoMips3DDirective();
   if (IdVal == "msa")
     return parseSetMsaDirective();
   if (IdVal == "nomsa")
     return parseSetNoMsaDirective();
   if (IdVal == "mt")
     return parseSetMtDirective();
   if (IdVal == "nomt")
     return parseSetNoMtDirective();
   if (IdVal == "softfloat")
     return parseSetSoftFloatDirective();
   if (IdVal == "hardfloat")
     return parseSetHardFloatDirective();
   if (IdVal == "crc")
     return parseSetFeature(Mips::FeatureCRC);
   if (IdVal == "nocrc")
     return parseSetNoCRCDirective();
   if (IdVal == "virt")
     return parseSetFeature(Mips::FeatureVirt);
   if (IdVal == "novirt")
     return parseSetNoVirtDirective();
   if (IdVal == "ginv")
     return parseSetFeature(Mips::FeatureGINV);
   if (IdVal == "noginv")
     return parseSetNoGINVDirective();
 
   // It is just an identifier, look for an assignment.
   return parseSetAssignment();
 }
 
 /// parseDirectiveGpWord
 ///  ::= .gpword local_sym
 bool MipsAsmParser::parseDirectiveGpWord() {
   MCAsmParser &Parser = getParser();
   const MCExpr *Value;
   // EmitGPRel32Value requires an expression, so we are using base class
   // method to evaluate the expression.
   if (getParser().parseExpression(Value))
     return true;
   getParser().getStreamer().emitGPRel32Value(Value);
 
   if (getLexer().isNot(AsmToken::EndOfStatement))
     return Error(getLexer().getLoc(),
                 "unexpected token, expected end of statement");
   Parser.Lex(); // Eat EndOfStatement token.
   return false;
 }
 
 /// parseDirectiveGpDWord
 ///  ::= .gpdword local_sym
 bool MipsAsmParser::parseDirectiveGpDWord() {
   MCAsmParser &Parser = getParser();
   const MCExpr *Value;
   // EmitGPRel64Value requires an expression, so we are using base class
   // method to evaluate the expression.
   if (getParser().parseExpression(Value))
     return true;
   getParser().getStreamer().emitGPRel64Value(Value);
 
   if (getLexer().isNot(AsmToken::EndOfStatement))
     return Error(getLexer().getLoc(),
                 "unexpected token, expected end of statement");
   Parser.Lex(); // Eat EndOfStatement token.
   return false;
 }
 
 /// parseDirectiveDtpRelWord
 ///  ::= .dtprelword tls_sym
 bool MipsAsmParser::parseDirectiveDtpRelWord() {
   MCAsmParser &Parser = getParser();
   const MCExpr *Value;
   // EmitDTPRel32Value requires an expression, so we are using base class
   // method to evaluate the expression.
   if (getParser().parseExpression(Value))
     return true;
   getParser().getStreamer().emitDTPRel32Value(Value);
 
   if (getLexer().isNot(AsmToken::EndOfStatement))
     return Error(getLexer().getLoc(),
                 "unexpected token, expected end of statement");
   Parser.Lex(); // Eat EndOfStatement token.
   return false;
 }
 
 /// parseDirectiveDtpRelDWord
 ///  ::= .dtpreldword tls_sym
 bool MipsAsmParser::parseDirectiveDtpRelDWord() {
   MCAsmParser &Parser = getParser();
   const MCExpr *Value;
   // EmitDTPRel64Value requires an expression, so we are using base class
   // method to evaluate the expression.
   if (getParser().parseExpression(Value))
     return true;
   getParser().getStreamer().emitDTPRel64Value(Value);
 
   if (getLexer().isNot(AsmToken::EndOfStatement))
     return Error(getLexer().getLoc(),
                 "unexpected token, expected end of statement");
   Parser.Lex(); // Eat EndOfStatement token.
   return false;
 }
 
 /// parseDirectiveTpRelWord
 ///  ::= .tprelword tls_sym
 bool MipsAsmParser::parseDirectiveTpRelWord() {
   MCAsmParser &Parser = getParser();
   const MCExpr *Value;
   // EmitTPRel32Value requires an expression, so we are using base class
   // method to evaluate the expression.
   if (getParser().parseExpression(Value))
     return true;
   getParser().getStreamer().emitTPRel32Value(Value);
 
   if (getLexer().isNot(AsmToken::EndOfStatement))
     return Error(getLexer().getLoc(),
                 "unexpected token, expected end of statement");
   Parser.Lex(); // Eat EndOfStatement token.
   return false;
 }
 
 /// parseDirectiveTpRelDWord
 ///  ::= .tpreldword tls_sym
 bool MipsAsmParser::parseDirectiveTpRelDWord() {
   MCAsmParser &Parser = getParser();
   const MCExpr *Value;
   // EmitTPRel64Value requires an expression, so we are using base class
   // method to evaluate the expression.
   if (getParser().parseExpression(Value))
     return true;
   getParser().getStreamer().emitTPRel64Value(Value);
 
   if (getLexer().isNot(AsmToken::EndOfStatement))
     return Error(getLexer().getLoc(),
                 "unexpected token, expected end of statement");
   Parser.Lex(); // Eat EndOfStatement token.
   return false;
 }
 
 bool MipsAsmParser::parseDirectiveOption() {
   MCAsmParser &Parser = getParser();
   // Get the option token.
   AsmToken Tok = Parser.getTok();
   // At the moment only identifiers are supported.
   if (Tok.isNot(AsmToken::Identifier)) {
     return Error(Parser.getTok().getLoc(),
                  "unexpected token, expected identifier");
   }
 
   StringRef Option = Tok.getIdentifier();
 
   if (Option == "pic0") {
     // MipsAsmParser needs to know if the current PIC mode changes.
     IsPicEnabled = false;
 
     getTargetStreamer().emitDirectiveOptionPic0();
     Parser.Lex();
     if (Parser.getTok().isNot(AsmToken::EndOfStatement)) {
       return Error(Parser.getTok().getLoc(),
                    "unexpected token, expected end of statement");
     }
     return false;
   }
 
   if (Option == "pic2") {
     // MipsAsmParser needs to know if the current PIC mode changes.
     IsPicEnabled = true;
 
     getTargetStreamer().emitDirectiveOptionPic2();
     Parser.Lex();
     if (Parser.getTok().isNot(AsmToken::EndOfStatement)) {
       return Error(Parser.getTok().getLoc(),
                    "unexpected token, expected end of statement");
     }
     return false;
   }
 
   // Unknown option.
   Warning(Parser.getTok().getLoc(),
           "unknown option, expected 'pic0' or 'pic2'");
   Parser.eatToEndOfStatement();
   return false;
 }
 
 /// parseInsnDirective
 ///  ::= .insn
 bool MipsAsmParser::parseInsnDirective() {
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   // The actual label marking happens in
   // MipsELFStreamer::createPendingLabelRelocs().
   getTargetStreamer().emitDirectiveInsn();
 
   getParser().Lex(); // Eat EndOfStatement token.
   return false;
 }
 
 /// parseRSectionDirective
 ///  ::= .rdata
 bool MipsAsmParser::parseRSectionDirective(StringRef Section) {
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   MCSection *ELFSection = getContext().getELFSection(
       Section, ELF::SHT_PROGBITS, ELF::SHF_ALLOC);
   getParser().getStreamer().SwitchSection(ELFSection);
 
   getParser().Lex(); // Eat EndOfStatement token.
   return false;
 }
 
 /// parseSSectionDirective
 ///  ::= .sbss
 ///  ::= .sdata
 bool MipsAsmParser::parseSSectionDirective(StringRef Section, unsigned Type) {
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   MCSection *ELFSection = getContext().getELFSection(
       Section, Type, ELF::SHF_WRITE | ELF::SHF_ALLOC | ELF::SHF_MIPS_GPREL);
   getParser().getStreamer().SwitchSection(ELFSection);
 
   getParser().Lex(); // Eat EndOfStatement token.
   return false;
 }
 
 /// parseDirectiveModule
 ///  ::= .module oddspreg
 ///  ::= .module nooddspreg
 ///  ::= .module fp=value
 ///  ::= .module softfloat
 ///  ::= .module hardfloat
 ///  ::= .module mt
 ///  ::= .module crc
 ///  ::= .module nocrc
 ///  ::= .module virt
 ///  ::= .module novirt
 ///  ::= .module ginv
 ///  ::= .module noginv
 bool MipsAsmParser::parseDirectiveModule() {
   MCAsmParser &Parser = getParser();
   MCAsmLexer &Lexer = getLexer();
   SMLoc L = Lexer.getLoc();
 
   if (!getTargetStreamer().isModuleDirectiveAllowed()) {
     // TODO : get a better message.
     reportParseError(".module directive must appear before any code");
     return false;
   }
 
   StringRef Option;
   if (Parser.parseIdentifier(Option)) {
     reportParseError("expected .module option identifier");
     return false;
   }
 
   if (Option == "oddspreg") {
     clearModuleFeatureBits(Mips::FeatureNoOddSPReg, "nooddspreg");
 
     // Synchronize the abiflags information with the FeatureBits information we
     // changed above.
     getTargetStreamer().updateABIInfo(*this);
 
     // If printing assembly, use the recently updated abiflags information.
     // If generating ELF, don't do anything (the .MIPS.abiflags section gets
     // emitted at the end).
     getTargetStreamer().emitDirectiveModuleOddSPReg();
 
     // If this is not the end of the statement, report an error.
     if (getLexer().isNot(AsmToken::EndOfStatement)) {
       reportParseError("unexpected token, expected end of statement");
       return false;
     }
 
     return false; // parseDirectiveModule has finished successfully.
   } else if (Option == "nooddspreg") {
     if (!isABI_O32()) {
       return Error(L, "'.module nooddspreg' requires the O32 ABI");
     }
 
     setModuleFeatureBits(Mips::FeatureNoOddSPReg, "nooddspreg");
 
     // Synchronize the abiflags information with the FeatureBits information we
     // changed above.
     getTargetStreamer().updateABIInfo(*this);
 
     // If printing assembly, use the recently updated abiflags information.
     // If generating ELF, don't do anything (the .MIPS.abiflags section gets
     // emitted at the end).
     getTargetStreamer().emitDirectiveModuleOddSPReg();
 
     // If this is not the end of the statement, report an error.
     if (getLexer().isNot(AsmToken::EndOfStatement)) {
       reportParseError("unexpected token, expected end of statement");
       return false;
     }
 
     return false; // parseDirectiveModule has finished successfully.
   } else if (Option == "fp") {
     return parseDirectiveModuleFP();
   } else if (Option == "softfloat") {
     setModuleFeatureBits(Mips::FeatureSoftFloat, "soft-float");
 
     // Synchronize the ABI Flags information with the FeatureBits information we
     // updated above.
     getTargetStreamer().updateABIInfo(*this);
 
     // If printing assembly, use the recently updated ABI Flags information.
     // If generating ELF, don't do anything (the .MIPS.abiflags section gets
     // emitted later).
     getTargetStreamer().emitDirectiveModuleSoftFloat();
 
     // If this is not the end of the statement, report an error.
     if (getLexer().isNot(AsmToken::EndOfStatement)) {
       reportParseError("unexpected token, expected end of statement");
       return false;
     }
 
     return false; // parseDirectiveModule has finished successfully.
   } else if (Option == "hardfloat") {
     clearModuleFeatureBits(Mips::FeatureSoftFloat, "soft-float");
 
     // Synchronize the ABI Flags information with the FeatureBits information we
     // updated above.
     getTargetStreamer().updateABIInfo(*this);
 
     // If printing assembly, use the recently updated ABI Flags information.
     // If generating ELF, don't do anything (the .MIPS.abiflags section gets
     // emitted later).
     getTargetStreamer().emitDirectiveModuleHardFloat();
 
     // If this is not the end of the statement, report an error.
     if (getLexer().isNot(AsmToken::EndOfStatement)) {
       reportParseError("unexpected token, expected end of statement");
       return false;
     }
 
     return false; // parseDirectiveModule has finished successfully.
   } else if (Option == "mt") {
     setModuleFeatureBits(Mips::FeatureMT, "mt");
 
     // Synchronize the ABI Flags information with the FeatureBits information we
     // updated above.
     getTargetStreamer().updateABIInfo(*this);
 
     // If printing assembly, use the recently updated ABI Flags information.
     // If generating ELF, don't do anything (the .MIPS.abiflags section gets
     // emitted later).
     getTargetStreamer().emitDirectiveModuleMT();
 
     // If this is not the end of the statement, report an error.
     if (getLexer().isNot(AsmToken::EndOfStatement)) {
       reportParseError("unexpected token, expected end of statement");
       return false;
     }
 
     return false; // parseDirectiveModule has finished successfully.
   } else if (Option == "crc") {
     setModuleFeatureBits(Mips::FeatureCRC, "crc");
 
     // Synchronize the ABI Flags information with the FeatureBits information we
     // updated above.
     getTargetStreamer().updateABIInfo(*this);
 
     // If printing assembly, use the recently updated ABI Flags information.
     // If generating ELF, don't do anything (the .MIPS.abiflags section gets
     // emitted later).
     getTargetStreamer().emitDirectiveModuleCRC();
 
     // If this is not the end of the statement, report an error.
     if (getLexer().isNot(AsmToken::EndOfStatement)) {
       reportParseError("unexpected token, expected end of statement");
       return false;
     }
 
     return false; // parseDirectiveModule has finished successfully.
   } else if (Option == "nocrc") {
     clearModuleFeatureBits(Mips::FeatureCRC, "crc");
 
     // Synchronize the ABI Flags information with the FeatureBits information we
     // updated above.
     getTargetStreamer().updateABIInfo(*this);
 
     // If printing assembly, use the recently updated ABI Flags information.
     // If generating ELF, don't do anything (the .MIPS.abiflags section gets
     // emitted later).
     getTargetStreamer().emitDirectiveModuleNoCRC();
 
     // If this is not the end of the statement, report an error.
     if (getLexer().isNot(AsmToken::EndOfStatement)) {
       reportParseError("unexpected token, expected end of statement");
       return false;
     }
 
     return false; // parseDirectiveModule has finished successfully.
   } else if (Option == "virt") {
     setModuleFeatureBits(Mips::FeatureVirt, "virt");
 
     // Synchronize the ABI Flags information with the FeatureBits information we
     // updated above.
     getTargetStreamer().updateABIInfo(*this);
 
     // If printing assembly, use the recently updated ABI Flags information.
     // If generating ELF, don't do anything (the .MIPS.abiflags section gets
     // emitted later).
     getTargetStreamer().emitDirectiveModuleVirt();
 
     // If this is not the end of the statement, report an error.
     if (getLexer().isNot(AsmToken::EndOfStatement)) {
       reportParseError("unexpected token, expected end of statement");
       return false;
     }
 
     return false; // parseDirectiveModule has finished successfully.
   } else if (Option == "novirt") {
     clearModuleFeatureBits(Mips::FeatureVirt, "virt");
 
     // Synchronize the ABI Flags information with the FeatureBits information we
     // updated above.
     getTargetStreamer().updateABIInfo(*this);
 
     // If printing assembly, use the recently updated ABI Flags information.
     // If generating ELF, don't do anything (the .MIPS.abiflags section gets
     // emitted later).
     getTargetStreamer().emitDirectiveModuleNoVirt();
 
     // If this is not the end of the statement, report an error.
     if (getLexer().isNot(AsmToken::EndOfStatement)) {
       reportParseError("unexpected token, expected end of statement");
       return false;
     }
 
     return false; // parseDirectiveModule has finished successfully.
   } else if (Option == "ginv") {
     setModuleFeatureBits(Mips::FeatureGINV, "ginv");
 
     // Synchronize the ABI Flags information with the FeatureBits information we
     // updated above.
     getTargetStreamer().updateABIInfo(*this);
 
     // If printing assembly, use the recently updated ABI Flags information.
     // If generating ELF, don't do anything (the .MIPS.abiflags section gets
     // emitted later).
     getTargetStreamer().emitDirectiveModuleGINV();
 
     // If this is not the end of the statement, report an error.
     if (getLexer().isNot(AsmToken::EndOfStatement)) {
       reportParseError("unexpected token, expected end of statement");
       return false;
     }
 
     return false; // parseDirectiveModule has finished successfully.
   } else if (Option == "noginv") {
     clearModuleFeatureBits(Mips::FeatureGINV, "ginv");
 
     // Synchronize the ABI Flags information with the FeatureBits information we
     // updated above.
     getTargetStreamer().updateABIInfo(*this);
 
     // If printing assembly, use the recently updated ABI Flags information.
     // If generating ELF, don't do anything (the .MIPS.abiflags section gets
     // emitted later).
     getTargetStreamer().emitDirectiveModuleNoGINV();
 
     // If this is not the end of the statement, report an error.
     if (getLexer().isNot(AsmToken::EndOfStatement)) {
       reportParseError("unexpected token, expected end of statement");
       return false;
     }
 
     return false; // parseDirectiveModule has finished successfully.
   } else {
     return Error(L, "'" + Twine(Option) + "' is not a valid .module option.");
   }
 }
 
 /// parseDirectiveModuleFP
 ///  ::= =32
 ///  ::= =xx
 ///  ::= =64
 bool MipsAsmParser::parseDirectiveModuleFP() {
   MCAsmParser &Parser = getParser();
   MCAsmLexer &Lexer = getLexer();
 
   if (Lexer.isNot(AsmToken::Equal)) {
     reportParseError("unexpected token, expected equals sign '='");
     return false;
   }
   Parser.Lex(); // Eat '=' token.
 
   MipsABIFlagsSection::FpABIKind FpABI;
   if (!parseFpABIValue(FpABI, ".module"))
     return false;
 
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   // Synchronize the abiflags information with the FeatureBits information we
   // changed above.
   getTargetStreamer().updateABIInfo(*this);
 
   // If printing assembly, use the recently updated abiflags information.
   // If generating ELF, don't do anything (the .MIPS.abiflags section gets
   // emitted at the end).
   getTargetStreamer().emitDirectiveModuleFP();
 
   Parser.Lex(); // Consume the EndOfStatement.
   return false;
 }
 
 bool MipsAsmParser::parseFpABIValue(MipsABIFlagsSection::FpABIKind &FpABI,
                                     StringRef Directive) {
   MCAsmParser &Parser = getParser();
   MCAsmLexer &Lexer = getLexer();
   bool ModuleLevelOptions = Directive == ".module";
 
   if (Lexer.is(AsmToken::Identifier)) {
     StringRef Value = Parser.getTok().getString();
     Parser.Lex();
 
     if (Value != "xx") {
       reportParseError("unsupported value, expected 'xx', '32' or '64'");
       return false;
     }
 
     if (!isABI_O32()) {
       reportParseError("'" + Directive + " fp=xx' requires the O32 ABI");
       return false;
     }
 
     FpABI = MipsABIFlagsSection::FpABIKind::XX;
     if (ModuleLevelOptions) {
       setModuleFeatureBits(Mips::FeatureFPXX, "fpxx");
       clearModuleFeatureBits(Mips::FeatureFP64Bit, "fp64");
     } else {
       setFeatureBits(Mips::FeatureFPXX, "fpxx");
       clearFeatureBits(Mips::FeatureFP64Bit, "fp64");
     }
     return true;
   }
 
   if (Lexer.is(AsmToken::Integer)) {
     unsigned Value = Parser.getTok().getIntVal();
     Parser.Lex();
 
     if (Value != 32 && Value != 64) {
       reportParseError("unsupported value, expected 'xx', '32' or '64'");
       return false;
     }
 
     if (Value == 32) {
       if (!isABI_O32()) {
         reportParseError("'" + Directive + " fp=32' requires the O32 ABI");
         return false;
       }
 
       FpABI = MipsABIFlagsSection::FpABIKind::S32;
       if (ModuleLevelOptions) {
         clearModuleFeatureBits(Mips::FeatureFPXX, "fpxx");
         clearModuleFeatureBits(Mips::FeatureFP64Bit, "fp64");
       } else {
         clearFeatureBits(Mips::FeatureFPXX, "fpxx");
         clearFeatureBits(Mips::FeatureFP64Bit, "fp64");
       }
     } else {
       FpABI = MipsABIFlagsSection::FpABIKind::S64;
       if (ModuleLevelOptions) {
         clearModuleFeatureBits(Mips::FeatureFPXX, "fpxx");
         setModuleFeatureBits(Mips::FeatureFP64Bit, "fp64");
       } else {
         clearFeatureBits(Mips::FeatureFPXX, "fpxx");
         setFeatureBits(Mips::FeatureFP64Bit, "fp64");
       }
     }
 
     return true;
   }
 
   return false;
 }
 
 bool MipsAsmParser::ParseDirective(AsmToken DirectiveID) {
   // This returns false if this function recognizes the directive
   // regardless of whether it is successfully handles or reports an
   // error. Otherwise it returns true to give the generic parser a
   // chance at recognizing it.
 
   MCAsmParser &Parser = getParser();
   StringRef IDVal = DirectiveID.getString();
 
   if (IDVal == ".cpadd") {
     parseDirectiveCpAdd(DirectiveID.getLoc());
     return false;
   }
   if (IDVal == ".cpload") {
     parseDirectiveCpLoad(DirectiveID.getLoc());
     return false;
   }
   if (IDVal == ".cprestore") {
     parseDirectiveCpRestore(DirectiveID.getLoc());
     return false;
   }
   if (IDVal == ".cplocal") {
     parseDirectiveCpLocal(DirectiveID.getLoc());
     return false;
   }
   if (IDVal == ".ent") {
     StringRef SymbolName;
 
     if (Parser.parseIdentifier(SymbolName)) {
       reportParseError("expected identifier after .ent");
       return false;
     }
 
     // There's an undocumented extension that allows an integer to
     // follow the name of the procedure which AFAICS is ignored by GAS.
     // Example: .ent foo,2
     if (getLexer().isNot(AsmToken::EndOfStatement)) {
       if (getLexer().isNot(AsmToken::Comma)) {
         // Even though we accept this undocumented extension for compatibility
         // reasons, the additional integer argument does not actually change
         // the behaviour of the '.ent' directive, so we would like to discourage
         // its use. We do this by not referring to the extended version in
         // error messages which are not directly related to its use.
         reportParseError("unexpected token, expected end of statement");
         return false;
       }
       Parser.Lex(); // Eat the comma.
       const MCExpr *DummyNumber;
       int64_t DummyNumberVal;
       // If the user was explicitly trying to use the extended version,
       // we still give helpful extension-related error messages.
       if (Parser.parseExpression(DummyNumber)) {
         reportParseError("expected number after comma");
         return false;
       }
       if (!DummyNumber->evaluateAsAbsolute(DummyNumberVal)) {
         reportParseError("expected an absolute expression after comma");
         return false;
       }
     }
 
     // If this is not the end of the statement, report an error.
     if (getLexer().isNot(AsmToken::EndOfStatement)) {
       reportParseError("unexpected token, expected end of statement");
       return false;
     }
 
     MCSymbol *Sym = getContext().getOrCreateSymbol(SymbolName);
 
     getTargetStreamer().emitDirectiveEnt(*Sym);
     CurrentFn = Sym;
     IsCpRestoreSet = false;
     return false;
   }
 
   if (IDVal == ".end") {
     StringRef SymbolName;
 
     if (Parser.parseIdentifier(SymbolName)) {
       reportParseError("expected identifier after .end");
       return false;
     }
 
     if (getLexer().isNot(AsmToken::EndOfStatement)) {
       reportParseError("unexpected token, expected end of statement");
       return false;
     }
 
     if (CurrentFn == nullptr) {
       reportParseError(".end used without .ent");
       return false;
     }
 
     if ((SymbolName != CurrentFn->getName())) {
       reportParseError(".end symbol does not match .ent symbol");
       return false;
     }
 
     getTargetStreamer().emitDirectiveEnd(SymbolName);
     CurrentFn = nullptr;
     IsCpRestoreSet = false;
     return false;
   }
 
   if (IDVal == ".frame") {
     // .frame $stack_reg, frame_size_in_bytes, $return_reg
     SmallVector<std::unique_ptr<MCParsedAsmOperand>, 1> TmpReg;
     OperandMatchResultTy ResTy = parseAnyRegister(TmpReg);
     if (ResTy == MatchOperand_NoMatch || ResTy == MatchOperand_ParseFail) {
       reportParseError("expected stack register");
       return false;
     }
 
     MipsOperand &StackRegOpnd = static_cast<MipsOperand &>(*TmpReg[0]);
     if (!StackRegOpnd.isGPRAsmReg()) {
       reportParseError(StackRegOpnd.getStartLoc(),
                        "expected general purpose register");
       return false;
     }
     unsigned StackReg = StackRegOpnd.getGPR32Reg();
 
     if (Parser.getTok().is(AsmToken::Comma))
       Parser.Lex();
     else {
       reportParseError("unexpected token, expected comma");
       return false;
     }
 
     // Parse the frame size.
     const MCExpr *FrameSize;
     int64_t FrameSizeVal;
 
     if (Parser.parseExpression(FrameSize)) {
       reportParseError("expected frame size value");
       return false;
     }
 
     if (!FrameSize->evaluateAsAbsolute(FrameSizeVal)) {
       reportParseError("frame size not an absolute expression");
       return false;
     }
 
     if (Parser.getTok().is(AsmToken::Comma))
       Parser.Lex();
     else {
       reportParseError("unexpected token, expected comma");
       return false;
     }
 
     // Parse the return register.
     TmpReg.clear();
     ResTy = parseAnyRegister(TmpReg);
     if (ResTy == MatchOperand_NoMatch || ResTy == MatchOperand_ParseFail) {
       reportParseError("expected return register");
       return false;
     }
 
     MipsOperand &ReturnRegOpnd = static_cast<MipsOperand &>(*TmpReg[0]);
     if (!ReturnRegOpnd.isGPRAsmReg()) {
       reportParseError(ReturnRegOpnd.getStartLoc(),
                        "expected general purpose register");
       return false;
     }
 
     // If this is not the end of the statement, report an error.
     if (getLexer().isNot(AsmToken::EndOfStatement)) {
       reportParseError("unexpected token, expected end of statement");
       return false;
     }
 
     getTargetStreamer().emitFrame(StackReg, FrameSizeVal,
                                   ReturnRegOpnd.getGPR32Reg());
     IsCpRestoreSet = false;
     return false;
   }
 
   if (IDVal == ".set") {
     parseDirectiveSet();
     return false;
   }
 
   if (IDVal == ".mask" || IDVal == ".fmask") {
     // .mask bitmask, frame_offset
     // bitmask: One bit for each register used.
     // frame_offset: Offset from Canonical Frame Address ($sp on entry) where
     //               first register is expected to be saved.
     // Examples:
     //   .mask 0x80000000, -4
     //   .fmask 0x80000000, -4
     //
 
     // Parse the bitmask
     const MCExpr *BitMask;
     int64_t BitMaskVal;
 
     if (Parser.parseExpression(BitMask)) {
       reportParseError("expected bitmask value");
       return false;
     }
 
     if (!BitMask->evaluateAsAbsolute(BitMaskVal)) {
       reportParseError("bitmask not an absolute expression");
       return false;
     }
 
     if (Parser.getTok().is(AsmToken::Comma))
       Parser.Lex();
     else {
       reportParseError("unexpected token, expected comma");
       return false;
     }
 
     // Parse the frame_offset
     const MCExpr *FrameOffset;
     int64_t FrameOffsetVal;
 
     if (Parser.parseExpression(FrameOffset)) {
       reportParseError("expected frame offset value");
       return false;
     }
 
     if (!FrameOffset->evaluateAsAbsolute(FrameOffsetVal)) {
       reportParseError("frame offset not an absolute expression");
       return false;
     }
 
     // If this is not the end of the statement, report an error.
     if (getLexer().isNot(AsmToken::EndOfStatement)) {
       reportParseError("unexpected token, expected end of statement");
       return false;
     }
 
     if (IDVal == ".mask")
       getTargetStreamer().emitMask(BitMaskVal, FrameOffsetVal);
     else
       getTargetStreamer().emitFMask(BitMaskVal, FrameOffsetVal);
     return false;
   }
 
   if (IDVal == ".nan")
     return parseDirectiveNaN();
 
   if (IDVal == ".gpword") {
     parseDirectiveGpWord();
     return false;
   }
 
   if (IDVal == ".gpdword") {
     parseDirectiveGpDWord();
     return false;
   }
 
   if (IDVal == ".dtprelword") {
     parseDirectiveDtpRelWord();
     return false;
   }
 
   if (IDVal == ".dtpreldword") {
     parseDirectiveDtpRelDWord();
     return false;
   }
 
   if (IDVal == ".tprelword") {
     parseDirectiveTpRelWord();
     return false;
   }
 
   if (IDVal == ".tpreldword") {
     parseDirectiveTpRelDWord();
     return false;
   }
 
   if (IDVal == ".option") {
     parseDirectiveOption();
     return false;
   }
 
   if (IDVal == ".abicalls") {
     getTargetStreamer().emitDirectiveAbiCalls();
     if (Parser.getTok().isNot(AsmToken::EndOfStatement)) {
       Error(Parser.getTok().getLoc(),
             "unexpected token, expected end of statement");
     }
     return false;
   }
 
   if (IDVal == ".cpsetup") {
     parseDirectiveCPSetup();
     return false;
   }
   if (IDVal == ".cpreturn") {
     parseDirectiveCPReturn();
     return false;
   }
   if (IDVal == ".module") {
     parseDirectiveModule();
     return false;
   }
   if (IDVal == ".llvm_internal_mips_reallow_module_directive") {
     parseInternalDirectiveReallowModule();
     return false;
   }
   if (IDVal == ".insn") {
     parseInsnDirective();
     return false;
   }
   if (IDVal == ".rdata") {
     parseRSectionDirective(".rodata");
     return false;
   }
   if (IDVal == ".sbss") {
     parseSSectionDirective(IDVal, ELF::SHT_NOBITS);
     return false;
   }
   if (IDVal == ".sdata") {
     parseSSectionDirective(IDVal, ELF::SHT_PROGBITS);
     return false;
   }
 
   return true;
 }
 
 bool MipsAsmParser::parseInternalDirectiveReallowModule() {
   // If this is not the end of the statement, report an error.
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     reportParseError("unexpected token, expected end of statement");
     return false;
   }
 
   getTargetStreamer().reallowModuleDirective();
 
   getParser().Lex(); // Eat EndOfStatement token.
   return false;
 }
 
 extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeMipsAsmParser() {
   RegisterMCAsmParser<MipsAsmParser> X(getTheMipsTarget());
   RegisterMCAsmParser<MipsAsmParser> Y(getTheMipselTarget());
   RegisterMCAsmParser<MipsAsmParser> A(getTheMips64Target());
   RegisterMCAsmParser<MipsAsmParser> B(getTheMips64elTarget());
 }
 
 #define GET_REGISTER_MATCHER
 #define GET_MATCHER_IMPLEMENTATION
 #define GET_MNEMONIC_SPELL_CHECKER
 #include "MipsGenAsmMatcher.inc"
 
 bool MipsAsmParser::mnemonicIsValid(StringRef Mnemonic, unsigned VariantID) {
   // Find the appropriate table for this asm variant.
   const MatchEntry *Start, *End;
   switch (VariantID) {
   default: llvm_unreachable("invalid variant!");
   case 0: Start = std::begin(MatchTable0); End = std::end(MatchTable0); break;
   }
   // Search the table.
   auto MnemonicRange = std::equal_range(Start, End, Mnemonic, LessOpcode());
   return MnemonicRange.first != MnemonicRange.second;
 }
diff --git a/llvm/lib/Target/Mips/Mips16InstrInfo.td b/llvm/lib/Target/Mips/Mips16InstrInfo.td
index c4a43d44b7c4..c874b59a3253 100644
--- a/llvm/lib/Target/Mips/Mips16InstrInfo.td
+++ b/llvm/lib/Target/Mips/Mips16InstrInfo.td
@@ -1,1891 +1,1891 @@
 //===- Mips16InstrInfo.td - Target Description for Mips16  -*- tablegen -*-=//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 //
 // This file describes Mips16 instructions.
 //
 //===----------------------------------------------------------------------===//
 //
 //
 // Mips Address
 //
 def addr16 : ComplexPattern<iPTR, 2, "selectAddr16", [frameindex]>;
 def addr16sp : ComplexPattern<iPTR, 2, "selectAddr16SP", [frameindex]>;
 
 //
 // Address operand
 def mem16 : Operand<i32> {
   let PrintMethod = "printMemOperand";
   let MIOperandInfo = (ops CPU16Regs, simm16);
   let EncoderMethod = "getMemEncoding";
 }
 
 def mem16sp : Operand<i32> {
   let PrintMethod = "printMemOperand";
   // This should be CPUSPReg but the MIPS16 subtarget isn't good enough at
   // keeping the sp-relative load and the other varieties separate at the
   // moment. This lie fixes the problem sufficiently well to fix the errors
   // emitted by -verify-machineinstrs and the output ends up correct as long
   // as we use an external assembler (which is already a requirement for MIPS16
   // for several other reasons).
   let MIOperandInfo = (ops CPU16RegsPlusSP, simm16);
   let EncoderMethod = "getMemEncoding";
 }
 
 def mem16_ea : Operand<i32> {
   let PrintMethod = "printMemOperandEA";
   let MIOperandInfo = (ops CPU16RegsPlusSP, simm16);
   let EncoderMethod = "getMemEncoding";
 }
 
 def pcrel16 : Operand<i32>;
 
 //
 // I-type instruction format
 //
 // this is only used by bimm. the actual assembly value is a 12 bit signed
 // number
 //
 class FI16_ins<bits<5> op, string asmstr, InstrItinClass itin>:
   FI16<op, (outs), (ins brtarget:$imm16),
             !strconcat(asmstr, "\t$imm16 # 16 bit inst"), [], itin>;
 
 //
 //
 // I8 instruction format
 //
 
 class FI816_ins_base<bits<3> _func, string asmstr,
                      string asmstr2, InstrItinClass itin>:
   FI816<_func, (outs), (ins simm16:$imm), !strconcat(asmstr, asmstr2),
         [], itin>;
 
 class FI816_ins<bits<3> _func, string asmstr,
                 InstrItinClass itin>:
   FI816_ins_base<_func, asmstr, "\t$imm  # 16 bit inst", itin>;
 
 class FI816_SP_ins<bits<3> _func, string asmstr,
                    InstrItinClass itin>:
   FI816_ins_base<_func, asmstr, "\t$$sp, $imm # 16 bit inst", itin>;
 
 //
 // RI instruction format
 //
 
 
 class FRI16_ins_base<bits<5> op, string asmstr, string asmstr2,
                      InstrItinClass itin>:
   FRI16<op, (outs CPU16Regs:$rx), (ins simm16:$imm),
         !strconcat(asmstr, asmstr2), [], itin>;
 
 class FRI16_ins<bits<5> op, string asmstr,
                 InstrItinClass itin>:
   FRI16_ins_base<op, asmstr, "\t$rx, $imm \t# 16 bit inst", itin>;
 
 class FRI16_TCP_ins<bits<5> _op, string asmstr,
                     InstrItinClass itin>:
   FRI16<_op, (outs CPU16Regs:$rx), (ins pcrel16:$imm, i32imm:$size),
             !strconcat(asmstr, "\t$rx, $imm\t# 16 bit inst"), [], itin>;
 
 class FRI16R_ins_base<bits<5> op, string asmstr, string asmstr2,
                      InstrItinClass itin>:
   FRI16<op, (outs), (ins CPU16Regs:$rx, simm16:$imm),
         !strconcat(asmstr, asmstr2), [], itin>;
 
 class FRI16R_ins<bits<5> op, string asmstr,
                 InstrItinClass itin>:
   FRI16R_ins_base<op, asmstr, "\t$rx, $imm \t# 16 bit inst", itin>;
 
 class F2RI16_ins<bits<5> _op, string asmstr,
                      InstrItinClass itin>:
   FRI16<_op, (outs CPU16Regs:$rx), (ins CPU16Regs:$rx_, simm16:$imm),
         !strconcat(asmstr, "\t$rx, $imm\t# 16 bit inst"), [], itin> {
   let Constraints = "$rx_ = $rx";
 }
 
 class FRI16_B_ins<bits<5> _op, string asmstr,
                   InstrItinClass itin>:
   FRI16<_op, (outs), (ins  CPU16Regs:$rx, brtarget:$imm),
         !strconcat(asmstr, "\t$rx, $imm  # 16 bit inst"), [], itin>;
 //
 // Compare a register and immediate and place result in CC
 // Implicit use of T8
 //
 // EXT-CCRR Instruction format
 //
 class FEXT_CCRXI16_ins<string asmstr>:
   MipsPseudo16<(outs CPU16Regs:$cc), (ins CPU16Regs:$rx, simm16:$imm),
                !strconcat(asmstr, "\t$rx, $imm\n\tmove\t$cc, $$t8"), []> {
   let isCodeGenOnly=1;
   let usesCustomInserter = 1;
 }
 
 // JAL and JALX instruction format
 //
 class FJAL16_ins<bits<1> _X, string asmstr,
                  InstrItinClass itin>:
   FJAL16<_X, (outs), (ins uimm26:$imm),
          !strconcat(asmstr, "\t$imm\n\tnop"),[],
          itin>  {
   let isCodeGenOnly=1;
   let Size=6;
 }
 
 class FJALB16_ins<bits<1> _X, string asmstr,
                  InstrItinClass itin>:
   FJAL16<_X, (outs), (ins uimm26:$imm),
          !strconcat(asmstr, "\t$imm\t# branch\n\tnop"),[],
          itin>  {
   let isCodeGenOnly=1;
   let Size=6;
 }
 
 //
 // EXT-I instruction format
 //
 class FEXT_I16_ins<bits<5> eop, string asmstr, InstrItinClass itin> :
   FEXT_I16<eop, (outs), (ins brtarget:$imm16),
            !strconcat(asmstr, "\t$imm16"),[], itin>;
 
 //
 // EXT-I8 instruction format
 //
 
 class FEXT_I816_ins_base<bits<3> _func, string asmstr,
                          string asmstr2, InstrItinClass itin>:
   FEXT_I816<_func, (outs), (ins simm16:$imm), !strconcat(asmstr, asmstr2),
             [], itin>;
 
 class FEXT_I816_ins<bits<3> _func, string asmstr,
                     InstrItinClass itin>:
   FEXT_I816_ins_base<_func, asmstr, "\t$imm", itin>;
 
 class FEXT_I816_SP_ins<bits<3> _func, string asmstr,
                        InstrItinClass itin>:
       FEXT_I816_ins_base<_func, asmstr, "\t$$sp, $imm", itin>;
 
 //
 // Assembler formats in alphabetical order.
 // Natural and pseudos are mixed together.
 //
 // Compare two registers and place result in CC
 // Implicit use of T8
 //
 // CC-RR Instruction format
 //
 class FCCRR16_ins<string asmstr> :
   MipsPseudo16<(outs CPU16Regs:$cc), (ins CPU16Regs:$rx, CPU16Regs:$ry),
                !strconcat(asmstr, "\t$rx, $ry\n\tmove\t$cc, $$t8"), []> {
   let isCodeGenOnly=1;
   let usesCustomInserter = 1;
 }
 
 //
 // EXT-RI instruction format
 //
 
 class FEXT_RI16_ins_base<bits<5> _op, string asmstr, string asmstr2,
                          InstrItinClass itin>:
   FEXT_RI16<_op, (outs CPU16Regs:$rx), (ins simm16:$imm),
                   !strconcat(asmstr, asmstr2), [], itin>;
 
 class FEXT_RI16_ins<bits<5> _op, string asmstr,
                     InstrItinClass itin>:
   FEXT_RI16_ins_base<_op, asmstr, "\t$rx, $imm", itin>;
 
 class FEXT_RI16R_ins_base<bits<5> _op, string asmstr, string asmstr2,
                          InstrItinClass itin>:
   FEXT_RI16<_op, (outs ), (ins CPU16Regs:$rx, simm16:$imm),
                   !strconcat(asmstr, asmstr2), [], itin>;
 
 class FEXT_RI16R_ins<bits<5> _op, string asmstr,
                     InstrItinClass itin>:
   FEXT_RI16R_ins_base<_op, asmstr, "\t$rx, $imm", itin>;
 
 class FEXT_RI16_PC_ins<bits<5> _op, string asmstr, InstrItinClass itin>:
   FEXT_RI16_ins_base<_op, asmstr, "\t$rx, $$pc, $imm", itin>;
 
 class FEXT_RI16_B_ins<bits<5> _op, string asmstr,
                       InstrItinClass itin>:
   FEXT_RI16<_op, (outs), (ins  CPU16Regs:$rx, brtarget:$imm),
             !strconcat(asmstr, "\t$rx, $imm"), [], itin>;
 
 class FEXT_RI16_TCP_ins<bits<5> _op, string asmstr,
                         InstrItinClass itin>:
   FEXT_RI16<_op, (outs CPU16Regs:$rx), (ins pcrel16:$imm, i32imm:$size),
             !strconcat(asmstr, "\t$rx, $imm"), [], itin>;
 
 class FEXT_2RI16_ins<bits<5> _op, string asmstr,
                      InstrItinClass itin>:
   FEXT_RI16<_op, (outs CPU16Regs:$rx), (ins CPU16Regs:$rx_, simm16:$imm),
             !strconcat(asmstr, "\t$rx, $imm"), [], itin> {
   let Constraints = "$rx_ = $rx";
 }
 
 //
 // EXT-RRI instruction format
 //
 
 class FEXT_RRI16_mem_ins<bits<5> op, string asmstr, Operand MemOpnd,
                          InstrItinClass itin>:
   FEXT_RRI16<op, (outs CPU16Regs:$ry), (ins  MemOpnd:$addr),
              !strconcat(asmstr, "\t$ry, $addr"), [], itin>;
 
 class FEXT_RRI16_mem2_ins<bits<5> op, string asmstr, Operand MemOpnd,
                           InstrItinClass itin>:
   FEXT_RRI16<op, (outs ), (ins  CPU16Regs:$ry, MemOpnd:$addr),
              !strconcat(asmstr, "\t$ry, $addr"), [], itin>;
 
 //
 //
 // EXT-RRI-A instruction format
 //
 
 class FEXT_RRI_A16_mem_ins<bits<1> op, string asmstr, Operand MemOpnd,
                            InstrItinClass itin>:
   FEXT_RRI_A16<op, (outs CPU16Regs:$ry), (ins  MemOpnd:$addr),
                !strconcat(asmstr, "\t$ry, $addr"), [], itin>;
 
 //
 // EXT-SHIFT instruction format
 //
 class FEXT_SHIFT16_ins<bits<2> _f, string asmstr, InstrItinClass itin>:
   FEXT_SHIFT16<_f, (outs CPU16Regs:$rx), (ins CPU16Regs:$ry, uimm5:$sa),
                !strconcat(asmstr, "\t$rx, $ry, $sa"), [], itin>;
 
 //
 // EXT-T8I8
 //
 class FEXT_T8I816_ins<string asmstr, string asmstr2>:
   MipsPseudo16<(outs),
                (ins CPU16Regs:$rx, CPU16Regs:$ry, brtarget:$imm),
                !strconcat(asmstr2, !strconcat("\t$rx, $ry\n\t",
                !strconcat(asmstr, "\t$imm"))),[]> {
   let isCodeGenOnly=1;
   let usesCustomInserter = 1;
 }
 
 //
 // EXT-T8I8I
 //
 class FEXT_T8I8I16_ins<string asmstr, string asmstr2>:
   MipsPseudo16<(outs),
                (ins CPU16Regs:$rx, simm16:$imm, brtarget:$targ),
                !strconcat(asmstr2, !strconcat("\t$rx, $imm\n\t",
                !strconcat(asmstr, "\t$targ"))), []> {
   let isCodeGenOnly=1;
   let usesCustomInserter = 1;
 }
 //
 
 
 //
 // I8_MOVR32 instruction format (used only by the MOVR32 instructio
 //
 class FI8_MOVR3216_ins<string asmstr, InstrItinClass itin>:
        FI8_MOVR3216<(outs CPU16Regs:$rz), (ins GPR32:$r32),
        !strconcat(asmstr,  "\t$rz, $r32"), [], itin>;
 
 //
 // I8_MOV32R instruction format (used only by MOV32R instruction)
 //
 
 class FI8_MOV32R16_ins<string asmstr, InstrItinClass itin>:
   FI8_MOV32R16<(outs GPR32:$r32), (ins CPU16Regs:$rz),
                !strconcat(asmstr,  "\t$r32, $rz"), [], itin>;
 
 //
 // RR-type instruction format
 //
 
 class FRR16_ins<bits<5> f, string asmstr, InstrItinClass itin> :
   FRR16<f, (outs CPU16Regs:$rx), (ins CPU16Regs:$ry),
         !strconcat(asmstr, "\t$rx, $ry"), [], itin> {
 }
 
 class FRRBreakNull16_ins<string asmstr, InstrItinClass itin> :
   FRRBreak16<(outs), (ins), asmstr, [], itin> {
   let Code=0;
 }
 
 class FRR16R_ins<bits<5> f, string asmstr, InstrItinClass itin> :
   FRR16<f, (outs), (ins  CPU16Regs:$rx, CPU16Regs:$ry),
         !strconcat(asmstr, "\t$rx, $ry"), [], itin> {
 }
 
 class FRRTR16_ins<string asmstr> :
   MipsPseudo16<(outs CPU16Regs:$rz), (ins CPU16Regs:$rx, CPU16Regs:$ry),
                !strconcat(asmstr, "\t$rx, $ry\n\tmove\t$rz, $$t8"), []> ;
 
 //
 // maybe refactor but need a $zero as a dummy first parameter
 //
 class FRR16_div_ins<bits<5> f, string asmstr, InstrItinClass itin> :
   FRR16<f, (outs ), (ins CPU16Regs:$rx, CPU16Regs:$ry),
         !strconcat(asmstr, "\t$$zero, $rx, $ry"), [], itin> ;
 
 class FRR16_mult_ins<bits<5> f, string asmstr, InstrItinClass itin> :
   FRR16<f, (outs ), (ins CPU16Regs:$rx, CPU16Regs:$ry),
         !strconcat(asmstr, "\t$rx, $ry"), [], itin> ;
 
 class FUnaryRR16_ins<bits<5> f, string asmstr, InstrItinClass itin> :
   FRR16<f, (outs CPU16Regs:$rx), (ins CPU16Regs:$ry),
         !strconcat(asmstr, "\t$rx, $ry"), [], itin> ;
 
 
 class FRR16_M_ins<bits<5> f, string asmstr,
                   InstrItinClass itin> :
   FRR16<f, (outs CPU16Regs:$rx), (ins),
         !strconcat(asmstr, "\t$rx"), [], itin>;
 
 class FRxRxRy16_ins<bits<5> f, string asmstr,
                     InstrItinClass itin> :
-  FRR16<f, (outs CPU16Regs:$rz), (ins CPU16Regs:$rx, CPU16Regs:$ry),
+  FRR16<f, (outs CPU16Opnd:$rz), (ins CPU16Opnd:$rx, CPU16Opnd:$ry),
             !strconcat(asmstr, "\t$rz, $ry"),
             [], itin> {
   let Constraints = "$rx = $rz";
 }
 
 let rx=0 in
 class FRR16_JALRC_RA_only_ins<bits<1> nd_, bits<1> l_,
                               string asmstr, InstrItinClass itin>:
   FRR16_JALRC<nd_, l_, 1, (outs), (ins), !strconcat(asmstr, "\t$$ra"),
               [], itin> ;
 
 
 class FRR16_JALRC_ins<bits<1> nd, bits<1> l, bits<1> ra,
                       string asmstr, InstrItinClass itin>:
   FRR16_JALRC<nd, l, ra, (outs), (ins CPU16Regs:$rx),
               !strconcat(asmstr, "\t$rx"), [], itin> ;
 
 class FRR_SF16_ins
   <bits<5> _funct, bits<3> _subfunc,
     string asmstr, InstrItinClass itin>:
   FRR_SF16<_funct, _subfunc, (outs CPU16Regs:$rx), (ins CPU16Regs:$rx_),
            !strconcat(asmstr, "\t $rx"),
            [], itin> {
   let Constraints = "$rx_ = $rx";
   }
 //
 // RRR-type instruction format
 //
 
 class FRRR16_ins<bits<2> _f, string asmstr,  InstrItinClass itin> :
   FRRR16<_f, (outs CPU16Regs:$rz), (ins CPU16Regs:$rx, CPU16Regs:$ry),
          !strconcat(asmstr, "\t$rz, $rx, $ry"), [], itin>;
 
 //
 // These Sel patterns support the generation of conditional move
 // pseudo instructions.
 //
 // The nomenclature uses the components making up the pseudo and may
 // be a bit counter intuitive when compared with the end result we seek.
 // For example using a bqez in the example directly below results in the
 // conditional move being done if the tested register is not zero.
 // I considered in easier to check by keeping the pseudo consistent with
 // it's components but it could have been done differently.
 //
 // The simplest case is when can test and operand directly and do the
 // conditional move based on a simple mips16 conditional
 //  branch instruction.
 // for example:
 // if $op == beqz or bnez:
 //
 // $op1 $rt, .+4
 // move $rd, $rs
 //
 // if $op == beqz, then if $rt != 0, then the conditional assignment
 // $rd = $rs is done.
 
 // if $op == bnez, then if $rt == 0, then the conditional assignment
 // $rd = $rs is done.
 //
 // So this pseudo class only has one operand, i.e. op
 //
 class Sel<string op>:
   MipsPseudo16<(outs CPU16Regs:$rd_), (ins CPU16Regs:$rd, CPU16Regs:$rs,
                CPU16Regs:$rt),
                !strconcat(op, "\t$rt, .+4\n\t\n\tmove $rd, $rs"), []> {
   //let isCodeGenOnly=1;
   let Constraints = "$rd = $rd_";
   let usesCustomInserter = 1;
 }
 
 //
 // The next two instruction classes allow for an operand which tests
 // two operands and returns a value in register T8 and
 //then does a conditional branch based on the value of T8
 //
 
 // op2 can be cmpi or slti/sltiu
 // op1 can bteqz or btnez
 // the operands for op2 are a register and a signed constant
 //
 // $op2 $t, $imm  ;test register t and branch conditionally
 // $op1 .+4       ;op1 is a conditional branch
 // move $rd, $rs
 //
 //
 class SeliT<string op1, string op2>:
   MipsPseudo16<(outs CPU16Regs:$rd_), (ins CPU16Regs:$rd, CPU16Regs:$rs,
                                        CPU16Regs:$rl, simm16:$imm),
                !strconcat(op2,
                !strconcat("\t$rl, $imm\n\t",
                !strconcat(op1, "\t.+4\n\tmove $rd, $rs"))), []> {
   let isCodeGenOnly=1;
   let Constraints = "$rd = $rd_";
   let usesCustomInserter = 1;
 }
 
 //
 // op2 can be cmp or slt/sltu
 // op1 can be bteqz or btnez
 // the operands for op2 are two registers
 // op1 is a conditional branch
 //
 //
 // $op2 $rl, $rr  ;test registers rl,rr
 // $op1 .+4       ;op2 is a conditional branch
 // move $rd, $rs
 //
 //
 class SelT<string op1, string op2>:
   MipsPseudo16<(outs CPU16Regs:$rd_),
                (ins CPU16Regs:$rd, CPU16Regs:$rs,
                 CPU16Regs:$rl, CPU16Regs:$rr),
                !strconcat(op2,
                !strconcat("\t$rl, $rr\n\t",
                !strconcat(op1, "\t.+4\n\tmove $rd, $rs"))), []> {
   let isCodeGenOnly=1;
   let Constraints = "$rd = $rd_";
   let usesCustomInserter = 1;
 }
 
 //
 // 32 bit constant
 //
 def Constant32 : MipsPseudo16<(outs), (ins simm32:$imm), "\t.word $imm", []>;
 
 def LwConstant32 :
   MipsPseudo16<(outs CPU16Regs:$rx), (ins simm32:$imm, simm32:$constid),
                "lw\t$rx, 1f\n\tb\t2f\n\t.align\t2\n1: \t.word\t$imm\n2:", []>;
 
 //
 // Some general instruction class info
 //
 //
 
 class ArithLogic16Defs<bit isCom=0> {
   bits<5> shamt = 0;
   bit isCommutable = isCom;
   bit isReMaterializable = 1;
   bit hasSideEffects = 0;
 }
 
 class branch16 {
   bit isBranch = 1;
   bit isTerminator = 1;
   bit isBarrier = 1;
 }
 
 class cbranch16 {
   bit isBranch = 1;
   bit isTerminator = 1;
 }
 
 class MayLoad {
   bit mayLoad = 1;
 }
 
 class MayStore {
   bit mayStore = 1;
 }
 //
 
 
 // Format: ADDIU rx, immediate MIPS16e
 // Purpose: Add Immediate Unsigned Word (2-Operand, Extended)
 // To add a constant to a 32-bit integer.
 //
 def AddiuRxImmX16: FEXT_RI16_ins<0b01001, "addiu", IIM16Alu>;
 
 def AddiuRxRxImm16: F2RI16_ins<0b01001, "addiu", IIM16Alu>,
   ArithLogic16Defs<0> {
   let AddedComplexity = 5;
 }
 def AddiuRxRxImmX16: FEXT_2RI16_ins<0b01001, "addiu", IIM16Alu>,
   ArithLogic16Defs<0> {
   let isCodeGenOnly = 1;
 }
 
 def AddiuRxRyOffMemX16:
   FEXT_RRI_A16_mem_ins<0, "addiu", mem16_ea, IIM16Alu>;
 
 //
 
 // Format: ADDIU rx, pc, immediate MIPS16e
 // Purpose: Add Immediate Unsigned Word (3-Operand, PC-Relative, Extended)
 // To add a constant to the program counter.
 //
 def AddiuRxPcImmX16: FEXT_RI16_PC_ins<0b00001, "addiu", IIM16Alu>;
 
 //
 // Format: ADDIU sp, immediate MIPS16e
 // Purpose: Add Immediate Unsigned Word (2-Operand, SP-Relative, Extended)
 // To add a constant to the stack pointer.
 //
 def AddiuSpImm16
   : FI816_SP_ins<0b011, "addiu", IIM16Alu> {
   let Defs = [SP];
   let Uses = [SP];
   let AddedComplexity = 5;
 }
 
 def AddiuSpImmX16
   : FEXT_I816_SP_ins<0b011, "addiu", IIM16Alu> {
   let Defs = [SP];
   let Uses = [SP];
 }
 
 //
 // Format: ADDU rz, rx, ry MIPS16e
 // Purpose: Add Unsigned Word (3-Operand)
 // To add 32-bit integers.
 //
 
 def AdduRxRyRz16: FRRR16_ins<01, "addu", IIM16Alu>, ArithLogic16Defs<1>;
 
 //
 // Format: AND rx, ry MIPS16e
 // Purpose: AND
 // To do a bitwise logical AND.
 
 def AndRxRxRy16: FRxRxRy16_ins<0b01100, "and", IIM16Alu>, ArithLogic16Defs<1>;
 
 
 //
 // Format: BEQZ rx, offset MIPS16e
 // Purpose: Branch on Equal to Zero
 // To test a GPR then do a PC-relative conditional branch.
 //
 def BeqzRxImm16: FRI16_B_ins<0b00100, "beqz", IIM16Alu>, cbranch16;
 
 
 //
 // Format: BEQZ rx, offset MIPS16e
 // Purpose: Branch on Equal to Zero (Extended)
 // To test a GPR then do a PC-relative conditional branch.
 //
 def BeqzRxImmX16: FEXT_RI16_B_ins<0b00100, "beqz", IIM16Alu>, cbranch16;
 
 //
 // Format: B offset MIPS16e
 // Purpose: Unconditional Branch (Extended)
 // To do an unconditional PC-relative branch.
 //
 
 def Bimm16: FI16_ins<0b00010, "b", IIM16Alu>, branch16;
 
 // Format: B offset MIPS16e
 // Purpose: Unconditional Branch
 // To do an unconditional PC-relative branch.
 //
 def BimmX16: FEXT_I16_ins<0b00010, "b", IIM16Alu>, branch16;
 
 //
 // Format: BNEZ rx, offset MIPS16e
 // Purpose: Branch on Not Equal to Zero
 // To test a GPR then do a PC-relative conditional branch.
 //
 def BnezRxImm16: FRI16_B_ins<0b00101, "bnez", IIM16Alu>, cbranch16;
 
 //
 // Format: BNEZ rx, offset MIPS16e
 // Purpose: Branch on Not Equal to Zero (Extended)
 // To test a GPR then do a PC-relative conditional branch.
 //
 def BnezRxImmX16: FEXT_RI16_B_ins<0b00101, "bnez", IIM16Alu>, cbranch16;
 
 
 //
 //Format: BREAK immediate
 // Purpose: Breakpoint
 // To cause a Breakpoint exception.
 
 def Break16: FRRBreakNull16_ins<"break 0", IIM16Alu>;
 //
 // Format: BTEQZ offset MIPS16e
 // Purpose: Branch on T Equal to Zero (Extended)
 // To test special register T then do a PC-relative conditional branch.
 //
 def Bteqz16: FI816_ins<0b000, "bteqz", IIM16Alu>, cbranch16 {
   let Uses = [T8];
 }
 
 def BteqzX16: FEXT_I816_ins<0b000, "bteqz", IIM16Alu>, cbranch16 {
   let Uses = [T8];
 }
 
 def BteqzT8CmpX16: FEXT_T8I816_ins<"bteqz", "cmp">, cbranch16;
 
 def BteqzT8CmpiX16: FEXT_T8I8I16_ins<"bteqz", "cmpi">,
   cbranch16;
 
 def BteqzT8SltX16: FEXT_T8I816_ins<"bteqz", "slt">, cbranch16;
 
 def BteqzT8SltuX16: FEXT_T8I816_ins<"bteqz", "sltu">, cbranch16;
 
 def BteqzT8SltiX16: FEXT_T8I8I16_ins<"bteqz", "slti">, cbranch16;
 
 def BteqzT8SltiuX16: FEXT_T8I8I16_ins<"bteqz", "sltiu">,
   cbranch16;
 
 //
 // Format: BTNEZ offset MIPS16e
 // Purpose: Branch on T Not Equal to Zero (Extended)
 // To test special register T then do a PC-relative conditional branch.
 //
 
 def Btnez16: FI816_ins<0b001, "btnez", IIM16Alu>, cbranch16 {
   let Uses = [T8];
 }
 
 def BtnezX16: FEXT_I816_ins<0b001, "btnez", IIM16Alu> ,cbranch16 {
   let Uses = [T8];
 }
 
 def BtnezT8CmpX16: FEXT_T8I816_ins<"btnez", "cmp">, cbranch16;
 
 def BtnezT8CmpiX16: FEXT_T8I8I16_ins<"btnez", "cmpi">, cbranch16;
 
 def BtnezT8SltX16: FEXT_T8I816_ins<"btnez", "slt">, cbranch16;
 
 def BtnezT8SltuX16: FEXT_T8I816_ins<"btnez", "sltu">, cbranch16;
 
 def BtnezT8SltiX16: FEXT_T8I8I16_ins<"btnez", "slti">, cbranch16;
 
 def BtnezT8SltiuX16: FEXT_T8I8I16_ins<"btnez", "sltiu">,
   cbranch16;
 
 //
 // Format: CMP rx, ry MIPS16e
 // Purpose: Compare
 // To compare the contents of two GPRs.
 //
 def CmpRxRy16: FRR16R_ins<0b01010, "cmp", IIM16Alu> {
   let Defs = [T8];
 }
 
 //
 // Format: CMPI rx, immediate MIPS16e
 // Purpose: Compare Immediate
 // To compare a constant with the contents of a GPR.
 //
 def CmpiRxImm16: FRI16R_ins<0b01110, "cmpi", IIM16Alu> {
   let Defs = [T8];
 }
 
 //
 // Format: CMPI rx, immediate MIPS16e
 // Purpose: Compare Immediate (Extended)
 // To compare a constant with the contents of a GPR.
 //
 def CmpiRxImmX16: FEXT_RI16R_ins<0b01110, "cmpi", IIM16Alu> {
   let Defs = [T8];
 }
 
 
 //
 // Format: DIV rx, ry MIPS16e
 // Purpose: Divide Word
 // To divide 32-bit signed integers.
 //
 def DivRxRy16: FRR16_div_ins<0b11010, "div", IIM16Alu> {
   let Defs = [HI0, LO0];
 }
 
 //
 // Format: DIVU rx, ry MIPS16e
 // Purpose: Divide Unsigned Word
 // To divide 32-bit unsigned integers.
 //
 def DivuRxRy16: FRR16_div_ins<0b11011, "divu", IIM16Alu> {
   let Defs = [HI0, LO0];
 }
 
 //
 // Format: JAL target MIPS16e
 // Purpose: Jump and Link
 // To execute a procedure call within the current 256 MB-aligned
 // region and preserve the current ISA.
 //
 
 def Jal16 : FJAL16_ins<0b0, "jal", IIM16Alu> {
   let hasDelaySlot = 0;  // not true, but we add the nop for now
   let isCall=1;
   let Defs = [RA];
 }
 
 def JalB16 : FJALB16_ins<0b0, "jal", IIM16Alu>, branch16 {
   let hasDelaySlot = 0;  // not true, but we add the nop for now
   let isBranch=1;
   let Defs = [RA];
 }
 
 //
 // Format: JR ra MIPS16e
 // Purpose: Jump Register Through Register ra
 // To execute a branch to the instruction address in the return
 // address register.
 //
 
 def JrRa16: FRR16_JALRC_RA_only_ins<0, 0, "jr", IIM16Alu> {
   let isBranch = 1;
   let isIndirectBranch = 1;
   let hasDelaySlot = 1;
   let isTerminator=1;
   let isBarrier=1;
   let isReturn=1;
 }
 
 def JrcRa16: FRR16_JALRC_RA_only_ins<1, 1, "jrc", IIM16Alu> {
   let isBranch = 1;
   let isIndirectBranch = 1;
   let isTerminator=1;
   let isBarrier=1;
   let isReturn=1;
 }
 
 def JrcRx16: FRR16_JALRC_ins<1, 1, 0, "jrc", IIM16Alu> {
   let isBranch = 1;
   let isIndirectBranch = 1;
   let isTerminator=1;
   let isBarrier=1;
 }
 //
 // Format: LB ry, offset(rx) MIPS16e
 // Purpose: Load Byte (Extended)
 // To load a byte from memory as a signed value.
 //
 def LbRxRyOffMemX16: FEXT_RRI16_mem_ins<0b10011, "lb", mem16, II_LB>, MayLoad{
   let isCodeGenOnly = 1;
 }
 
 //
 // Format: LBU ry, offset(rx) MIPS16e
 // Purpose: Load Byte Unsigned (Extended)
 // To load a byte from memory as a unsigned value.
 //
 def LbuRxRyOffMemX16:
   FEXT_RRI16_mem_ins<0b10100, "lbu", mem16, II_LBU>, MayLoad {
   let isCodeGenOnly = 1;
 }
 
 //
 // Format: LH ry, offset(rx) MIPS16e
 // Purpose: Load Halfword signed (Extended)
 // To load a halfword from memory as a signed value.
 //
 def LhRxRyOffMemX16: FEXT_RRI16_mem_ins<0b10100, "lh", mem16, II_LH>, MayLoad{
   let isCodeGenOnly = 1;
 }
 
 //
 // Format: LHU ry, offset(rx) MIPS16e
 // Purpose: Load Halfword unsigned (Extended)
 // To load a halfword from memory as an unsigned value.
 //
 def LhuRxRyOffMemX16:
   FEXT_RRI16_mem_ins<0b10100, "lhu", mem16, II_LHU>, MayLoad {
   let isCodeGenOnly = 1;
 }
 
 //
 // Format: LI rx, immediate MIPS16e
 // Purpose: Load Immediate
 // To load a constant into a GPR.
 //
 def LiRxImm16: FRI16_ins<0b01101, "li", IIM16Alu>;
 
 //
 // Format: LI rx, immediate MIPS16e
 // Purpose: Load Immediate (Extended)
 // To load a constant into a GPR.
 //
 def LiRxImmX16: FEXT_RI16_ins<0b01101, "li", IIM16Alu>;
 
 def LiRxImmAlignX16: FEXT_RI16_ins<0b01101, ".align 2\n\tli", IIM16Alu> {
   let isCodeGenOnly = 1;
 }
 
 //
 // Format: LW ry, offset(rx) MIPS16e
 // Purpose: Load Word (Extended)
 // To load a word from memory as a signed value.
 //
 def LwRxRyOffMemX16: FEXT_RRI16_mem_ins<0b10011, "lw", mem16, II_LW>, MayLoad{
   let isCodeGenOnly = 1;
 }
 
 // Format: LW rx, offset(sp) MIPS16e
 // Purpose: Load Word (SP-Relative, Extended)
 // To load an SP-relative word from memory as a signed value.
 //
 def LwRxSpImmX16: FEXT_RRI16_mem_ins<0b10010, "lw", mem16sp, II_LW>, MayLoad;
 
 def LwRxPcTcp16: FRI16_TCP_ins<0b10110, "lw", II_LW>, MayLoad;
 
 def LwRxPcTcpX16: FEXT_RI16_TCP_ins<0b10110, "lw", II_LW>, MayLoad;
 //
 // Format: MOVE r32, rz MIPS16e
 // Purpose: Move
 // To move the contents of a GPR to a GPR.
 //
 def Move32R16: FI8_MOV32R16_ins<"move", IIM16Alu>;
 
 //
 // Format: MOVE ry, r32 MIPS16e
 //Purpose: Move
 // To move the contents of a GPR to a GPR.
 //
 def MoveR3216: FI8_MOVR3216_ins<"move", IIM16Alu> {
   let isMoveReg = 1;
 }
 
 //
 // Format: MFHI rx MIPS16e
 // Purpose: Move From HI Register
 // To copy the special purpose HI register to a GPR.
 //
 def Mfhi16: FRR16_M_ins<0b10000, "mfhi", IIM16Alu> {
   let Uses = [HI0];
   let hasSideEffects = 0;
   let isMoveReg = 1;
 }
 
 //
 // Format: MFLO rx MIPS16e
 // Purpose: Move From LO Register
 // To copy the special purpose LO register to a GPR.
 //
 def Mflo16: FRR16_M_ins<0b10010, "mflo", IIM16Alu> {
   let Uses = [LO0];
   let hasSideEffects = 0;
   let isMoveReg = 0;
 }
 
 //
 // Format: MULT rx, ry MIPS16e
 // Purpose: Multiply Word
 // To multiply 32-bit signed integers.
 //
 def MultRxRy16: FRR16_mult_ins<0b11000, "mult", IIM16Alu> {
   let Defs = [HI0, LO0];
 }
 
 //
 // Format: MULTU rx, ry MIPS16e
 // Purpose: Multiply Unsigned Word
 // To multiply 32-bit unsigned integers.
 //
 def MultuRxRy16: FRR16_mult_ins<0b11001, "multu", IIM16Alu> {
   let Defs = [HI0, LO0];
 }
 
 
 //
 // Format: NEG rx, ry MIPS16e
 // Purpose: Negate
 // To negate an integer value.
 //
 def NegRxRy16: FUnaryRR16_ins<0b11101, "neg", IIM16Alu>;
 
 //
 // Format: NOT rx, ry MIPS16e
 // Purpose: Not
 // To complement an integer value
 //
 def NotRxRy16: FUnaryRR16_ins<0b01111, "not", IIM16Alu>;
 
 //
 // Format: OR rx, ry MIPS16e
 // Purpose: Or
 // To do a bitwise logical OR.
 //
 def OrRxRxRy16: FRxRxRy16_ins<0b01101, "or", IIM16Alu>, ArithLogic16Defs<1>;
 
 //
 // Format: RESTORE {ra,}{s0/s1/s0-1,}{framesize}
 // (All args are optional) MIPS16e
 // Purpose: Restore Registers and Deallocate Stack Frame
 // To deallocate a stack frame before exit from a subroutine,
 // restoring return address and static registers, and adjusting
 // stack
 //
 
 def Restore16:
   FI8_SVRS16<0b1, (outs), (ins variable_ops),
              "", [], II_RESTORE >, MayLoad {
   let isCodeGenOnly = 1;
   let Defs = [SP];
   let Uses = [SP];
 }
 
 
 def RestoreX16:
   FI8_SVRS16<0b1, (outs), (ins variable_ops),
              "", [], II_RESTORE >, MayLoad {
   let isCodeGenOnly = 1;
   let Defs = [SP];
   let Uses = [SP];
 }
 
 //
 // Format: SAVE {ra,}{s0/s1/s0-1,}{framesize} (All arguments are optional)
 // MIPS16e
 // Purpose: Save Registers and Set Up Stack Frame
 // To set up a stack frame on entry to a subroutine,
 // saving return address and static registers, and adjusting stack
 //
 def Save16:
   FI8_SVRS16<0b1, (outs), (ins variable_ops),
              "", [], II_SAVE >, MayStore {
   let isCodeGenOnly = 1;
   let Uses = [SP];
   let Defs = [SP];
 }
 
 def SaveX16:
   FI8_SVRS16<0b1, (outs), (ins variable_ops),
              "", [], II_SAVE >, MayStore {
   let isCodeGenOnly = 1;
   let Uses = [SP];
   let Defs = [SP];
 }
 //
 // Format: SB ry, offset(rx) MIPS16e
 // Purpose: Store Byte (Extended)
 // To store a byte to memory.
 //
 def SbRxRyOffMemX16:
   FEXT_RRI16_mem2_ins<0b11000, "sb", mem16, II_SB>, MayStore;
 
 //
 // Format: SEB rx MIPS16e
 // Purpose: Sign-Extend Byte
 // Sign-extend least significant byte in register rx.
 //
 def SebRx16
   : FRR_SF16_ins<0b10001, 0b100, "seb", IIM16Alu>;
 
 //
 // Format: SEH rx MIPS16e
 // Purpose: Sign-Extend Halfword
 // Sign-extend least significant word in register rx.
 //
 def SehRx16
   : FRR_SF16_ins<0b10001, 0b101, "seh", IIM16Alu>;
 
 //
 // The Sel(T) instructions are pseudos
 // T means that they use T8 implicitly.
 //
 //
 // Format: SelBeqZ rd, rs, rt
 // Purpose: if rt==0, do nothing
 //          else rs = rt
 //
 def SelBeqZ: Sel<"beqz">;
 
 //
 // Format:  SelTBteqZCmp rd, rs, rl, rr
 // Purpose: b = Cmp rl, rr.
 //          If b==0 then do nothing.
 //          if b!=0 then rd = rs
 //
 def SelTBteqZCmp: SelT<"bteqz", "cmp">;
 
 //
 // Format:  SelTBteqZCmpi rd, rs, rl, rr
 // Purpose: b = Cmpi rl, imm.
 //          If b==0 then do nothing.
 //          if b!=0 then rd = rs
 //
 def SelTBteqZCmpi: SeliT<"bteqz", "cmpi">;
 
 //
 // Format:  SelTBteqZSlt rd, rs, rl, rr
 // Purpose: b = Slt rl, rr.
 //          If b==0 then do nothing.
 //          if b!=0 then rd = rs
 //
 def SelTBteqZSlt: SelT<"bteqz", "slt">;
 
 //
 // Format:  SelTBteqZSlti rd, rs, rl, rr
 // Purpose: b = Slti rl, imm.
 //          If b==0 then do nothing.
 //          if b!=0 then rd = rs
 //
 def SelTBteqZSlti: SeliT<"bteqz", "slti">;
 
 //
 // Format:  SelTBteqZSltu rd, rs, rl, rr
 // Purpose: b = Sltu rl, rr.
 //          If b==0 then do nothing.
 //          if b!=0 then rd = rs
 //
 def SelTBteqZSltu: SelT<"bteqz", "sltu">;
 
 //
 // Format:  SelTBteqZSltiu rd, rs, rl, rr
 // Purpose: b = Sltiu rl, imm.
 //          If b==0 then do nothing.
 //          if b!=0 then rd = rs
 //
 def SelTBteqZSltiu: SeliT<"bteqz", "sltiu">;
 
 //
 // Format: SelBnez rd, rs, rt
 // Purpose: if rt!=0, do nothing
 //          else rs = rt
 //
 def SelBneZ: Sel<"bnez">;
 
 //
 // Format:  SelTBtneZCmp rd, rs, rl, rr
 // Purpose: b = Cmp rl, rr.
 //          If b!=0 then do nothing.
 //          if b0=0 then rd = rs
 //
 def SelTBtneZCmp: SelT<"btnez", "cmp">;
 
 //
 // Format:  SelTBtnezCmpi rd, rs, rl, rr
 // Purpose: b = Cmpi rl, imm.
 //          If b!=0 then do nothing.
 //          if b==0 then rd = rs
 //
 def SelTBtneZCmpi: SeliT<"btnez", "cmpi">;
 
 //
 // Format:  SelTBtneZSlt rd, rs, rl, rr
 // Purpose: b = Slt rl, rr.
 //          If b!=0 then do nothing.
 //          if b==0 then rd = rs
 //
 def SelTBtneZSlt: SelT<"btnez", "slt">;
 
 //
 // Format:  SelTBtneZSlti rd, rs, rl, rr
 // Purpose: b = Slti rl, imm.
 //          If b!=0 then do nothing.
 //          if b==0 then rd = rs
 //
 def SelTBtneZSlti: SeliT<"btnez", "slti">;
 
 //
 // Format:  SelTBtneZSltu rd, rs, rl, rr
 // Purpose: b = Sltu rl, rr.
 //          If b!=0 then do nothing.
 //          if b==0 then rd = rs
 //
 def SelTBtneZSltu: SelT<"btnez", "sltu">;
 
 //
 // Format:  SelTBtneZSltiu rd, rs, rl, rr
 // Purpose: b = Slti rl, imm.
 //          If b!=0 then do nothing.
 //          if b==0 then rd = rs
 //
 def SelTBtneZSltiu: SeliT<"btnez", "sltiu">;
 //
 //
 // Format: SH ry, offset(rx) MIPS16e
 // Purpose: Store Halfword (Extended)
 // To store a halfword to memory.
 //
 def ShRxRyOffMemX16:
   FEXT_RRI16_mem2_ins<0b11001, "sh", mem16, II_SH>, MayStore;
 
 //
 // Format: SLL rx, ry, sa MIPS16e
 // Purpose: Shift Word Left Logical (Extended)
 // To execute a left-shift of a word by a fixed number of bits-0 to 31 bits.
 //
 def SllX16: FEXT_SHIFT16_ins<0b00, "sll", IIM16Alu>;
 
 //
 // Format: SLLV ry, rx MIPS16e
 // Purpose: Shift Word Left Logical Variable
 // To execute a left-shift of a word by a variable number of bits.
 //
 def SllvRxRy16 : FRxRxRy16_ins<0b00100, "sllv", IIM16Alu>;
 
 // Format: SLTI rx, immediate MIPS16e
 // Purpose: Set on Less Than Immediate
 // To record the result of a less-than comparison with a constant.
 //
 //
 def SltiRxImm16: FRI16R_ins<0b01010, "slti", IIM16Alu> {
   let Defs = [T8];
 }
 
 //
 // Format: SLTI rx, immediate MIPS16e
 // Purpose: Set on Less Than Immediate (Extended)
 // To record the result of a less-than comparison with a constant.
 //
 //
 def SltiRxImmX16: FEXT_RI16R_ins<0b01010, "slti", IIM16Alu> {
   let Defs = [T8];
 }
 
 def SltiCCRxImmX16: FEXT_CCRXI16_ins<"slti">;
 
 // Format: SLTIU rx, immediate MIPS16e
 // Purpose: Set on Less Than Immediate Unsigned
 // To record the result of a less-than comparison with a constant.
 //
 //
 def SltiuRxImm16: FRI16R_ins<0b01011, "sltiu", IIM16Alu> {
   let Defs = [T8];
 }
 
 //
 // Format: SLTI rx, immediate MIPS16e
 // Purpose: Set on Less Than Immediate Unsigned (Extended)
 // To record the result of a less-than comparison with a constant.
 //
 //
 def SltiuRxImmX16: FEXT_RI16R_ins<0b01011, "sltiu", IIM16Alu> {
   let Defs = [T8];
 }
 //
 // Format: SLTIU rx, immediate MIPS16e
 // Purpose: Set on Less Than Immediate Unsigned (Extended)
 // To record the result of a less-than comparison with a constant.
 //
 def SltiuCCRxImmX16: FEXT_CCRXI16_ins<"sltiu">;
 
 //
 // Format: SLT rx, ry MIPS16e
 // Purpose: Set on Less Than
 // To record the result of a less-than comparison.
 //
 def SltRxRy16: FRR16R_ins<0b00010, "slt", IIM16Alu>{
   let Defs = [T8];
 }
 
 def SltCCRxRy16: FCCRR16_ins<"slt">;
 
 // Format: SLTU rx, ry MIPS16e
 // Purpose: Set on Less Than Unsigned
 // To record the result of an unsigned less-than comparison.
 //
 def SltuRxRy16: FRR16R_ins<0b00011, "sltu", IIM16Alu>{
   let Defs = [T8];
 }
 
 def SltuRxRyRz16: FRRTR16_ins<"sltu"> {
   let isCodeGenOnly=1;
   let Defs = [T8];
 }
 
 
 def SltuCCRxRy16: FCCRR16_ins<"sltu">;
 //
 // Format: SRAV ry, rx MIPS16e
 // Purpose: Shift Word Right Arithmetic Variable
 // To execute an arithmetic right-shift of a word by a variable
 // number of bits.
 //
 def SravRxRy16: FRxRxRy16_ins<0b00111, "srav", IIM16Alu>;
 
 
 //
 // Format: SRA rx, ry, sa MIPS16e
 // Purpose: Shift Word Right Arithmetic (Extended)
 // To execute an arithmetic right-shift of a word by a fixed
 // number of bits-1 to 8 bits.
 //
 def SraX16: FEXT_SHIFT16_ins<0b11, "sra", IIM16Alu>;
 
 
 //
 // Format: SRLV ry, rx MIPS16e
 // Purpose: Shift Word Right Logical Variable
 // To execute a logical right-shift of a word by a variable
 // number of bits.
 //
 def SrlvRxRy16: FRxRxRy16_ins<0b00110, "srlv", IIM16Alu>;
 
 
 //
 // Format: SRL rx, ry, sa MIPS16e
 // Purpose: Shift Word Right Logical (Extended)
 // To execute a logical right-shift of a word by a fixed
 // number of bits-1 to 31 bits.
 //
 def SrlX16: FEXT_SHIFT16_ins<0b10, "srl", IIM16Alu>;
 
 //
 // Format: SUBU rz, rx, ry MIPS16e
 // Purpose: Subtract Unsigned Word
 // To subtract 32-bit integers
 //
 def SubuRxRyRz16: FRRR16_ins<0b11, "subu", IIM16Alu>, ArithLogic16Defs<0>;
 
 //
 // Format: SW ry, offset(rx) MIPS16e
 // Purpose: Store Word (Extended)
 // To store a word to memory.
 //
 def SwRxRyOffMemX16: FEXT_RRI16_mem2_ins<0b11011, "sw", mem16, II_SW>, MayStore;
 
 //
 // Format: SW rx, offset(sp) MIPS16e
 // Purpose: Store Word rx (SP-Relative)
 // To store an SP-relative word to memory.
 //
 def SwRxSpImmX16: FEXT_RRI16_mem2_ins<0b11010, "sw", mem16sp, II_SW>, MayStore;
 
 //
 //
 // Format: XOR rx, ry MIPS16e
 // Purpose: Xor
 // To do a bitwise logical XOR.
 //
 def XorRxRxRy16: FRxRxRy16_ins<0b01110, "xor", IIM16Alu>, ArithLogic16Defs<1>;
 
 class Mips16Pat<dag pattern, dag result> : Pat<pattern, result> {
   let Predicates = [InMips16Mode];
 }
 
 // Unary Arith/Logic
 //
 class ArithLogicU_pat<PatFrag OpNode, Instruction I> :
   Mips16Pat<(OpNode CPU16Regs:$r),
             (I CPU16Regs:$r)>;
 
 def: ArithLogicU_pat<not, NotRxRy16>;
 def: ArithLogicU_pat<ineg, NegRxRy16>;
 
 class ArithLogic16_pat<SDNode OpNode, Instruction I> :
   Mips16Pat<(OpNode CPU16Regs:$l, CPU16Regs:$r),
             (I CPU16Regs:$l, CPU16Regs:$r)>;
 
 def: ArithLogic16_pat<add, AdduRxRyRz16>;
 def: ArithLogic16_pat<and, AndRxRxRy16>;
 def: ArithLogic16_pat<or, OrRxRxRy16>;
 def: ArithLogic16_pat<sub, SubuRxRyRz16>;
 def: ArithLogic16_pat<xor, XorRxRxRy16>;
 
 // Arithmetic and logical instructions with 2 register operands.
 
 class ArithLogicI16_pat<SDNode OpNode, PatFrag imm_type, Instruction I> :
   Mips16Pat<(OpNode CPU16Regs:$in, imm_type:$imm),
             (I CPU16Regs:$in, imm_type:$imm)>;
 
 def: ArithLogicI16_pat<add, immSExt8, AddiuRxRxImm16>;
 def: ArithLogicI16_pat<add, immSExt16, AddiuRxRxImmX16>;
 def: ArithLogicI16_pat<shl, immZExt5, SllX16>;
 def: ArithLogicI16_pat<srl, immZExt5, SrlX16>;
 def: ArithLogicI16_pat<sra, immZExt5, SraX16>;
 
 class shift_rotate_reg16_pat<SDNode OpNode, Instruction I> :
   Mips16Pat<(OpNode CPU16Regs:$r, CPU16Regs:$ra),
             (I CPU16Regs:$r, CPU16Regs:$ra)>;
 
 def: shift_rotate_reg16_pat<shl, SllvRxRy16>;
 def: shift_rotate_reg16_pat<sra, SravRxRy16>;
 def: shift_rotate_reg16_pat<srl, SrlvRxRy16>;
 
 class LoadM16_pat<PatFrag OpNode, Instruction I, ComplexPattern Addr> :
   Mips16Pat<(OpNode Addr:$addr), (I Addr:$addr)>;
 
 def: LoadM16_pat<sextloadi8, LbRxRyOffMemX16, addr16>;
 def: LoadM16_pat<zextloadi8, LbuRxRyOffMemX16, addr16>;
 def: LoadM16_pat<sextloadi16, LhRxRyOffMemX16, addr16>;
 def: LoadM16_pat<zextloadi16, LhuRxRyOffMemX16, addr16>;
 def: LoadM16_pat<load, LwRxSpImmX16, addr16sp>;
 
 class StoreM16_pat<PatFrag OpNode, Instruction I, ComplexPattern Addr> :
   Mips16Pat<(OpNode CPU16Regs:$r, Addr:$addr), (I CPU16Regs:$r, Addr:$addr)>;
 
 def: StoreM16_pat<truncstorei8, SbRxRyOffMemX16, addr16>;
 def: StoreM16_pat<truncstorei16, ShRxRyOffMemX16, addr16>;
 def: StoreM16_pat<store, SwRxSpImmX16, addr16sp>;
 
 // Unconditional branch
 class UncondBranch16_pat<SDNode OpNode, Instruction I>:
   Mips16Pat<(OpNode bb:$imm16), (I bb:$imm16)> {
     let Predicates = [InMips16Mode];
   }
 
 def : Mips16Pat<(MipsJmpLink (i32 tglobaladdr:$dst)),
                 (Jal16 tglobaladdr:$dst)>;
 
 def : Mips16Pat<(MipsJmpLink (i32 texternalsym:$dst)),
                 (Jal16 texternalsym:$dst)>;
 
 // Indirect branch
 def: Mips16Pat<(brind CPU16Regs:$rs), (JrcRx16 CPU16Regs:$rs)> {
   // Ensure that the addition of MIPS32r6/MIPS64r6 support does not change
   // MIPS16's behaviour.
   let AddedComplexity = 1;
 }
 
 // Jump and Link (Call)
 let isCall=1, hasDelaySlot=0 in
 def JumpLinkReg16:
   FRR16_JALRC<0, 0, 0, (outs), (ins CPU16Regs:$rs),
               "jalrc\t$rs", [(MipsJmpLink CPU16Regs:$rs)], II_JALRC> {
   let Defs = [RA];
 }
 
 // Mips16 pseudos
 let isReturn=1, isTerminator=1, hasDelaySlot=1, isBarrier=1, hasCtrlDep=1,
   hasExtraSrcRegAllocReq = 1 in
 def RetRA16 : MipsPseudo16<(outs), (ins), "", [(MipsRet)]>;
 
 
 // setcc patterns
 
 class SetCC_R16<PatFrag cond_op, Instruction I>:
   Mips16Pat<(cond_op CPU16Regs:$rx, CPU16Regs:$ry),
             (I CPU16Regs:$rx, CPU16Regs:$ry)>;
 
 class SetCC_I16<PatFrag cond_op, PatLeaf imm_type, Instruction I>:
   Mips16Pat<(cond_op CPU16Regs:$rx, imm_type:$imm16),
             (I CPU16Regs:$rx, imm_type:$imm16)>;
 
 
 def: Mips16Pat<(i32 addr16sp:$addr), (AddiuRxRyOffMemX16 addr16sp:$addr)>;
 
 
 // Large (>16 bit) immediate loads
 def : Mips16Pat<(i32 imm:$imm), (LwConstant32 imm:$imm, -1)>;
 
 //
 // Some branch conditional patterns are not generated by llvm at this time.
 // Some are for seemingly arbitrary reasons not used: i.e. with signed number
 // comparison they are used and for unsigned a different pattern is used.
 // I am pushing upstream from the full mips16 port and it seemed that I needed
 // these earlier and the mips32 port has these but now I cannot create test
 // cases that use these patterns. While I sort this all out I will leave these
 // extra patterns commented out and if I can be sure they are really not used,
 // I will delete the code. I don't want to check the code in uncommented without
 // a valid test case. In some cases, the compiler is generating patterns with
 // setcc instead and earlier I had implemented setcc first so may have masked
 // the problem. The setcc variants are suboptimal for mips16 so I may wantto
 // figure out how to enable the brcond patterns or else possibly new
 // combinations of brcond and setcc.
 //
 //
 // bcond-seteq
 //
 def: Mips16Pat
   <(brcond (i32 (seteq CPU16Regs:$rx, CPU16Regs:$ry)), bb:$imm16),
    (BteqzT8CmpX16 CPU16Regs:$rx, CPU16Regs:$ry,  bb:$imm16)
   >;
 
 
 def: Mips16Pat
   <(brcond (i32 (seteq CPU16Regs:$rx, immZExt16:$imm)), bb:$targ16),
    (BteqzT8CmpiX16 CPU16Regs:$rx, immSExt16:$imm,  bb:$targ16)
   >;
 
 def: Mips16Pat
   <(brcond (i32 (seteq CPU16Regs:$rx, 0)), bb:$targ16),
    (BeqzRxImm16 CPU16Regs:$rx, bb:$targ16)
   >;
 
 //
 // bcond-setgt (do we need to have this pair of setlt, setgt??)
 //
 def: Mips16Pat
   <(brcond (i32 (setgt CPU16Regs:$rx, CPU16Regs:$ry)), bb:$imm16),
    (BtnezT8SltX16 CPU16Regs:$ry, CPU16Regs:$rx,  bb:$imm16)
   >;
 
 //
 // bcond-setge
 //
 def: Mips16Pat
   <(brcond (i32 (setge CPU16Regs:$rx, CPU16Regs:$ry)), bb:$imm16),
    (BteqzT8SltX16 CPU16Regs:$rx, CPU16Regs:$ry,  bb:$imm16)
   >;
 
 //
 // never called because compiler transforms a >= k to a > (k-1)
 def: Mips16Pat
   <(brcond (i32 (setge CPU16Regs:$rx, immSExt16:$imm)), bb:$imm16),
    (BteqzT8SltiX16 CPU16Regs:$rx, immSExt16:$imm,  bb:$imm16)
   >;
 
 //
 // bcond-setlt
 //
 def: Mips16Pat
   <(brcond (i32 (setlt CPU16Regs:$rx, CPU16Regs:$ry)), bb:$imm16),
    (BtnezT8SltX16 CPU16Regs:$rx, CPU16Regs:$ry,  bb:$imm16)
   >;
 
 def: Mips16Pat
   <(brcond (i32 (setlt CPU16Regs:$rx, immSExt16:$imm)), bb:$imm16),
    (BtnezT8SltiX16 CPU16Regs:$rx, immSExt16:$imm,  bb:$imm16)
   >;
 
 //
 // bcond-setle
 //
 def: Mips16Pat
   <(brcond (i32 (setle CPU16Regs:$rx, CPU16Regs:$ry)), bb:$imm16),
    (BteqzT8SltX16 CPU16Regs:$ry, CPU16Regs:$rx,  bb:$imm16)
   >;
 
 //
 // bcond-setne
 //
 def: Mips16Pat
   <(brcond (i32 (setne CPU16Regs:$rx, CPU16Regs:$ry)), bb:$imm16),
    (BtnezT8CmpX16 CPU16Regs:$rx, CPU16Regs:$ry,  bb:$imm16)
   >;
 
 def: Mips16Pat
   <(brcond (i32 (setne CPU16Regs:$rx, immZExt16:$imm)), bb:$targ16),
    (BtnezT8CmpiX16 CPU16Regs:$rx, immSExt16:$imm,  bb:$targ16)
   >;
 
 def: Mips16Pat
   <(brcond (i32 (setne CPU16Regs:$rx, 0)), bb:$targ16),
    (BnezRxImm16 CPU16Regs:$rx, bb:$targ16)
   >;
 
 //
 // This needs to be there but I forget which code will generate it
 //
 def: Mips16Pat
   <(brcond CPU16Regs:$rx, bb:$targ16),
    (BnezRxImm16 CPU16Regs:$rx, bb:$targ16)
   >;
 
 //
 
 //
 // bcond-setugt
 //
 //def: Mips16Pat
 //  <(brcond (i32 (setugt CPU16Regs:$rx, CPU16Regs:$ry)), bb:$imm16),
 //   (BtnezT8SltuX16 CPU16Regs:$ry, CPU16Regs:$rx,  bb:$imm16)
 //  >;
 
 //
 // bcond-setuge
 //
 //def: Mips16Pat
 //  <(brcond (i32 (setuge CPU16Regs:$rx, CPU16Regs:$ry)), bb:$imm16),
 //   (BteqzT8SltuX16 CPU16Regs:$rx, CPU16Regs:$ry,  bb:$imm16)
 //  >;
 
 
 //
 // bcond-setult
 //
 //def: Mips16Pat
 //  <(brcond (i32 (setult CPU16Regs:$rx, CPU16Regs:$ry)), bb:$imm16),
 //   (BtnezT8SltuX16 CPU16Regs:$rx, CPU16Regs:$ry,  bb:$imm16)
 //  >;
 
 def: UncondBranch16_pat<br, Bimm16>;
 
 // Small immediates
 def: Mips16Pat<(i32 immSExt16:$in),
                (AddiuRxRxImmX16 (MoveR3216 ZERO), immSExt16:$in)>;
 
 def: Mips16Pat<(i32 immZExt16:$in), (LiRxImmX16 immZExt16:$in)>;
 
 //
 // MipsDivRem
 //
 def: Mips16Pat
   <(MipsDivRem16 CPU16Regs:$rx, CPU16Regs:$ry),
    (DivRxRy16 CPU16Regs:$rx, CPU16Regs:$ry)>;
 
 //
 // MipsDivRemU
 //
 def: Mips16Pat
   <(MipsDivRemU16 CPU16Regs:$rx, CPU16Regs:$ry),
    (DivuRxRy16 CPU16Regs:$rx, CPU16Regs:$ry)>;
 
 //
 // MipsMult
 //
 def: Mips16Pat
   <(MipsMult16 CPU16Regs:$rx, CPU16Regs:$ry),
    (MultRxRy16 CPU16Regs:$rx, CPU16Regs:$ry)>;
 
 //
 // MipsMultu
 //
 def: Mips16Pat
   <(MipsMultu16 CPU16Regs:$rx, CPU16Regs:$ry),
    (MultuRxRy16 CPU16Regs:$rx, CPU16Regs:$ry)>;
 
 //  signed a,b
 //  x = (a>=b)?x:y
 //
 //  if !(a < b) x = y
 //
 def : Mips16Pat<(select (i32 (setge CPU16Regs:$a, CPU16Regs:$b)),
                  CPU16Regs:$x, CPU16Regs:$y),
                 (SelTBteqZSlt CPU16Regs:$x, CPU16Regs:$y,
                  CPU16Regs:$a, CPU16Regs:$b)>;
 
 //  signed a,b
 //  x = (a>b)?x:y
 //
 //  if  (b < a) x = y
 //
 def : Mips16Pat<(select (i32 (setgt CPU16Regs:$a, CPU16Regs:$b)),
                  CPU16Regs:$x, CPU16Regs:$y),
                 (SelTBtneZSlt CPU16Regs:$x, CPU16Regs:$y,
                  CPU16Regs:$b, CPU16Regs:$a)>;
 
 // unsigned a,b
 // x = (a>=b)?x:y
 //
 // if !(a < b) x = y;
 //
 def : Mips16Pat<
   (select (i32 (setuge CPU16Regs:$a, CPU16Regs:$b)),
    CPU16Regs:$x, CPU16Regs:$y),
   (SelTBteqZSltu CPU16Regs:$x, CPU16Regs:$y,
    CPU16Regs:$a, CPU16Regs:$b)>;
 
 //  unsigned a,b
 //  x = (a>b)?x:y
 //
 //  if (b < a) x = y
 //
 def : Mips16Pat<(select (i32 (setugt CPU16Regs:$a, CPU16Regs:$b)),
                  CPU16Regs:$x, CPU16Regs:$y),
                 (SelTBtneZSltu CPU16Regs:$x, CPU16Regs:$y,
                  CPU16Regs:$b, CPU16Regs:$a)>;
 
 // signed
 // x = (a >= k)?x:y
 // due to an llvm optimization, i don't think that this will ever
 // be used. This is transformed into x = (a > k-1)?x:y
 //
 //
 
 //def : Mips16Pat<
 //  (select (i32 (setge CPU16Regs:$lhs, immSExt16:$rhs)),
 //   CPU16Regs:$T, CPU16Regs:$F),
 //  (SelTBteqZSlti CPU16Regs:$T, CPU16Regs:$F,
 //   CPU16Regs:$lhs, immSExt16:$rhs)>;
 
 //def : Mips16Pat<
 //  (select (i32 (setuge CPU16Regs:$lhs, immSExt16:$rhs)),
 //   CPU16Regs:$T, CPU16Regs:$F),
 //  (SelTBteqZSltiu CPU16Regs:$T, CPU16Regs:$F,
 //   CPU16Regs:$lhs, immSExt16:$rhs)>;
 
 // signed
 // x = (a < k)?x:y
 //
 // if !(a < k) x = y;
 //
 def : Mips16Pat<
   (select (i32 (setlt CPU16Regs:$a, immSExt16:$b)),
    CPU16Regs:$x, CPU16Regs:$y),
   (SelTBtneZSlti CPU16Regs:$x, CPU16Regs:$y,
    CPU16Regs:$a, immSExt16:$b)>;
 
 
 //
 //
 // signed
 // x = (a <= b)? x : y
 //
 // if  (b < a) x = y
 //
 def : Mips16Pat<(select (i32 (setle CPU16Regs:$a, CPU16Regs:$b)),
                  CPU16Regs:$x, CPU16Regs:$y),
                 (SelTBteqZSlt CPU16Regs:$x, CPU16Regs:$y,
                  CPU16Regs:$b, CPU16Regs:$a)>;
 
 //
 // unsigned
 // x = (a <= b)? x : y
 //
 // if  (b < a) x = y
 //
 def : Mips16Pat<(select (i32 (setule CPU16Regs:$a, CPU16Regs:$b)),
                  CPU16Regs:$x, CPU16Regs:$y),
                 (SelTBteqZSltu CPU16Regs:$x, CPU16Regs:$y,
                  CPU16Regs:$b, CPU16Regs:$a)>;
 
 //
 // signed/unsigned
 // x = (a == b)? x : y
 //
 // if (a != b) x = y
 //
 def : Mips16Pat<(select (i32 (seteq CPU16Regs:$a, CPU16Regs:$b)),
                  CPU16Regs:$x, CPU16Regs:$y),
                 (SelTBteqZCmp CPU16Regs:$x, CPU16Regs:$y,
                  CPU16Regs:$b, CPU16Regs:$a)>;
 
 //
 // signed/unsigned
 // x = (a == 0)? x : y
 //
 // if (a != 0) x = y
 //
 def : Mips16Pat<(select (i32 (seteq CPU16Regs:$a, 0)),
                  CPU16Regs:$x, CPU16Regs:$y),
                 (SelBeqZ CPU16Regs:$x, CPU16Regs:$y,
                  CPU16Regs:$a)>;
 
 
 //
 // signed/unsigned
 // x = (a == k)? x : y
 //
 // if (a != k) x = y
 //
 def : Mips16Pat<(select (i32 (seteq CPU16Regs:$a, immZExt16:$k)),
                  CPU16Regs:$x, CPU16Regs:$y),
                 (SelTBteqZCmpi CPU16Regs:$x, CPU16Regs:$y,
                  CPU16Regs:$a, immZExt16:$k)>;
 
 
 //
 // signed/unsigned
 // x = (a != b)? x : y
 //
 // if (a == b) x = y
 //
 //
 def : Mips16Pat<(select (i32 (setne CPU16Regs:$a, CPU16Regs:$b)),
                  CPU16Regs:$x, CPU16Regs:$y),
                 (SelTBtneZCmp CPU16Regs:$x, CPU16Regs:$y,
                  CPU16Regs:$b, CPU16Regs:$a)>;
 
 //
 // signed/unsigned
 // x = (a != 0)? x : y
 //
 // if (a == 0) x = y
 //
 def : Mips16Pat<(select (i32 (setne CPU16Regs:$a, 0)),
                  CPU16Regs:$x, CPU16Regs:$y),
                 (SelBneZ CPU16Regs:$x, CPU16Regs:$y,
                  CPU16Regs:$a)>;
 
 // signed/unsigned
 // x = (a)? x : y
 //
 // if (!a) x = y
 //
 def : Mips16Pat<(select  CPU16Regs:$a,
                  CPU16Regs:$x, CPU16Regs:$y),
       (SelBneZ CPU16Regs:$x, CPU16Regs:$y,
        CPU16Regs:$a)>;
 
 
 //
 // signed/unsigned
 // x = (a != k)? x : y
 //
 // if (a == k) x = y
 //
 def : Mips16Pat<(select (i32 (setne CPU16Regs:$a, immZExt16:$k)),
                  CPU16Regs:$x, CPU16Regs:$y),
                 (SelTBtneZCmpi CPU16Regs:$x, CPU16Regs:$y,
                  CPU16Regs:$a, immZExt16:$k)>;
 
 //
 // When writing C code to test setxx these patterns,
 // some will be transformed into
 // other things. So we test using C code but using -O3 and -O0
 //
 // seteq
 //
 def : Mips16Pat
   <(seteq CPU16Regs:$lhs,CPU16Regs:$rhs),
    (SltiuCCRxImmX16 (XorRxRxRy16 CPU16Regs:$lhs, CPU16Regs:$rhs), 1)>;
 
 def : Mips16Pat
   <(seteq CPU16Regs:$lhs, 0),
    (SltiuCCRxImmX16 CPU16Regs:$lhs, 1)>;
 
 
 //
 // setge
 //
 
 def: Mips16Pat
   <(setge CPU16Regs:$lhs, CPU16Regs:$rhs),
    (XorRxRxRy16 (SltCCRxRy16 CPU16Regs:$lhs, CPU16Regs:$rhs),
    (LiRxImmX16 1))>;
 
 //
 // For constants, llvm transforms this to:
 // x > (k - 1) and then reverses the operands to use setlt. So this pattern
 // is not used now by the compiler. (Presumably checking that k-1 does not
 // overflow). The compiler never uses this at the current time, due to
 // other optimizations.
 //
 //def: Mips16Pat
 //  <(setge CPU16Regs:$lhs, immSExt16:$rhs),
 //   (XorRxRxRy16 (SltiCCRxImmX16 CPU16Regs:$lhs, immSExt16:$rhs),
 //   (LiRxImmX16 1))>;
 
 // This catches the x >= -32768 case by transforming it to  x > -32769
 //
 def: Mips16Pat
   <(setgt CPU16Regs:$lhs, -32769),
    (XorRxRxRy16 (SltiCCRxImmX16 CPU16Regs:$lhs, -32768),
    (LiRxImmX16 1))>;
 
 //
 // setgt
 //
 //
 
 def: Mips16Pat
   <(setgt CPU16Regs:$lhs, CPU16Regs:$rhs),
    (SltCCRxRy16 CPU16Regs:$rhs, CPU16Regs:$lhs)>;
 
 //
 // setle
 //
 def: Mips16Pat
   <(setle CPU16Regs:$lhs, CPU16Regs:$rhs),
    (XorRxRxRy16 (SltCCRxRy16 CPU16Regs:$rhs, CPU16Regs:$lhs), (LiRxImm16 1))>;
 
 //
 // setlt
 //
 def: SetCC_R16<setlt, SltCCRxRy16>;
 
 def: SetCC_I16<setlt, immSExt16, SltiCCRxImmX16>;
 
 //
 // setne
 //
 def : Mips16Pat
   <(setne CPU16Regs:$lhs,CPU16Regs:$rhs),
    (SltuCCRxRy16 (LiRxImmX16 0),
    (XorRxRxRy16 CPU16Regs:$lhs, CPU16Regs:$rhs))>;
 
 
 //
 // setuge
 //
 def: Mips16Pat
   <(setuge CPU16Regs:$lhs, CPU16Regs:$rhs),
    (XorRxRxRy16 (SltuCCRxRy16 CPU16Regs:$lhs, CPU16Regs:$rhs),
    (LiRxImmX16 1))>;
 
 // this pattern will never be used because the compiler will transform
 // x >= k to x > (k - 1) and then use SLT
 //
 //def: Mips16Pat
 //  <(setuge CPU16Regs:$lhs, immZExt16:$rhs),
 //   (XorRxRxRy16 (SltiuCCRxImmX16 CPU16Regs:$lhs, immZExt16:$rhs),
 //   (LiRxImmX16 1))>;
 
 //
 // setugt
 //
 def: Mips16Pat
   <(setugt CPU16Regs:$lhs, CPU16Regs:$rhs),
    (SltuCCRxRy16 CPU16Regs:$rhs, CPU16Regs:$lhs)>;
 
 //
 // setule
 //
 def: Mips16Pat
   <(setule CPU16Regs:$lhs, CPU16Regs:$rhs),
    (XorRxRxRy16 (SltuCCRxRy16 CPU16Regs:$rhs, CPU16Regs:$lhs), (LiRxImmX16 1))>;
 
 //
 // setult
 //
 def: SetCC_R16<setult, SltuCCRxRy16>;
 
 def: SetCC_I16<setult, immSExt16, SltiuCCRxImmX16>;
 
 def: Mips16Pat<(add CPU16Regs:$hi, (MipsLo tglobaladdr:$lo)),
                (AddiuRxRxImmX16 CPU16Regs:$hi, tglobaladdr:$lo)>;
 
 // hi/lo relocs
 def : Mips16Pat<(MipsHi tblockaddress:$in),
                 (SllX16 (LiRxImmX16 tblockaddress:$in), 16)>;
 def : Mips16Pat<(MipsHi tglobaladdr:$in),
                 (SllX16 (LiRxImmX16 tglobaladdr:$in), 16)>;
 def : Mips16Pat<(MipsHi tjumptable:$in),
                 (SllX16 (LiRxImmX16 tjumptable:$in), 16)>;
 
 def : Mips16Pat<(MipsLo tblockaddress:$in), (LiRxImmX16 tblockaddress:$in)>;
 
 def : Mips16Pat<(MipsTlsHi tglobaltlsaddr:$in),
                 (SllX16 (LiRxImmX16 tglobaltlsaddr:$in), 16)>;
 
 // wrapper_pic
 class Wrapper16Pat<SDNode node, Instruction ADDiuOp, RegisterClass RC>:
   Mips16Pat<(MipsWrapper RC:$gp, node:$in),
             (ADDiuOp RC:$gp, node:$in)>;
 
 
 def : Wrapper16Pat<tglobaladdr, AddiuRxRxImmX16, CPU16Regs>;
 def : Wrapper16Pat<tglobaltlsaddr, AddiuRxRxImmX16, CPU16Regs>;
 
 def : Mips16Pat<(i32 (extloadi8   addr16:$src)),
                 (LbuRxRyOffMemX16  addr16:$src)>;
 def : Mips16Pat<(i32 (extloadi16  addr16:$src)),
                 (LhuRxRyOffMemX16  addr16:$src)>;
 
 def: Mips16Pat<(trap), (Break16)>;
 
 def : Mips16Pat<(sext_inreg CPU16Regs:$val, i8),
                 (SebRx16 CPU16Regs:$val)>;
 
 def : Mips16Pat<(sext_inreg CPU16Regs:$val, i16),
                 (SehRx16 CPU16Regs:$val)>;
 
 def GotPrologue16:
   MipsPseudo16<
     (outs CPU16Regs:$rh, CPU16Regs:$rl),
     (ins simm16:$immHi, simm16:$immLo),
     "li\t$rh, $immHi\n\taddiu\t$rl, $$pc, $immLo\n ",[]> ;
 
 // An operand for the CONSTPOOL_ENTRY pseudo-instruction.
 def cpinst_operand : Operand<i32> {
   // let PrintMethod = "printCPInstOperand";
 }
 
 // CONSTPOOL_ENTRY - This instruction represents a floating constant pool in
 // the function.  The first operand is the ID# for this instruction, the second
 // is the index into the MachineConstantPool that this is, the third is the
 // size in bytes of this constant pool entry.
 //
 let hasSideEffects = 0, isNotDuplicable = 1 in
 def CONSTPOOL_ENTRY :
 MipsPseudo16<(outs), (ins cpinst_operand:$instid, cpinst_operand:$cpidx,
                       i32imm:$size), "foo", []>;
 
 // Instruction Aliases
 
 let EncodingPredicates = [InMips16Mode] in
 def : MipsInstAlias<"nop", (Move32R16 ZERO, S0)>;
diff --git a/llvm/lib/Target/Mips/MipsRegisterInfo.td b/llvm/lib/Target/Mips/MipsRegisterInfo.td
index 7d4dcca89e31..70fc5ec520a5 100644
--- a/llvm/lib/Target/Mips/MipsRegisterInfo.td
+++ b/llvm/lib/Target/Mips/MipsRegisterInfo.td
@@ -1,758 +1,767 @@
 //===-- MipsRegisterInfo.td - Mips Register defs -----------*- tablegen -*-===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
 //===----------------------------------------------------------------------===//
 //  Declarations that describe the MIPS register file
 //===----------------------------------------------------------------------===//
 let Namespace = "Mips" in {
 def sub_32     : SubRegIndex<32>;
 def sub_64     : SubRegIndex<64>;
 def sub_lo     : SubRegIndex<32>;
 def sub_hi     : SubRegIndex<32, 32>;
 def sub_dsp16_19 : SubRegIndex<4, 16>;
 def sub_dsp20    : SubRegIndex<1, 20>;
 def sub_dsp21    : SubRegIndex<1, 21>;
 def sub_dsp22    : SubRegIndex<1, 22>;
 def sub_dsp23    : SubRegIndex<1, 23>;
 }
 
 class Unallocatable {
   bit isAllocatable = 0;
 }
 
 // We have banks of 32 registers each.
 class MipsReg<bits<16> Enc, string n> : Register<n> {
   let HWEncoding = Enc;
   let Namespace = "Mips";
 }
 
 class MipsRegWithSubRegs<bits<16> Enc, string n, list<Register> subregs>
   : RegisterWithSubRegs<n, subregs> {
   let HWEncoding = Enc;
   let Namespace = "Mips";
 }
 
 // Mips CPU Registers.
 class MipsGPRReg<bits<16> Enc, string n> : MipsReg<Enc, n>;
 
 // Mips 64-bit CPU Registers
 class Mips64GPRReg<bits<16> Enc, string n, list<Register> subregs>
   : MipsRegWithSubRegs<Enc, n, subregs> {
   let SubRegIndices = [sub_32];
 }
 
 // Mips 32-bit FPU Registers
 class FPR<bits<16> Enc, string n> : MipsReg<Enc, n>;
 
 // Mips 64-bit (aliased) FPU Registers
 class AFPR<bits<16> Enc, string n, list<Register> subregs>
   : MipsRegWithSubRegs<Enc, n, subregs> {
   let SubRegIndices = [sub_lo, sub_hi];
   let CoveredBySubRegs = 1;
 }
 
 class AFPR64<bits<16> Enc, string n, list<Register> subregs>
   : MipsRegWithSubRegs<Enc, n, subregs> {
   let SubRegIndices = [sub_lo, sub_hi];
   let CoveredBySubRegs = 1;
 }
 
 // Mips 128-bit (aliased) MSA Registers
 class AFPR128<bits<16> Enc, string n, list<Register> subregs>
   : MipsRegWithSubRegs<Enc, n, subregs> {
   let SubRegIndices = [sub_64];
 }
 
 // Accumulator Registers
 class ACCReg<bits<16> Enc, string n, list<Register> subregs>
   : MipsRegWithSubRegs<Enc, n, subregs> {
   let SubRegIndices = [sub_lo, sub_hi];
   let CoveredBySubRegs = 1;
 }
 
 // Mips Hardware Registers
 class HWR<bits<16> Enc, string n> : MipsReg<Enc, n>;
 
 //===----------------------------------------------------------------------===//
 //  Registers
 //===----------------------------------------------------------------------===//
 
 let Namespace = "Mips" in {
   // General Purpose Registers
   def ZERO : MipsGPRReg< 0, "zero">, DwarfRegNum<[0]>;
   def AT   : MipsGPRReg< 1, "1">,    DwarfRegNum<[1]>;
   def V0   : MipsGPRReg< 2, "2">,    DwarfRegNum<[2]>;
   def V1   : MipsGPRReg< 3, "3">,    DwarfRegNum<[3]>;
   def A0   : MipsGPRReg< 4, "4">,    DwarfRegNum<[4]>;
   def A1   : MipsGPRReg< 5, "5">,    DwarfRegNum<[5]>;
   def A2   : MipsGPRReg< 6, "6">,    DwarfRegNum<[6]>;
   def A3   : MipsGPRReg< 7, "7">,    DwarfRegNum<[7]>;
   def T0   : MipsGPRReg< 8, "8">,    DwarfRegNum<[8]>;
   def T1   : MipsGPRReg< 9, "9">,    DwarfRegNum<[9]>;
   def T2   : MipsGPRReg< 10, "10">,  DwarfRegNum<[10]>;
   def T3   : MipsGPRReg< 11, "11">,  DwarfRegNum<[11]>;
   def T4   : MipsGPRReg< 12, "12">,  DwarfRegNum<[12]>;
   def T5   : MipsGPRReg< 13, "13">,  DwarfRegNum<[13]>;
   def T6   : MipsGPRReg< 14, "14">,  DwarfRegNum<[14]>;
   def T7   : MipsGPRReg< 15, "15">,  DwarfRegNum<[15]>;
   def S0   : MipsGPRReg< 16, "16">,  DwarfRegNum<[16]>;
   def S1   : MipsGPRReg< 17, "17">,  DwarfRegNum<[17]>;
   def S2   : MipsGPRReg< 18, "18">,  DwarfRegNum<[18]>;
   def S3   : MipsGPRReg< 19, "19">,  DwarfRegNum<[19]>;
   def S4   : MipsGPRReg< 20, "20">,  DwarfRegNum<[20]>;
   def S5   : MipsGPRReg< 21, "21">,  DwarfRegNum<[21]>;
   def S6   : MipsGPRReg< 22, "22">,  DwarfRegNum<[22]>;
   def S7   : MipsGPRReg< 23, "23">,  DwarfRegNum<[23]>;
   def T8   : MipsGPRReg< 24, "24">,  DwarfRegNum<[24]>;
   def T9   : MipsGPRReg< 25, "25">,  DwarfRegNum<[25]>;
   def K0   : MipsGPRReg< 26, "26">,  DwarfRegNum<[26]>;
   def K1   : MipsGPRReg< 27, "27">,  DwarfRegNum<[27]>;
   def GP   : MipsGPRReg< 28, "gp">,  DwarfRegNum<[28]>;
   def SP   : MipsGPRReg< 29, "sp">,  DwarfRegNum<[29]>;
   def FP   : MipsGPRReg< 30, "fp">,  DwarfRegNum<[30]>;
   def RA   : MipsGPRReg< 31, "ra">,  DwarfRegNum<[31]>;
 
   // General Purpose 64-bit Registers
   def ZERO_64 : Mips64GPRReg< 0, "zero", [ZERO]>, DwarfRegNum<[0]>;
   def AT_64   : Mips64GPRReg< 1, "1",    [AT]>, DwarfRegNum<[1]>;
   def V0_64   : Mips64GPRReg< 2, "2",    [V0]>, DwarfRegNum<[2]>;
   def V1_64   : Mips64GPRReg< 3, "3",    [V1]>, DwarfRegNum<[3]>;
   def A0_64   : Mips64GPRReg< 4, "4",    [A0]>, DwarfRegNum<[4]>;
   def A1_64   : Mips64GPRReg< 5, "5",    [A1]>, DwarfRegNum<[5]>;
   def A2_64   : Mips64GPRReg< 6, "6",    [A2]>, DwarfRegNum<[6]>;
   def A3_64   : Mips64GPRReg< 7, "7",    [A3]>, DwarfRegNum<[7]>;
   def T0_64   : Mips64GPRReg< 8, "8",    [T0]>, DwarfRegNum<[8]>;
   def T1_64   : Mips64GPRReg< 9, "9",    [T1]>, DwarfRegNum<[9]>;
   def T2_64   : Mips64GPRReg< 10, "10",  [T2]>, DwarfRegNum<[10]>;
   def T3_64   : Mips64GPRReg< 11, "11",  [T3]>, DwarfRegNum<[11]>;
   def T4_64   : Mips64GPRReg< 12, "12",  [T4]>, DwarfRegNum<[12]>;
   def T5_64   : Mips64GPRReg< 13, "13",  [T5]>, DwarfRegNum<[13]>;
   def T6_64   : Mips64GPRReg< 14, "14",  [T6]>, DwarfRegNum<[14]>;
   def T7_64   : Mips64GPRReg< 15, "15",  [T7]>, DwarfRegNum<[15]>;
   def S0_64   : Mips64GPRReg< 16, "16",  [S0]>, DwarfRegNum<[16]>;
   def S1_64   : Mips64GPRReg< 17, "17",  [S1]>, DwarfRegNum<[17]>;
   def S2_64   : Mips64GPRReg< 18, "18",  [S2]>, DwarfRegNum<[18]>;
   def S3_64   : Mips64GPRReg< 19, "19",  [S3]>, DwarfRegNum<[19]>;
   def S4_64   : Mips64GPRReg< 20, "20",  [S4]>, DwarfRegNum<[20]>;
   def S5_64   : Mips64GPRReg< 21, "21",  [S5]>, DwarfRegNum<[21]>;
   def S6_64   : Mips64GPRReg< 22, "22",  [S6]>, DwarfRegNum<[22]>;
   def S7_64   : Mips64GPRReg< 23, "23",  [S7]>, DwarfRegNum<[23]>;
   def T8_64   : Mips64GPRReg< 24, "24",  [T8]>, DwarfRegNum<[24]>;
   def T9_64   : Mips64GPRReg< 25, "25",  [T9]>, DwarfRegNum<[25]>;
   def K0_64   : Mips64GPRReg< 26, "26",  [K0]>, DwarfRegNum<[26]>;
   def K1_64   : Mips64GPRReg< 27, "27",  [K1]>, DwarfRegNum<[27]>;
   def GP_64   : Mips64GPRReg< 28, "gp",  [GP]>, DwarfRegNum<[28]>;
   def SP_64   : Mips64GPRReg< 29, "sp",  [SP]>, DwarfRegNum<[29]>;
   def FP_64   : Mips64GPRReg< 30, "fp",  [FP]>, DwarfRegNum<[30]>;
   def RA_64   : Mips64GPRReg< 31, "ra",  [RA]>, DwarfRegNum<[31]>;
 
   /// Mips Single point precision FPU Registers
   foreach I = 0-31 in
   def F#I : FPR<I, "f"#I>, DwarfRegNum<[!add(I, 32)]>;
 
   // Higher half of 64-bit FP registers.
   foreach I = 0-31 in
   def F_HI#I : FPR<I, "f"#I>, DwarfRegNum<[!add(I, 32)]>;
 
   /// Mips Double point precision FPU Registers (aliased
   /// with the single precision to hold 64 bit values)
   foreach I = 0-15 in
   def D#I : AFPR<!shl(I, 1), "f"#!shl(I, 1),
                  [!cast<FPR>("F"#!shl(I, 1)),
                   !cast<FPR>("F"#!add(!shl(I, 1), 1))]>;
 
   /// Mips Double point precision FPU Registers in MFP64 mode.
   foreach I = 0-31 in
   def D#I#_64 : AFPR64<I, "f"#I, [!cast<FPR>("F"#I), !cast<FPR>("F_HI"#I)]>,
                 DwarfRegNum<[!add(I, 32)]>;
 
   /// Mips MSA registers
   /// MSA and FPU cannot both be present unless the FPU has 64-bit registers
   foreach I = 0-31 in
   def W#I : AFPR128<I, "w"#I, [!cast<AFPR64>("D"#I#"_64")]>,
             DwarfRegNum<[!add(I, 32)]>;
 
   // Hi/Lo registers
   def HI0 : MipsReg<0, "ac0">, DwarfRegNum<[64]>;
   def HI1 : MipsReg<1, "ac1">, DwarfRegNum<[176]>;
   def HI2 : MipsReg<2, "ac2">, DwarfRegNum<[178]>;
   def HI3 : MipsReg<3, "ac3">, DwarfRegNum<[180]>;
   def LO0 : MipsReg<0, "ac0">, DwarfRegNum<[65]>;
   def LO1 : MipsReg<1, "ac1">, DwarfRegNum<[177]>;
   def LO2 : MipsReg<2, "ac2">, DwarfRegNum<[179]>;
   def LO3 : MipsReg<3, "ac3">, DwarfRegNum<[181]>;
 
   let SubRegIndices = [sub_32] in {
   def HI0_64  : RegisterWithSubRegs<"hi", [HI0]>;
   def LO0_64  : RegisterWithSubRegs<"lo", [LO0]>;
   }
 
   // FP control registers.
   foreach I = 0-31 in
   def FCR#I : MipsReg<I, ""#I>;
 
   // FP condition code registers.
   foreach I = 0-7 in
   def FCC#I : MipsReg<I, "fcc"#I>;
 
   // COP0 registers.
   foreach I = 0-31 in
   def COP0#I : MipsReg<I, ""#I>;
 
   // COP2 registers.
   foreach I = 0-31 in
   def COP2#I : MipsReg<I, ""#I>;
 
   // COP3 registers.
   foreach I = 0-31 in
   def COP3#I : MipsReg<I, ""#I>;
 
   // PC register
   def PC : Register<"pc">;
 
   // Hardware registers
   def HWR0 : MipsReg<0, "hwr_cpunum">;
   def HWR1 : MipsReg<1, "hwr_synci_step">;
   def HWR2 : MipsReg<2, "hwr_cc">;
   def HWR3 : MipsReg<3, "hwr_ccres">;
 
   foreach I = 4-31 in
   def HWR#I : MipsReg<I, ""#I>;
 
   // Accum registers
   foreach I = 0-3 in
   def AC#I : ACCReg<I, "ac"#I,
                     [!cast<Register>("LO"#I), !cast<Register>("HI"#I)]>;
 
   def AC0_64 : ACCReg<0, "ac0", [LO0_64, HI0_64]>;
 
   // DSP-ASE control register fields.
   def DSPPos : Register<"">;
   def DSPSCount : Register<"">;
   def DSPCarry : Register<"">;
   def DSPEFI : Register<"">;
   def DSPOutFlag16_19 : Register<"">;
   def DSPOutFlag20 : Register<"">;
   def DSPOutFlag21 : Register<"">;
   def DSPOutFlag22 : Register<"">;
   def DSPOutFlag23 : Register<"">;
   def DSPCCond : Register<"">;
 
   let SubRegIndices = [sub_dsp16_19, sub_dsp20, sub_dsp21, sub_dsp22,
                        sub_dsp23] in
   def DSPOutFlag : RegisterWithSubRegs<"", [DSPOutFlag16_19, DSPOutFlag20,
                                             DSPOutFlag21, DSPOutFlag22,
                                             DSPOutFlag23]>;
 
   // MSA-ASE control registers.
   def MSAIR      : MipsReg<0, "0">;
   def MSACSR     : MipsReg<1, "1">;
   def MSAAccess  : MipsReg<2, "2">;
   def MSASave    : MipsReg<3, "3">;
   def MSAModify  : MipsReg<4, "4">;
   def MSARequest : MipsReg<5, "5">;
   def MSAMap     : MipsReg<6, "6">;
   def MSAUnmap   : MipsReg<7, "7">;
   // MSA-ASE fake control registers.
   // These registers do not exist, but instructions like `cfcmsa`
   // and `ctcmsa` allows to specify them.
   foreach I = 8-31 in
   def MSA#I : MipsReg<I, ""#I>;
 
   // Octeon multiplier and product registers
   def MPL0 : MipsReg<0, "mpl0">;
   def MPL1 : MipsReg<1, "mpl1">;
   def MPL2 : MipsReg<2, "mpl2">;
   def P0 : MipsReg<0, "p0">;
   def P1 : MipsReg<1, "p1">;
   def P2 : MipsReg<2, "p2">;
 
 }
 
 //===----------------------------------------------------------------------===//
 // Register Classes
 //===----------------------------------------------------------------------===//
 
 class GPR32Class<list<ValueType> regTypes> :
   RegisterClass<"Mips", regTypes, 32, (add
   // Reserved
   ZERO, AT,
   // Return Values and Arguments
   V0, V1, A0, A1, A2, A3,
   // Not preserved across procedure calls
   T0, T1, T2, T3, T4, T5, T6, T7,
   // Callee save
   S0, S1, S2, S3, S4, S5, S6, S7,
   // Not preserved across procedure calls
   T8, T9,
   // Reserved
   K0, K1, GP, SP, FP, RA)>;
 
 def GPR32 : GPR32Class<[i32]>;
 
 def GPR32ZERO : RegisterClass<"Mips", [i32], 32, (add
   // Reserved
   ZERO)>;
 
 def GPR32NONZERO : RegisterClass<"Mips", [i32], 32, (add
   // Reserved
   AT,
   // Return Values and Arguments
   V0, V1, A0, A1, A2, A3,
   // Not preserved across procedure calls
   T0, T1, T2, T3, T4, T5, T6, T7,
   // Callee save
   S0, S1, S2, S3, S4, S5, S6, S7,
   // Not preserved across procedure calls
   T8, T9,
   // Reserved
   K0, K1, GP, SP, FP, RA)>;
 
 def DSPR  : GPR32Class<[v4i8, v2i16]>;
 
 def GPRMM16 : RegisterClass<"Mips", [i32], 32, (add
   // Callee save
   S0, S1,
   // Return Values and Arguments
   V0, V1, A0, A1, A2, A3)>;
 
 def GPRMM16Zero : RegisterClass<"Mips", [i32], 32, (add
   // Reserved
   ZERO,
   // Callee save
   S1,
   // Return Values and Arguments
   V0, V1, A0, A1, A2, A3)>;
 
 def GPRMM16MoveP : RegisterClass<"Mips", [i32], 32, (add
   // Reserved
   ZERO,
   // Callee save
   S1,
   // Return Values and Arguments
   V0, V1,
   // Callee save
   S0, S2, S3, S4)>;
 
 def GPRMM16MovePPairFirst : RegisterClass<"Mips", [i32], 32, (add
   // Arguments
   A0, A1, A2)>;
 
 def GPRMM16MovePPairSecond : RegisterClass<"Mips", [i32], 32, (add
   // Arguments
   A1, A2, A3,
   // Callee save
   S5, S6)>;
 
 def GPR64 : RegisterClass<"Mips", [i64], 64, (add
   // Reserved
   ZERO_64, AT_64,
   // Return Values and Arguments
   V0_64, V1_64, A0_64, A1_64, A2_64, A3_64,
   // Not preserved across procedure calls
   T0_64, T1_64, T2_64, T3_64, T4_64, T5_64, T6_64, T7_64,
   // Callee save
   S0_64, S1_64, S2_64, S3_64, S4_64, S5_64, S6_64, S7_64,
   // Not preserved across procedure calls
   T8_64, T9_64,
   // Reserved
   K0_64, K1_64, GP_64, SP_64, FP_64, RA_64)>;
 
 def CPU16Regs : RegisterClass<"Mips", [i32], 32, (add
   // Return Values and Arguments
   V0, V1, A0, A1, A2, A3,
   // Callee save
   S0, S1)>;
 
 def CPU16RegsPlusSP : RegisterClass<"Mips", [i32], 32, (add
   // Return Values and Arguments
   V0, V1, A0, A1, A2, A3,
   // Callee save
   S0, S1,
   SP)>;
 
 def CPURAReg : RegisterClass<"Mips", [i32], 32, (add RA)>, Unallocatable;
 
 def CPUSPReg : RegisterClass<"Mips", [i32], 32, (add SP)>, Unallocatable;
 
 // 64bit fp:
 // * FGR64  - 32 64-bit registers
 // * AFGR64 - 16 32-bit even registers (32-bit FP Mode)
 //
 // 32bit fp:
 // * FGR32 - 16 32-bit even registers
 // * FGR32 - 32 32-bit registers (single float only mode)
 def FGR32 : RegisterClass<"Mips", [f32], 32, (sequence "F%u", 0, 31)> {
   // Do not allocate odd registers when given -mattr=+nooddspreg.
   let AltOrders = [(decimate FGR32, 2)];
   let AltOrderSelect = [{
     const auto & S = MF.getSubtarget<MipsSubtarget>();
     return S.isABI_O32() && !S.useOddSPReg();
   }];
 }
 
 def AFGR64 : RegisterClass<"Mips", [f64], 64, (add
   // Return Values and Arguments
   D0, D1,
   // Not preserved across procedure calls
   D2, D3, D4, D5,
   // Return Values and Arguments
   D6, D7,
   // Not preserved across procedure calls
   D8, D9,
   // Callee save
   D10, D11, D12, D13, D14, D15)>;
 
 def FGR64 : RegisterClass<"Mips", [f64], 64, (sequence "D%u_64", 0, 31)> {
   // Do not allocate odd registers when given -mattr=+nooddspreg.
   let AltOrders = [(decimate FGR64, 2)];
   let AltOrderSelect = [{
     const auto & S = MF.getSubtarget<MipsSubtarget>();
     return S.isABI_O32() && !S.useOddSPReg();
   }];
 }
 
 // FP control registers.
 def CCR : RegisterClass<"Mips", [i32], 32, (sequence "FCR%u", 0, 31)>,
           Unallocatable;
 
 // FP condition code registers.
 def FCC : RegisterClass<"Mips", [i32], 32, (sequence "FCC%u", 0, 7)>,
           Unallocatable;
 
 // MIPS32r6/MIPS64r6 store FPU condition codes in normal FGR registers.
 // This class allows us to represent this in codegen patterns.
 def FGRCC : RegisterClass<"Mips", [i32], 32, (sequence "F%u", 0, 31)>;
 
 def MSA128F16 : RegisterClass<"Mips", [f16], 128, (sequence "W%u", 0, 31)>;
 
 def MSA128B: RegisterClass<"Mips", [v16i8], 128,
                            (sequence "W%u", 0, 31)>;
 def MSA128H: RegisterClass<"Mips", [v8i16, v8f16], 128,
                            (sequence "W%u", 0, 31)>;
 def MSA128W: RegisterClass<"Mips", [v4i32, v4f32], 128,
                            (sequence "W%u", 0, 31)>;
 def MSA128D: RegisterClass<"Mips", [v2i64, v2f64], 128,
                            (sequence "W%u", 0, 31)>;
 def MSA128WEvens: RegisterClass<"Mips", [v4i32, v4f32], 128,
                                 (decimate (sequence "W%u", 0, 31), 2)>;
 
 def MSACtrl: RegisterClass<"Mips", [i32], 32, (add
   MSAIR, MSACSR, MSAAccess, MSASave, MSAModify, MSARequest, MSAMap, MSAUnmap,
   (sequence "MSA%u", 8, 31))>, Unallocatable;
 
 // Hi/Lo Registers
 def LO32 : RegisterClass<"Mips", [i32], 32, (add LO0)>;
 def HI32 : RegisterClass<"Mips", [i32], 32, (add HI0)>;
 def LO32DSP : RegisterClass<"Mips", [i32], 32, (sequence "LO%u", 0, 3)>;
 def HI32DSP : RegisterClass<"Mips", [i32], 32, (sequence "HI%u", 0, 3)>;
 def LO64 : RegisterClass<"Mips", [i64], 64, (add LO0_64)>;
 def HI64 : RegisterClass<"Mips", [i64], 64, (add HI0_64)>;
 
 // Hardware registers
 def HWRegs : RegisterClass<"Mips", [i32], 32, (sequence "HWR%u", 0, 31)>,
              Unallocatable;
 
 // Accumulator Registers
 def ACC64 : RegisterClass<"Mips", [untyped], 64, (add AC0)> {
   let Size = 64;
 }
 
 def ACC128 : RegisterClass<"Mips", [untyped], 128, (add AC0_64)> {
   let Size = 128;
 }
 
 def ACC64DSP : RegisterClass<"Mips", [untyped], 64, (sequence "AC%u", 0, 3)> {
   let Size = 64;
 }
 
 def DSPCC : RegisterClass<"Mips", [v4i8, v2i16], 32, (add DSPCCond)>;
 
 // Coprocessor 0 registers.
 def COP0 : RegisterClass<"Mips", [i32], 32, (sequence "COP0%u", 0, 31)>,
            Unallocatable;
 
 // Coprocessor 2 registers.
 def COP2 : RegisterClass<"Mips", [i32], 32, (sequence "COP2%u", 0, 31)>,
            Unallocatable;
 
 // Coprocessor 3 registers.
 def COP3 : RegisterClass<"Mips", [i32], 32, (sequence "COP3%u", 0, 31)>,
            Unallocatable;
 
 // Stack pointer and global pointer classes for instructions that are limited
 // to a single register such as lwgp/lwsp in microMIPS.
 def SP32 : RegisterClass<"Mips", [i32], 32, (add SP)>, Unallocatable;
 def SP64 : RegisterClass<"Mips", [i64], 64, (add SP_64)>, Unallocatable;
 def GP32 : RegisterClass<"Mips", [i32], 32, (add GP)>, Unallocatable;
 def GP64 : RegisterClass<"Mips", [i64], 64, (add GP_64)>, Unallocatable;
 
 // Octeon multiplier and product registers
 def OCTEON_MPL : RegisterClass<"Mips", [i64], 64, (add MPL0, MPL1, MPL2)>,
                  Unallocatable;
 def OCTEON_P : RegisterClass<"Mips", [i64], 64, (add P0, P1, P2)>,
                Unallocatable;
 
 // Register Operands.
 
 class MipsAsmRegOperand : AsmOperandClass {
   let ParserMethod = "parseAnyRegister";
 }
 
 def GPR64AsmOperand : MipsAsmRegOperand {
   let Name = "GPR64AsmReg";
   let PredicateMethod = "isGPRAsmReg";
 }
 
 def GPR32ZeroAsmOperand : MipsAsmRegOperand {
   let Name = "GPR32ZeroAsmReg";
   let PredicateMethod = "isGPRZeroAsmReg";
 }
 
 def GPR32NonZeroAsmOperand : MipsAsmRegOperand {
   let Name = "GPR32NonZeroAsmReg";
   let PredicateMethod = "isGPRNonZeroAsmReg";
 }
 
 def GPR32AsmOperand : MipsAsmRegOperand {
   let Name = "GPR32AsmReg";
   let PredicateMethod = "isGPRAsmReg";
 }
 
 def GPRMM16AsmOperand : MipsAsmRegOperand {
   let Name = "GPRMM16AsmReg";
   let PredicateMethod = "isMM16AsmReg";
 }
 
 def GPRMM16AsmOperandZero : MipsAsmRegOperand {
   let Name = "GPRMM16AsmRegZero";
   let PredicateMethod = "isMM16AsmRegZero";
 }
 
 def GPRMM16AsmOperandMoveP : MipsAsmRegOperand {
   let Name = "GPRMM16AsmRegMoveP";
   let PredicateMethod = "isMM16AsmRegMoveP";
 }
 
 def GPRMM16AsmOperandMovePPairFirst : MipsAsmRegOperand {
   let Name = "GPRMM16AsmRegMovePPairFirst";
   let PredicateMethod = "isMM16AsmRegMovePPairFirst";
 }
 
 def GPRMM16AsmOperandMovePPairSecond : MipsAsmRegOperand {
   let Name = "GPRMM16AsmRegMovePPairSecond";
   let PredicateMethod = "isMM16AsmRegMovePPairSecond";
 }
 
+def CPU16AsmOperand : MipsAsmRegOperand {
+  let Name = "CPU16AsmReg";
+  let PredicateMethod = "isCPU16AsmReg";
+}
+
 def ACC64DSPAsmOperand : MipsAsmRegOperand {
   let Name = "ACC64DSPAsmReg";
   let PredicateMethod = "isACCAsmReg";
 }
 
 def HI32DSPAsmOperand : MipsAsmRegOperand {
   let Name = "HI32DSPAsmReg";
   let PredicateMethod = "isACCAsmReg";
 }
 
 def LO32DSPAsmOperand : MipsAsmRegOperand {
   let Name = "LO32DSPAsmReg";
   let PredicateMethod = "isACCAsmReg";
 }
 
 def CCRAsmOperand : MipsAsmRegOperand {
   let Name = "CCRAsmReg";
 }
 
 def AFGR64AsmOperand : MipsAsmRegOperand {
   let Name = "AFGR64AsmReg";
   let PredicateMethod = "isFGRAsmReg";
 }
 
 def StrictlyAFGR64AsmOperand : MipsAsmRegOperand {
   let Name = "StrictlyAFGR64AsmReg";
   let PredicateMethod = "isStrictlyFGRAsmReg";
 }
 
 def FGR64AsmOperand : MipsAsmRegOperand {
   let Name = "FGR64AsmReg";
   let PredicateMethod = "isFGRAsmReg";
 }
 
 def StrictlyFGR64AsmOperand : MipsAsmRegOperand {
   let Name = "StrictlyFGR64AsmReg";
   let PredicateMethod = "isStrictlyFGRAsmReg";
 }
 
 def FGR32AsmOperand : MipsAsmRegOperand {
   let Name = "FGR32AsmReg";
   let PredicateMethod = "isFGRAsmReg";
 }
 
 def StrictlyFGR32AsmOperand : MipsAsmRegOperand {
   let Name = "StrictlyFGR32AsmReg";
   let PredicateMethod = "isStrictlyFGRAsmReg";
 }
 
 def FCCRegsAsmOperand : MipsAsmRegOperand {
   let Name = "FCCAsmReg";
 }
 
 def MSA128AsmOperand : MipsAsmRegOperand {
   let Name = "MSA128AsmReg";
 }
 
 def MSACtrlAsmOperand : MipsAsmRegOperand {
   let Name = "MSACtrlAsmReg";
 }
 
 def GPR32ZeroOpnd : RegisterOperand<GPR32ZERO> {
   let ParserMatchClass = GPR32ZeroAsmOperand;
 }
 
 def GPR32NonZeroOpnd : RegisterOperand<GPR32NONZERO> {
   let ParserMatchClass = GPR32NonZeroAsmOperand;
 }
 
 def GPR32Opnd : RegisterOperand<GPR32> {
   let ParserMatchClass = GPR32AsmOperand;
 }
 
 def GPRMM16Opnd : RegisterOperand<GPRMM16> {
   let ParserMatchClass = GPRMM16AsmOperand;
 }
 
 def GPRMM16OpndZero : RegisterOperand<GPRMM16Zero> {
   let ParserMatchClass = GPRMM16AsmOperandZero;
 }
 
 def GPRMM16OpndMoveP : RegisterOperand<GPRMM16MoveP> {
   let ParserMatchClass = GPRMM16AsmOperandMoveP;
   let EncoderMethod = "getMovePRegSingleOpValue";
 }
 
 def GPRMM16OpndMovePPairFirst : RegisterOperand<GPRMM16MovePPairFirst> {
   let ParserMatchClass = GPRMM16AsmOperandMovePPairFirst;
 }
 
 def GPRMM16OpndMovePPairSecond : RegisterOperand<GPRMM16MovePPairSecond> {
   let ParserMatchClass = GPRMM16AsmOperandMovePPairSecond;
 }
 
+def CPU16Opnd : RegisterOperand<CPU16Regs> {
+  let ParserMatchClass = CPU16AsmOperand;
+}
+
 def GPR64Opnd : RegisterOperand<GPR64> {
   let ParserMatchClass = GPR64AsmOperand;
 }
 
 def DSPROpnd : RegisterOperand<DSPR> {
   let ParserMatchClass = GPR32AsmOperand;
 }
 
 def CCROpnd : RegisterOperand<CCR> {
   let ParserMatchClass = CCRAsmOperand;
 }
 
 def HWRegsAsmOperand : MipsAsmRegOperand {
   let Name = "HWRegsAsmReg";
 }
 
 def COP0AsmOperand : MipsAsmRegOperand {
   let Name = "COP0AsmReg";
 }
 
 def COP2AsmOperand : MipsAsmRegOperand {
   let Name = "COP2AsmReg";
 }
 
 def COP3AsmOperand : MipsAsmRegOperand {
   let Name = "COP3AsmReg";
 }
 
 def HWRegsOpnd : RegisterOperand<HWRegs> {
   let ParserMatchClass = HWRegsAsmOperand;
 }
 
 def AFGR64Opnd : RegisterOperand<AFGR64> {
   let ParserMatchClass = AFGR64AsmOperand;
 }
 
 def StrictlyAFGR64Opnd : RegisterOperand<AFGR64> {
   let ParserMatchClass = StrictlyAFGR64AsmOperand;
 }
 
 def FGR64Opnd : RegisterOperand<FGR64> {
   let ParserMatchClass = FGR64AsmOperand;
 }
 
 def StrictlyFGR64Opnd : RegisterOperand<FGR64> {
   let ParserMatchClass = StrictlyFGR64AsmOperand;
 }
 
 def FGR32Opnd : RegisterOperand<FGR32> {
   let ParserMatchClass = FGR32AsmOperand;
 }
 
 def StrictlyFGR32Opnd : RegisterOperand<FGR32> {
   let ParserMatchClass = StrictlyFGR32AsmOperand;
 }
 
 def FGRCCOpnd : RegisterOperand<FGRCC> {
   // The assembler doesn't use register classes so we can re-use
   // FGR32AsmOperand.
   let ParserMatchClass = FGR32AsmOperand;
 }
 
 def FCCRegsOpnd : RegisterOperand<FCC> {
   let ParserMatchClass = FCCRegsAsmOperand;
 }
 
 def LO32DSPOpnd : RegisterOperand<LO32DSP> {
   let ParserMatchClass = LO32DSPAsmOperand;
 }
 
 def HI32DSPOpnd : RegisterOperand<HI32DSP> {
   let ParserMatchClass = HI32DSPAsmOperand;
 }
 
 def ACC64DSPOpnd : RegisterOperand<ACC64DSP> {
   let ParserMatchClass = ACC64DSPAsmOperand;
 }
 
 def COP0Opnd : RegisterOperand<COP0> {
   let ParserMatchClass = COP0AsmOperand;
 }
 
 def COP2Opnd : RegisterOperand<COP2> {
   let ParserMatchClass = COP2AsmOperand;
 }
 
 def COP3Opnd : RegisterOperand<COP3> {
   let ParserMatchClass = COP3AsmOperand;
 }
 
 def MSA128F16Opnd : RegisterOperand<MSA128F16> {
   let ParserMatchClass = MSA128AsmOperand;
 }
 
 def MSA128BOpnd : RegisterOperand<MSA128B> {
   let ParserMatchClass = MSA128AsmOperand;
 }
 
 def MSA128HOpnd : RegisterOperand<MSA128H> {
   let ParserMatchClass = MSA128AsmOperand;
 }
 
 def MSA128WOpnd : RegisterOperand<MSA128W> {
   let ParserMatchClass = MSA128AsmOperand;
 }
 
 def MSA128DOpnd : RegisterOperand<MSA128D> {
   let ParserMatchClass = MSA128AsmOperand;
 }
 
 def MSA128CROpnd : RegisterOperand<MSACtrl> {
   let ParserMatchClass = MSACtrlAsmOperand;
 }
